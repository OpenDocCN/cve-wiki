# CVE-2019-0808 - SecIN 社区 - 博客园

> 原文：[`www.cnblogs.com/SecIN/p/16505747.html`](https://www.cnblogs.com/SecIN/p/16505747.html)

一、 漏洞信息

CVE-2019-0808 是发生在 win32k 中的一个空指针解引用漏洞，根据网上的 blog 介绍该漏洞在 win32k!xxxMNMouseMove 中产生。

二、 测试环境及漏洞复现

## 测试环境

POC：[`github.com/ze0r/cve-2019-0808-poc`](https://www.sec-in.com/outLinkPage/?target=https://github.com/ze0r/cve-2019-0808-poc)

靶机： win10 x86 SP1

## 漏洞复现

![wKg0C2I0PpCAAkfvAACZSGfv9w448.png](img/e763d1c24b30dea5a30ce34da56ad5c0.png)

三、 漏洞成因分析

## 补丁分析

通过 bindiff 对 xxxMNMouseMove 函数进行对比，发现 win32k!xxxMNFindWindowFromPoint 函数新增对菜单窗口对象的校验。

![wKg0C2I0PpAM3ZAAA6nQmOih8069.png](img/a7db9dc1b22ea1a10c86dcd44f1fe0db.png)

对 win32k!xxxMNFindWindowFromPoint 进行详细分析时，可以看到 xxxSendMessage 成功获取到菜单窗口对象句柄后，通过 HMValidateHandleNoSecure 获取对应的菜单窗口对象，随后直接返回。

![wKg0C2I0PuKAWp2UAAA3rdyuPtw522.png](img/a4a2413ce0f009e5c8d0214f03123b3b.png)

而在补丁文件中，HMValidateHandleNoSecure 成功获取菜单窗口对象后会进行一系列的安全检查后（保证 tagWndMenu、tagWnd、tagPopuMenu、tagMenu 这四个对象均存在且不为 NULL）才会返回。此时也猜测到这个漏洞产生的原因大概率是空指针解引用。

![wKg0C2I0PuyAYQC3AABOk5cNEBo965.png](img/969d797b56cb2d03dc00c211d92dafd4.png)

## 成因分析

在补丁分析中，我们猜测这是一个空指针解引用的洞，这里结合 POC 去印证。下图为执行 POC 后 windbg 抓到的 cash 现场，从堆栈中可以看到蓝屏触发点在 win32!MNGetItem 函数。

![wKg0C2I0PvqANW5PAACDCFaFaow114.png](img/a2e2cc201b22420618c5f94c90cf64ce.png)

此时进行精准定位后，就是对 ecx+0x20 的 poi 操作发生错误。

![wKg0C2I0PweAEpbJAAAtQcgR1Us440.png](img/54e53b548da5bd7616dbdd2616e76a5b.png)

进一步调试后，我们发现 ecx 的值居然也为空！！！

![wKg0C2I0PxCAEVkAAAPyrqVFmk117.png](img/2b4f5857ae35ea1d8c89ac7f904f3685.png)

结合 IDA 对 ecx 的值进行溯源, 发现其存储的值是 ptagMenu。

![wKg0C2I0PxmAIbCnAABNkeRmmiM437.png](img/2a4e1b98e99e2b0b8731e9963d4bfb70.png)

而 ptagMenu 的值是由菜单弹出对象 tagPopuMenu+0x14 提供的。

![wKg0C2I0PyKASHRJAAAOX8S8dUQ423.png](img/ba418c2f4245b7ff792f2bbb8aa2a30b.png)

最终，我们溯源完成后知道 ptagPopuMenu 的值正是由通过 xxxMNFindWindowFromPoint 函数中 HMValidateHandleNoSecure 返回的菜单窗口对象 tagMenuWnd+0xb0 得到的。

![wKg0C2I0PyqAcfH5AAAPWBeNryo915.png](img/fda7ffa0cbe91886f6318552942f8fc2.png)

至此，空指针解引用产生的原因已然明了。

四、 漏洞利用分析

漏洞利用分析部分是结合 EXP，对其漏洞构造、提权利用进行详细阐述,方式为 Q-A 模式。

## 问题一，如何构造空的菜单对象（ptagPopupMenu->spmenu=NULL）

在漏洞成因过程中知道，tagMenu 是由 tagPopuMenu+0x14 提供的，而 tagPopuMenu 是由 tagMenuWnd+0xb0 提供的。tagMenuWnd 是在 xxxMNFindWindowFromPoint 在 xxxSendMessage 获取的弹出菜单句柄后通过 HMValidateHandleNoSecure 得到的。

![wKg0C2I0P1OAAtt9AAA7hEZbikc989.png](img/195f109685e52a42a17d60e7ac402829.png)

从 windbg 的堆栈可以看到漏洞函数 xxxMNUpdateDraggingInfo 是由 xxxMNMouseMove 调用的，另外在 window 中 win32k!xxxMNMouseMove 是菜单窗口过程处理函数用来处理鼠标在菜单内移动的消息，如果此时鼠标由主弹出菜单移动到了子弹出菜单，那么在 win32k!xxxMNFindWindowFromPoint 内部就会通过 xxxSendMessage 对子弹出菜单发送消息来获取子弹出菜单的句柄，用来在后续代码中对子弹出菜单发送消息来完成绘制和鼠标选中等效果。

因此在 EXP 对应会创建两个弹出菜单并将其设置成为非模拟态（原因是模拟态会导致其他其他菜单发生阻塞，无法正常接收消息）

![wKg0C2I0P12AGRS3AABA8cdA1M0022.png](img/5ca68455185055e24544eab4824a6129.png)

与此同时去创建一个伪造菜单窗口（tagfakeMenuwnd->spmenu==NULL），xxxSendMessage 发送消息后替换其返回值（正常应该返回 hMenuSub）。Ps：CSDN 中也有定义 lpClassName 为#32768 时，创建的是菜单窗口。

![wKg0C2I0P3KAABOOAAA9ViC2W8c385.png](img/6fb47cf05ee713da6601565d36f249dc.png)

弹出菜单创建后，还需要一个窗口作为媒介来传递消息。

![wKg0C2I0P3qAOO78AAAt8QpuMak890.png](img/469d89b6e07cede605970df037bf2558.png)

TrackPopupMenuEx 的作用是在桌面上显示弹出菜单。

![wKg0C2I0P4OAbQL4AAAPGeKP690582.png](img/8202fe3bad45fa7584dfd3aa26c119fe.png)

弹出菜单以及伪造窗口等都成功创建后，我们要想办法将 xxxSendMessage 的返回值替换为 hWndFakeMenu，这里是通过 SetWindowsHookEx 和 SetWinEventHook 实现的。

![wKg0C2I0P4qAKfsZAAAXvft9uBQ625.png](img/9244d04c0833e3b684d22a047211cc0b.png)

下面就这两处 hook 的原因及作用进行详细介绍：

1.  SetWinEventHook

这里是对 EVENT_SYSTEM_MENUPOPUPSTART 事件进行了 hook，原因是在 TrackPopupMenuEx 的内部实现 xxxTrackPopupMenuEx 中对菜单窗口（tagMenuWnd）、弹出菜单对象（tagPopupMenu）以及 tagMENUSTATE 创建并初始化后，会通过 xxxWindowEvent 向用户层发送 EVENT_SYSTEM_MENUPOPUPSTART 事件消息通知应用层的事件回调。

![wKg0C2I0P5SAdDVVAAAmFo8SuZ4639.png](img/4b33622aea44b7e869e5345231ba13b6.png)

当弹出菜单成功显示后，向用户层发送 EVENT_SYSTEM_MENUPOPUPSTART 事件。

![wKg0C2I0P5yAH52sAAAnS2QnWXY051.png](img/f068486445ef0b173ca54d222c23fd0d.png)

注册 Event Hook 后，首先在主弹出菜单（hMenuRoot）绘制完成后第一次进入此事件回调

![wKg0C2I0P6eAeMmBAACQj3HF8CM355.png](img/cdaa69741c0e7c7d7398fa622efa4fa6.png)

并向其发送 WM_LBUTTONDOWN 消息即按下左键显示出子弹出菜单（hMenuSub）

![wKg0C2I0P6AZBuAAAZdnGdVac423.png](img/81c91f7501a45b84997297dbbbbfbf9d.png)

子弹出菜单的显示是我们第二次进入事件回调并向 hMenuSub 发送 WM_MOUSEMOVE 消息从而形成一个从主弹出菜单到子弹出菜单的拖拽动作。

![wKg0C2I0P7qALLh5AAEyDGnj0A398.png](img/533610abe06ce86c7ed50fa545e46867.png)

拖拽动作成功实现后，EXP 就会顺利进行到 xxxMNMouseMove 函数中。

2.SetWindowsHookEx

用户层成功捕捉到由 xxxMNFindWindowFromPoint 中的 xxxSendMessage 发来的 WM_MN_FINDMENUWINDOWFROMPOINT 消息后通过 SetWindowLongPtr 将子弹出菜单窗口对应的过程函数（DefWindowProc）更改为 SubMenuProc。

![wKg0C2I0P9GAAJ3CAAAkKMbfg4624.png](img/740c80feae62b856b837d2ab4061903d.png)

SubMenuProc 最终返回用户态构造的窗口对象句柄 hWndFakeMenu 作为 xxxMNFindWindowFromPoint 函数调用 xxxSendMessage 的返回值，最终得到一个

ptagPopupMenu->spmenu=NULL 的空指针。

![wKg0C2I0P9qAVPvWAAAuPJjyy3Y281.png](img/6194ec801c71376c033ab506cb313762.png)

![wKg0C2I0P96AQ8VDAAAxMKKbhU324.png](img/5a6546aa9219f0f5518e2c60a557a0f1.png)

到这为止，已经成功实现了 xxxMNFindWindowFromPoint 函数调用 xxxSendMessage 后返回的是伪造的窗口对象。但是，这并不代表着已经能够成功触发空指针解引用的操作。原因是第二次触发 DisplayEventProc 事件回调后，EXP 向子弹出菜单窗口发送 WM_MOUSEMOVE 消息时就会在 R0 中调用一次 xxxMNMouseMove。

![wKg0C2I0PiAdqNlAAERmwx8kKo565.png](img/d467154b52797705cb9feab659b99204.png)

此时，窗口句柄虽然可以被替换但在成功替换后，xxxMNMouseMove 往下执行时并不会去调用 xxxMNUpdateDraggingInfo。

![wKg0C2I0PKAMvxvAAAqMEy6s9Y014.png](img/77f461fd501e6d002b8184e3de48f3e7.png)

通过 IDA 可以看到在 xxxMNMouseMove 中检查了 tagMENUSTATE 的 fInDoDragDrop 标志位是否置位，才会进入 xxxMNUpdateDraggingInfo 函数。

![wKg0C2I0PqARccOAAAc86SqbBg305.png](img/3fa28dd93754c8b2a7a28396ea516833.png)

DisplayEventProc 事件回调中虽然发送 WM_MOUSEMOVE 能够成功进入 xxxMNFindWindowFromPoint 的逻辑中，但是由于 fInDoDragDrop 没有被置位，因此并不能触发空指针解引用。

## 问题二，如何在 xxxMNFindWindowFromPoint 函数成功获取伪造窗口句柄成功后 exp 能够顺利进入 xxxMNUpdateDraggingInfo 的执行逻辑，触发空指针解引用的操作

对于这个问题，网上大神的 blog 给出了解决方案。我们可以通过手动调用 NtUserMNDragOver 函数来将 fInDoDragDrop 置位。

![wKg0C2I0QAAOtpnAAAeKuwEApA630.png](img/2a40ef14efabf26bcc65c1ce31246a85.png)

最后还需控制窗口句柄替换时机，设置一个全局变量 bOnDraging 在事件回调发送 xxxMNMouseMove 消息时 xxxMNFindWindowFromPoint 的 xxxSendMessage 返回正确的窗口句柄。

![wKg0C2I0QCGAMAChAAAMbWHh8qo949.png](img/05ccd49587dc60177e685c04809819eb.png)

在我们手动调用 NtUserMNDragOver 后进入 xxxMNFindWindowFromPoint 的 xxxSendMessage 时替换子菜单窗口的窗口过程，因此我们的窗口过程回调需要稍作修改，并在手动调用 NtUserMNDragOver 前将全局变量 bOnDrag 置 1：

![wKg0C2I0QC6AP7joAAAUEYyjfYE546.png](img/88dd1af1f06c50e8f41b7f91ce00eac2.png)

至此，可以实现稳定的触发漏洞。

## 问题三，如何构造任意地址覆盖写漏洞

在漏洞成因分析中我们知道，产生崩溃的点是在 xxxMNUpdateDraggingInfo-> MNGetpItem 中，具体是 spmenu 的空指针解引用。而对于此类漏洞 Win7 中用户态可以通过 ntdll!NtAllocateVirtualMemory 函数分配零页内存利用。分配零页内存的原理比较简单，不再详述：

![wKg0C2I0QEGAfO6oAAA2Bh13Spg731.png](img/2184c3295e413004e21a6ce26da350e9.png)

零页内存分配成功后，MNGetpItem 函数中的对于菜单对象的取值操作并不会触发异常，我们可以看到此时 pMenu 的地址为 0x0, pMenu->cItems [0x00000020] 也是可控数据。

![wKg0C2I0QEqAd16GAAA9fqMSk4405.png](img/5a3f507c92ade9695493bb75637674fb.png)

接着在下方的 if 判断中 uDraggingIndex < pMenu->cItems=0 不成立，导致返回 pItem=0。我们需要控制程序流程走到红框分支，返回可控数据

![wKg0C2I0QFKAARtrAAAUbCNPlw181.png](img/2a43599f7141e98d6a310ff48cf06c4f.png)

因此需要在[00000020]设置一个合适的值（这里设置为 0xffffffff）进入 if 分支。

![wKg0C2I0QFqAEI3qAAAeGGR6MuY241.png](img/3191d96aeb0f1c722cb3313bc1f42b3e.png)

返回值为 uDraggingINdex*6C+[00000034]

![wKg0C2I0QGOAaEphAABBdfgFchA479.png](img/f6113520b28890c168495ab7b81653f5.png)

uDraggingINdex 的值可以通过 wParam+0x10 去获取

![wKg0C2I0QGuAETOOAAAzE8ALZzg243.png](img/b940f0b71a63ea829eb35a4b5352d0e9.png)

[00000034]是我们可控的数据，因此 MNGetpItem 的返回值也是可控的。接着往下发现在 xxxMNUpdateDraggingInfo-> xxxMNSetGapState 存在位修改操作

![wKg0C2I0QHOAeDcuAAAuXhDWBo528.png](img/a80c3838e689fa2c2381be536f549289.png)

想必看到这里，我们知道此逻辑能够实现任意地地址的有限修改。具体如下：

addressToWrite = ret+0x4 = uDraggingINdex*6C+[00000034]+0x4

上述表达式 addressToWrite 代表着准备改写的任意地址,因此我们仅需设置[00000034]处的地址即可。

[00000034] = addressToWrite - uDraggingINdex*6C - 0x4

![wKg0C2I0QH2AP4mDAAA5edwlVec895.png](img/cf677ceefaf1851c08eabb571d172302.png)

至此，我们就实现了指定地址值的有限修改功能。

## 问题四,如何实现本地提权利用（LPE）

通过分析 exp 知道，准备修改的地址是一个窗口对象 tagWnd+0x90 处的数据即 cbwndExtra 的值，cbwndExtra 为此窗口扩展数据的大小，此处将其修改为 0x4000000 一个超长 buf,目的是对其相邻的窗口进行越界写。

![wKg0C2I0QIAKFOAAAPCUPthmM313.png](img/4291948f1696542629c360aff28ec312.png)

1.  窗口对象喷射

首先申请 100 个窗口对象

![wKg0C2I0QJuAMoHfAAAo5EbO4862.png](img/33c60a5630a14aac536827d1bb944e4c.png)

通过 pHmValidateHandle 函数泄露窗口对象的地址并且以两个窗口的地址差小于 0x3fd00 为判断依据去寻找两个相邻的窗口对象。

![wKg0C2I0QKOAWGm0AABgywlxTyo704.png](img/3337f2964db6fb1bbe833623259932ca.png)

![wKg0C2I0QKmAM0iAAAA7B0qMPSQ894.png](img/e55107176441bc2905c36e0c7c5c8e37.png)

成功找到后，将地址较高的窗口对象设置为 primaryWindow，另外一个设置为 secondaryWindow。

![wKg0C2I0QLKALsMoAABDJoI1Gh0481.png](img/089d217e2117a6bbbe94dbe9a0bb50d0.png)

最后通过漏洞能力将 primaryWindow 的 cbwndExtra 修改为 0x40000000。

![wKg0C2I0QLqAPvLlAAARrcWgVPk813.png](img/69cbde83be411b98952420542b408288.png)

2.越界写，执行 shellcode

xxxMNMouseMove 执行完 xxxMNUpdateDraggingInfo 并且成功将 primaryWindow 对象的 cbwndExtra 字段修改为 0x4000000 后，继续向下执行最后会向子菜单窗口发送 0x1E5 消息。

![wKg0C2I0QMqAcwBcAAAdszIpnM4641.png](img/a5764bae31539cb81d3165871dce20be.png)

EXP 成功拦截到发来的 1E5 消息后，开始计算 primaryWindow 对象末尾到 secondaryWindow 对象的 strName.buffer 的差值（offset）

![wKg0C2I0QNSANaR1AAAv7VP8Vds809.png](img/5123116d2cb9343c555af7c58d02de42.png)

![wKg0C2I0QNmALChQAAAb94cPDWo592.png](img/21b7a7619fe54051507123956d907695.png)

SetWindowLongA 将 secondaryWindowAddress 的 strName.buffer 的地址修改为 secondaryWindow 窗口对象的 0x16 的地址。

![wKg0C2I0QOeAZeSVAAAYfBfem88301.png](img/32f33628232886b6bfcf981deb3f48de.png)

![wKg0C2I0QOqAatdPAABJG9ztg8691.png](img/f5bb51f83eb23c9e8cb95d94d7b9fdb6.png)

接着用 SetWindowTextA 将 bServerSideWindowProc 置为 1，从而可以在内核执行我们的窗口过程函数。

![wKg0C2I0QPOAdXKAAAdDAvUdc472.png](img/da233c442b195d78266691eb55d7ee49.png)

![wKg0C2I0QPeAKcAEAAAeRJ9QkiU555.png](img/be5279ead42c19ac6d37e29393e41734.png)

修改 0x16 偏移的原因如下图所示：

![wKg0C2I0QPAeyx3AABeaVHKf8847.png](img/84510432fbd575ebc4b583836f94aae5.png)

最后向 secondaryWindow 窗口发送 WM_ENTERIDLE 消息执行 shellcode(内核执行)。

![wKg0C2I0QReAAQDdAAA0PrncNk694.png](img/818cbb779c7ae76be5996c88cf63911f.png)

```
secondaryWindow 成功接收到 WM_ENTERIDLE 消息后首先会通过 cs 寄存器的值去判断当前执行上下文是否在内核态，之后开始执行 shellcode，替换 token。 
```

![wKg0C2I0QSaATslHAABJkQeifds532.png](img/3fdeac7aa924f91953ce6dc24a04b5e1.png)

```
 Shellcode 中除了必要的 token 替换，还清空了进程的 Job 对象指针，这是因为在 Chrome 的渲染进程中，即使 shellcode 替换了 system 进程的 token，当前进程的 token 依然会继承自 Job 对象，并且 Job 不允许 Chrome 渲染进程产生新进程，因此需要先清空当前进程的 Job 对象指针。 
```

![wKg0C2I0QTuATpM3AAA7yXW6GkQ343.png](img/667c7ac3bb83e7a3f617e7f63ff506f2.png)

```
至此漏洞利用过程分析结束。 
```