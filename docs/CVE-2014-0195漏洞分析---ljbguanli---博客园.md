# CVE-2014-0195 漏洞分析 - ljbguanli - 博客园

> 原文：[`www.cnblogs.com/ljbguanli/p/6879717.html`](https://www.cnblogs.com/ljbguanli/p/6879717.html)

Watching the industry respond to the [Heartbleed](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160) vulnerability has been fascinating.  This bug had widespread impact with thousands of servers left vulnerable, numerous private keys compromised, and companies quick to jump on the bandwagon to gain a marketing advantage. All this activity rekindled the conversation around the security offered by open source projects and the lack of financial support provided to the projects used in critical infrastructure.

While all this is going on, researchers are upping their efforts to review OpenSSL source code to find additional vulnerabilities.  This left us wondering: “What will we find next?”  Well, it didn’t take long for another critical OpenSSL vulnerability to show up in the queues at the Zero Day Initiative.  Jüri Aedla is credited for the original discovery of this vulnerability. He recently made news by successfully compromising Mozilla Firefox during this year’s Pwn2Own contest.  We enjoy analyzing his work and knew immediately it would be an exciting case. 

Let’s discuss the vulnerability itself:

The issue exists wholly within ssl/d1_both.c and occurs when handling Datagram Transport Layer Security (DTLS) fragments.  DTLS has a fragmentation mechanism to break up large messages for UDP. Each fragment contains a 3-byte length field, which should be the same for all fragments in a message. OpenSSL incorrectly assumes that all DTLS fragments specify the same message size.  Specifically, it trusts that the message length specified within the header of the first fragment will be invariant across all fragments.  Here is an example packet that demonstrates the issue:

![Patch.png](img/3bcb348fca9f5df5f080ac56d70efec0.png "Patch.png")

Another quick observation is that the Wireshark protocol decoder highlights the mismatch of the length values in the DTLS fragments as a protocol error.  Unfortunately, OpenSSL did not recognize this as an error condition.

![Wireshark.png](img/1bec291203a098f173f3eaf8687af9a5.png "Wireshark.png")

The relevant source code is below (as of this [commit](https://git.openssl.org/gitweb/?</p><p>p=openssl.git;a=blob;f=ssl/d1_both.c;h=d8bcd58df2b14818b8237bb70c979d62c7df5747)):

1\. Read first fragment header.

![Code1.png](img/97718015fbcf536a4fddf02df39b5f5e.png "Code1.png")

2\. Check if it is a fragment.  Fragment Length of 1 < Length of 2.

![Code2.png](img/b4626672f28785a9023a3e04da3685f7.png "Code2.png")

3\. Allocate space for new message based on length in header, as it’s the first fragment.

![Code3.png](img/725f9a9bf0374ca112c627c0565b6667.png "Code3.png")

4\. Allocate a 2-byte buffer for the whole message.

![Code4.png](img/9d55b7a6ec5541f660cc1a3df546899e.png "Code4.png")

5\. Read in the 1-byte from the first fragment.

![Code5.png](img/51610ebecae85803d847edb6875fcaae.png "Code5.png")

6\. Read second fragment header.

![Code6.png](img/7d1c7144a9ba3a37be9eb941dc4bbb05.png "Code6.png")

7\. Check if it is a fragment.  Fragment Length of 986 < Length of 987.

![Code7.png](img/42e335516da0ba797f912af6d0b832c3.png "Code7.png")

8\. Read in the 986-bytes second fragment into a 2-byte buffer.

![Code8.png](img/cbbe5cb4c8afec1a796d8631e9585a73.png "Code8.png")

Just sending this single UDP packet results in the application segfaulting and causing a denial-of-service condition, but more malicious things are possible.  As the length field is 3-bytes wide, it is theoretically possible to write up to 2²⁴ bytes of data to the process using this vulnerability.  An attacker could leverage this issue to corrupt adjacent metadata, and possibly execute code in the context of the process using OpenSSL.

The OpenSSL code does some sanity checking on the length fields in the DTLS fragments but, unfortunately, the check occurs too late and could be bypassed.  The developers even left a prophetic comment in the code about what would happen if the validation failed.

![Code9.png](img/458f307291c3fe361ba083c4b3db7bcd.png "Code9.png")

So, why is this vulnerability interesting beyond just the technical aspects?

According to the commit logs, Robin Seggelmann introduced this vulnerability into the OpenSSL code base four years ago. Yes, Robin Seggelmann is also responsible for introducing the Heartbleed vulnerability.  Two big vulnerabilities introduced by the same developer. Seggelmann is not completely to blame, of course. OpenSSL is an open source project. The ‘many eyes’ that look at this code failed to catch this bug, but a new breed of individuals are looking at this code…especially at Seggelmann’s code.  This code is now known for having vulnerabilities. There is blood in the water.  For the individuals auditing his code, the Zero Day Initiative will happily handle the work that goes into disclosing those vulnerabilities and reward you for your efforts.

[Note: The team at HP TippingPoint’s DVLabs talks about this vuln and their customer protection [here](http://hpsw.co/Yq6g7W4). Be sure to check it out!]