# CVE-2022-24481 - SecIN 社区 - 博客园

> 原文：[`www.cnblogs.com/SecIN/p/17576690.html`](https://www.cnblogs.com/SecIN/p/17576690.html)

一、漏洞信息

CVE-2022-24481 是发生在 CLFS 驱动中的一个类型混淆漏洞，通过精巧的对 blf 文件的部分数据进行构造，可使 LogBlockHeader 中的 ClientContextOffset 指向 ContainContext，从而造成类型混淆。

二、测试环境及漏洞复现

测试环境

*   POC： 4c1579c6a14bb8f3985be8a1a83c731c
*   靶机： win10 x64 专业版，21H2

漏洞复现

![wKg0C2Q2sNCADGRmAACqApdDnHs835.png](img/377ac107d2aeaf0d60d7c05ee0366871.png)

三、漏洞成因分析

CLFS 内部结构

CLFS 即通用日志文件系统是在 Windows
Vista 和 Windows Server 2003 R2 中为实现高性能而引入的日志框架，它负责提供一个高性能、通用的日志文件子系统，供专用客户端应用程序使用，提供 API 函数来创建、存储和读取日志数据。并且多个客户端可以共享以优化日志访问。CLFS 驱动本质上的作用就是对 BLF 日志进行格式解析及处理。

![wKg0C2Q2sO6AYagaAACpvUlkLHQ344.png](img/a02da399f3ecca35eb71da1ded9209c3.png)

BLF 日志的格式如上图所示，每个日志块都以一个名为**_CLFS_LOG_BLOCK_HEADER**的结构开始：

![wKg0C2Q2sPqARrwEAABiqSCl374584.png](img/eb754091e26a558557ff3c6ae849e723.png)

Checksum(0xC)字段是该 Log 文件的 CRC 校验和，在对 Log 文件进行编码/解码操作时都需要对文件进行校验，通常在 CLFS 漏洞利用实现过程中都需要绕过 CRC 校验。

![wKg0C2Q2sQOAHLjXAABIvr5kmE952.png](img/ab141fdd38c3e4a2c9158449a1bb96a2.png)

RecordOffsets(0x28)是日志块内记录的偏移量数组。CLFS
只处理指向 _CLFS_LOG_BLOCK_HEADER 末尾的第一个记录偏移量 (0x70)。当基本日志文件存储在磁盘上时，必须对其日志块进行编码。

基本日志记录存储用于将基本日志文件与容器相关联的元数据。其结构如下：

![wKg0C2Q2sQ6AcDusAAC7eLRM5CM015.png](img/f8262c5c9feeb1fffbc98439f1d9cfbb.png)

rgClients（0x1a8）和 rgContainers(0x398)字段分别是存储着 ClientContext 和 ContainerContex 偏移值的数组。

ClientContext 的结构：

![wKg0C2Q2sRqAc1pBAACd23BAMr8699.png](img/5a8451a2d9bbc1f62618b6f54ae5817e.png)

ContainerContext 的结构：

![wKg0C2Q2sSaARHRPAABWErwiK7Y466.png](img/f9baa224c7abe3050729b7ad9cfd4666.png)

pContainer(0x18) 实际上包含一个内核指针, 指向在运行时描述容器的类 CClfsContainer。当 Log 文件在磁盘上时，该字段必须设置为零。

![wKg0C2Q2sTAE3FfAAA0tptjrGE910.png](img/25c7a206a76294144cb35f715f74ca07.png)

获取 ClientContext/ContainerContext 的函数分别是 CClfsBaseFile::AcquireClientContext 及

CClfsBaseFile::AcquireContainerContext，大致流程均是先通过 CClfsBaseFile::GetBaseLogRecord 获取基本日志块的地址，然后通过 GetSymbol 函数通过偏移找到对应的 Context 结构。

![wKg0C2Q2sUqAF56AAABjhkWofRg013.png](img/0dfba8ed32fae8432a096b2fd90b0b47.png)

漏洞触发

CVE-2022-24481 漏洞原因在于 CClfsBaseFile::GetSymbol 获取 ClientContext 时对其字段的校验不够严格，攻击者进行精巧的数据布局后使 rgClients 的偏移指向 ContainerContext。

1.  添加容器（Container）

为 Log 文件添加容器，以便 BaseLogRecord 中拥有 ContainerContext。

![wKg0C2Q2sWOAVGqdAAFu8CNwg6Y117.png](img/5fc57a689ed06b2927b4b9c0bf93e7a2.png)

2.  数据构造

成功创建 Log 文件并为其添加容器后，BaseLogRecord 0x1368 和 0x1528 的偏移处分别存储着 ClientContext 和 ContainerContext

![wKg0C2Q2sYSASijsAAEP8IuGlCM728.png](img/96e2cbdf2179a302cae38f16a9adcdb2.png)

![wKg0C2Q2sZOAMxTdAADQVotuEug002.png](img/c20fffccfef66b641c0cb0b2f62e3a95.png)

数据构造的目的是为了绕过 CLFS 在解析 Log 文件对 context 的校验。

第一部分绕过 Log 文件的 crc 校验。Log 文件的 BaseLogRecord 在进行编码和解码都会进行 CRC 校验。

![wKg0C2Q2sZAfgXeAACLwg0zqks834.png](img/3fc2b327317f20a248763801064d5e67.png)

在触发过程中，为绕过 CLFS 对 Checksum 字段的检查，需要自己实现一次 CRC 校验并将结果填充至 Checksum（0xc）

![wKg0C2Q2sbmAQ6tAAAB9gRKYZpA918.png](img/3695f31885208500515daec56b0e8825.png)

第二部分，对 ClientCotext 的数据进行修改，使其能够成功的绕过 CLFS 的检查最后指向 ContainerContext。

首先，更新 _CLFS_LOG_BLOCK_HEADER 中 rgClients（0x1a8）字段，使 rgClients 存储的偏移值变为 0x1520(ContainerContext offset 为 0x1528)

![wKg0C2Q2sdqAeXPxAAAwci9d8Tg191.png](img/7cd7f7b5c47a538c4c7afc692ac205b4.png)

然后在 0x1510 及 0x1514 偏移处分别存储 ClientContext 新的起始偏移地址（0x1520）以及 ClientContext 的结尾偏移地址（0x1520+size(0x88)。

![wKg0C2Q2seOAdBwcAAB2xq6F1o761.png](img/91f64090a4c461d4df0e2197b1a0ceaa.png)

构造这两处值是为了绕过在 CClfsBaseFile::GetSymbol 函数中的相关检查，以使 CLFS 在调用

CClfsBaseFile::AcquireClientContext 能够成功获取 ClientContext。

![wKg0C2Q2se2ABCfFAAByAhTY3O4401.png](img/c1dea21524efc21c42bbaa769fd6381d.png)

完成以上步骤之后，rgClients 已成功指向 ContainerContext。

四、漏洞利用分析

漏洞成功触发之后，下一步就是要实现提权利用，对于此漏洞我们需要重点关注以下两个点：

*   借助 ClientContext 对 ContainerContext 的修改能力
*   ContainerContext 中 pContainer(可将其指向 R3 内存)

1.  修改 pContainer

成功利用该漏洞前提就是能够控制 pContainer 指向的值，第一步就是通过 ClientContext 修改 ContainerContext->pContainer 的值。由于为 Log 文件添加容器之后，需要再次调用 CreateLogFile 对 BaseLogRecord 进行一次初始化更新

![wKg0C2Q2shyAFjMAAAEiIeQLOj4265.png](img/924ecd05b8e9618e55b167547c807fcc.png)

大致逻辑首先获取 ClientContext

![wKg0C2Q2siaAHMn5AACSyNqsSFY827.png](img/b49bf841add22cfe9546dbdbf173da82.png)

将 ClientContext 中的数据保存到 CclfsLogFcbPhysical 类中，此处重点关注 rcx+20h 处的值，现存储着我们 pContainer 的目标值（r3 可控地址 0x40000000）。

![wKg0C2Q2siANRAkAACwXmg05ek578.png](img/386058d98132999401ebf0355b8ec7e7.png)

随后会调用 CClfsBaseFilePersisted::LoadContainerQ 函数加载 Container 并更新 pContainer,让其指向在运行时描述容器的类 CclfsContainer

![wKg0C2Q2sjmARHHeAAE3PWG4QIo455.png](img/aed76eb906b3c0a7955e9984c4a415aa.png)

CclfsContainer 类的前 8 个字节指向虚表

![wKg0C2Q2skGAf0W1AADZ71E8Y8745.png](img/d034d94e6d6e9e2b815e91795b6c0aa2.png)

此时 pContainer 还是指向内核的 CclfsContainer 类，我们的可控地址 0x40000000 被保存到了 CclfsLogFcbPhysical 类的 0x1a0 处，经过分析发现，在 close Log 文件句柄过程中，CLFS 会调用 CClfsLogFcbPhysical::FlushMetadata 对 ClientContext 进行更新

![wKg0C2Q2smKAEF4wAAEEdO5btwg933.png](img/7a740c0f5b3bc8e2ae3d897461b1f826.png)

实际上就是将存储在 CclfsLogFcbPhysical 类中的数据重新写回到 ClientContext。

![wKg0C2Q2sm6ACqt8AAD9KVK4Qg173.png](img/c2a8086b119e05df79ab44478fa8f388.png)

由于 ClientContext 指向 ContainerContext-0x8，这里将 0x40000000 赋给 ClientContext+0x20 就是修改 ContainerContext+0x18(pContainer)为 0x0x40000000。

2.  修改 previousMode

执行 CloseHandle 时，内核中首先会将当前线程的 previousMode 修改为内核态（0）

![wKg0C2Q2soAMVOwAAAuaXuXbos431.png](img/edd8b9567379bf5f572d62a3d68e92ce.png)

![wKg0C2Q2spKADHFtAACUELQO1cM234.png](img/ee034ed2436afc61d2248100f7a80c86.png)

待到成功执行完返回 R3 前，又会将当前线程的 previousMode 修改为用户态（1）

![wKg0C2Q2spuAXM7RAAAte8qciKo991.png](img/acd021343cada16efa2a56e2e7fef8ea.png)

![wKg0C2Q2spAFuzyAABLLZpj4uM685.png](img/ac971fe9609c76b523f09f323f95a7b4.png)

此漏洞的提权原理就是在返回 R3 前，修改当前线程的 previousMode 为 0，下图为我们自定义构造由 pContainer 指向的” CclfsContainer”.

![wKg0C2Q2sqqAKuA5AACvuQHhFKw934.png](img/9638425a3bf7920808bc4d49ec61db25.png)

0x0 为“虚表指针“，0x20 为文件句柄，0x30 为 previousMode+0x30 address

![wKg0C2Q2sreATIyAAAA5Ms7iMYs168.png](img/415986efc8907effda9e455de95e5ad1.png)

漏洞利用是发生在 CClfsLogFcbPhysical::CloseContainers 函数中

![wKg0C2Q2ssOAZuK4AAEy4Awwuw003.png](img/1eab9d29903e038c0348cd8120e78a24.png)

在 CClfsLogFcbPhysical::CloseContainers 首先通过 ContainerContext 获取到 pContainer，然后对 CclfsContainer 类进行一个清理释放。这里我们拥有一个可控函数的执行！

![wKg0C2Q2ssAHEnsAACCLfaq9iU653.png](img/357ca4851169d9bac1648fba98d33bb4.png)

CClfsContainer::Close 实现：

![wKg0C2Q2st2AKUqzAAA8XMWT9ek894.png](img/d8d8b2a22a5432afc7ceaf28b3915196.png)

提权过程：

![wKg0C2Q2suaAdRxWAABckHfKlsI239.png](img/6a9019987ac5fa11923de04be9a74edd.png)

随后调用 ObfDereferenceObjectWithTag 传入的参数为 previousMode+0x30，并利用该函数的减数机制，将 previousMode 修改为 0（内核态）

![wKg0C2Q2su2Ab1pqAADLYlp1zYE046.png](img/e6e6fd0514a5e9b2410b8810d77e7e81.png)

此时，已到达提权目的。

最后，调用可控函数 ClfsSetEndOfLog 返回错误码到 R3。

![wKg0C2Q2svaAVMgRAABfAo5dj0M647.png](img/b98588e718b8dc860d6a6f4f1db74d65.png)

在提权样本中，利用当前线程的内核执行能力将当前线程的 token 替换为 system token。

![wKg0C2Q2swmAFiZhAAAwOpcW1aI998.png](img/279301efe92e81d7630df164f1cacc9d.png)

Token 替换之后，在将 previousMode 改回 1（目的是混淆）

![wKg0C2Q2sxSAQjbQAAAzynuLjuE853.png](img/cb86aca7f15195845fc377426cd69cb0.png)

至此，分析完毕！