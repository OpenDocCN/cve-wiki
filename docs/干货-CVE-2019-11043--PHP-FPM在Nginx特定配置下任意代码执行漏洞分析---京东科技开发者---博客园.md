# 干货|CVE-2019-11043: PHP-FPM 在 Nginx 特定配置下任意代码执行漏洞分析 - 京东科技开发者 - 博客园

> 原文：[`www.cnblogs.com/jdclouddeveloper/p/11857622.html`](https://www.cnblogs.com/jdclouddeveloper/p/11857622.html)

![Alt](img/4c421a702454ffc7a936ed3df14ac660.png)

> 近期，国外安全研究员 Andrew Danau，在参加夺旗赛（CTF: Capture the
> Flag）期间，偶然发现 php-fpm 组件处理特定请求时存在缺陷：在特定 Nginx 配置下，特定构造的请求会造成 php-fpm 处理异常，进而导致远程执行任意代码。当前，作者已经在 github 上公布了相关漏洞信息及自动化利用程序。鉴于 Nginx+PHP 组合在 Web 应用开发领域拥有极高的市场占有率，该漏洞影响范围较为广泛。

#### 漏洞概述

PHP-FPM 在 Nginx 特定配置下存在任意代码执行漏洞。具体为：
使用 Nginx + PHP-FPM 搭建的服务器在使用类似如下配置的 nginx.conf 时：

```
location ~ [^/]\.php(/|$) {
        fastcgi_split_path_info ^(.+?\.php)(/.*)$;
        fastcgi_param PATH_INFO       $fastcgi_path_info;
        fastcgi_pass   php:9000;
        ... 
```

Nginx 中 fastcgi_split_path_info 在处理存在"\n"(%oA) 的 path_info 时，会将传递给 PHP-FPM 的 PATH_INFO 置为空（PATH_INFO="")，影响关键指针的指向，导致后续 path_info[0]=0 的置零操作位置可控，通过构造特定长度和内容的请求，可以覆盖写特定位置数据，插入特定环境变量，进而导致代码执行。

#### 漏洞分析

首先，分析其补丁：在进行 request_info 结构体初始化的 static void init_request_info(void)函数中，增添对 pilen 和 slen 的大小校验，规避了指针的非预期回溯移动。

```
 // php-src/sapi/fpm/fpm/fpm_main.c
     ...
     if (pt) {
        while ((ptr = strrchr(pt, '/')) || (ptr = strrchr(pt, '\\'))) {
             // 对传入 PATH_INFO 进行校验。通过判断文件状态，获取真实 PATH_INFO
             *ptr = 0;
             f (stat(pt, &st) == 0 && S_ISREG(st.st_mode)) {
             int ptlen = strlen(pt); # Path-translated CONTENT_LENGTH
             int slen = len - ptlen;  //script length
            int pilen = env_path_info ? strlen(env_path_info) : 0;  //Path info 长度 0
            int tflag = 0;
            char *path_info;

            if (apache_was_here) {
                /* recall that PATH_INFO won't exist */
                path_info = script_path_translated + ptlen;
                tflag = (slen != 0 && (!orig_path_info || strcmp(orig_path_info, path_info) != 0));
            } else {
        -       path_info = env_path_info ? env_path_info + pilen - slen : NULL; // 通过偏移设置新 env_path_info，但是未对偏移量做校验
        -       tflag = (orig_path_info != path_info);
        +       path_info = (env_path_info && pilen > slen) ? env_path_info + pilen - slen : NULL;
        +       tflag = path_info && (orig_path_info != path_info);
            }

            if (tflag) {
                if (orig_path_info) {
                char old;

                FCGI_PUTENV(request, "ORIG_PATH_INFO", orig_path_info);
                old = path_info[0];
                path_info[0] = 0; //置零操作
                if (!orig_script_name ||
                    strcmp(orig_script_name, env_path_info) != 0) {
                    if (orig_script_name) {
                        FCGI_PUTENV(request, "ORIG_SCRIPT_NAME", orig_script_name);//触发入口
                    }
                    SG(request_info).request_uri = FCGI_PUTENV(request, "SCRIPT_NAME", env_path_info);
                    } else {
                    SG(request_info).request_uri = orig_script_name;
                    }
                    path_info[0] = old;
                }
        ... 
```

其中

```
 //以 http://localhost/info.php/test?a=b 为例
     PATH_INFO=/test
     PATH_TRANSLATED=/docroot/info.php/test
     SCRIPT_NAME=/info.php
     REQUEST_URI=/info.php/test?a=b
     SCRIPT_FILENAME=/docroot/info.php
     QUERY_STRING=a=b

     pt = script_path_translated; // = env_script_filename => "/docroot/info.php/test"
    len = script_path_translated_len  // 为"/docroot/info.php/test"

    // 经过重新计算处理后
    int ptlen = strlen(pt); // strlen("/docroot/info.php")
    int pilen = env_path_info ? strlen(env_path_info) : 0;  // 即 len(PATH_INFO) "/test"
    int slen = len - ptlen;   // len("/test")

    path_info = env_path_info + pilen - slen; // pilen 取值可能未 0 或 slen, 即偏移为 0 或 -N 
```

可见，当 PATH_INFO 为空时，path_info 指向发生向前偏移，偏移长度为 test 的长度。进而 path_info[0] = 0;可以将特定位置 单字节置零。但是，普通位置的置零并不会造成 RCE，进一步利用需要将特定控制位置零，且该控制位恰巧能控制写入位置。request->env->data->pos 便是这样一处位置。这里需要说明一下各变量的存储方式。

通过 fastcgi 协议传入的各环境变量会存储到 _fcgi_request->env 这个 fcgi_hash 结构体中，供后续执行取用，结构具体定义如下：

```
 // php-src/sapi/fpm/fpm/fastcgi.c
     typedef struct _fcgi_hash_bucket {
         unsigned int              hash_value;
         unsigned int              var_len;
         char                     *var;
         unsigned int              val_len;
         char                     *val;
         struct _fcgi_hash_bucket *next;
         struct _fcgi_hash_bucket *list_next;
   } fcgi_hash_bucket;

    typedef struct _fcgi_hash_buckets {
        unsigned int               idx;
        struct _fcgi_hash_buckets *next;
        struct _fcgi_hash_bucket   data[FCGI_HASH_TABLE_SIZE];
    } fcgi_hash_buckets;

    typedef struct _fcgi_data_seg {
        char                  *pos;
        char                  *end;
        struct _fcgi_data_seg *next;
        char                   data[1];
    } fcgi_data_seg;

    typedef struct _fcgi_hash {
        fcgi_hash_bucket  *hash_table[FCGI_HASH_TABLE_SIZE];
        fcgi_hash_bucket  *list;
        fcgi_hash_buckets *buckets;
        fcgi_data_seg     *data;
    } fcgi_hash;
    ...
    /* hash table */
    //初始化操作
    static void fcgi_hash_init(fcgi_hash *h)
    {
        memset(h->hash_table, 0, sizeof(h->hash_table));
        h->list = NULL;
        h->buckets = (fcgi_hash_buckets*)malloc(sizeof(fcgi_hash_buckets));
        h->buckets->idx = 0;
        h->buckets->next = NULL;
        h->data = (fcgi_data_seg*)malloc(sizeof(fcgi_data_seg) - 1 + FCGI_HASH_SEG_SIZE); // 默认分配 (4*8 - 1) + 4096
        h->data->pos = h->data->data; //指向环境变量初始写入位置
        h->data->end = h->data->pos + FCGI_HASH_SEG_SIZE; 指向//data_seg 末尾
        h->data->next = NULL;
    }
    ... 
```

其中我们主要关注其中的 get/set 操作，实现如下：

```
 static char *fcgi_hash_get(fcgi_hash *h, unsigned int hash_value, char *var, unsigned int var_len, unsigned int *val_len)
     // 关联 FCGI_GETENV()
     {
         unsigned int      idx = hash_value & FCGI_HASH_TABLE_MASK;
        fcgi_hash_bucket *p = h->hash_table[idx];

         while (p != NULL) {
         //需要 hast_value 值相同，var_len 相同才能取出值
             if (p->hash_value == hash_value &&
                p->var_len == var_len &&
                memcmp(p->var, var, var_len) == 0) {
                *val_len = p->val_len;
                return p->val;
            }
            p = p->next;
        }
        return NULL;
    }

    static char* fcgi_hash_set(fcgi_hash *h, unsigned int hash_value, char *var, unsigned int var_len, char *val, unsigned int val_len)
    // 关联 FCGI_PUTENV()
    {
        unsigned int      idx = hash_value & FCGI_HASH_TABLE_MASK;  // 计算 hash_value 确定 index
        fcgi_hash_bucket *p = h->hash_table[idx];  //获取原有 hash_table 中的对应值

        while (UNEXPECTED(p != NULL)) {
            if (UNEXPECTED(p->hash_value == hash_value) &&
                p->var_len == var_len &&
                memcmp(p->var, var, var_len) == 0) {

                p->val_len = val_len;
                p->val = fcgi_hash_strndup(h, val, val_len);
                return p->val;
            }
            p = p->next;
        }

       if (UNEXPECTED(h->buckets->idx >= FCGI_HASH_TABLE_SIZE)) {
            fcgi_hash_buckets *b = (fcgi_hash_buckets*)malloc(sizeof(fcgi_hash_buckets));
            b->idx = 0;
            b->next = h->buckets;
            h->buckets = b;
        }

        p = h->buckets->data + h->buckets->idx;
        h->buckets->idx++;
        p->next = h->hash_table[idx];
        h->hash_table[idx] = p;
        p->list_next = h->list;
        h->list = p;

        p->hash_value = hash_value;
        p->var_len = var_len;
        p->var = fcgi_hash_strndup(h, var, var_len);
        p->val_len = val_len;
        p->val = fcgi_hash_strndup(h, val, val_len);
        return p->val;
    }

    static inline char* fcgi_hash_strndup(fcgi_hash *h, char *str, unsigned int str_len)
    // 实际操作 request->env->data,进行数据写入。
    {
        char *ret;

        if (UNEXPECTED(h->data->pos + str_len + 1 >= h->data->end)) {
        //如果准备写入的数据长度大于当前指向的 fcgi_hash_seg 大小，则向前插入新的 fcgi_hash_seg
                unsigned int seg_size = (str_len + 1 > FCGI_HASH_SEG_SIZE) ? str_len + 1 : FCGI_HASH_SEG_SIZE;//较长值，不跨越两个 seg 进行写入。
                fcgi_data_seg *p = (fcgi_data_seg*)malloc(sizeof(fcgi_data_seg) - 1 + seg_size);
                p->pos = p->data;
                p->end = p->pos + seg_size;
                p->next = h->data;
                h->data = p;
            }

            ret = h->data->pos;
           memcpy(ret, str, str_len); //于 h->data->pos 后写入数据
            ret[str_len] = 0;
            h->data->pos += str_len + 1; //后移 h->data->pos 到新的可写入位置
            return ret;
    } 
```

由此，我们可以得出：request->env->data->pos 的指向直接影响我们环境变量 Key，Value 的写入位置，只要我们控制了 char* pos 的指向，就可能覆盖已有的数据。但是，要想达成 RCE 还存在以下要求及限制：

1.  指针前移受当前 fcgi_hash_seg 空间结构影响，过短无法将 char*
    pos 置零，过长会分配到新 fcgi_hash_seg 空间。(如传递"形如"[`127.0.0.1/Somefile_exits/AAAAA.php/`](http://127.0.0.1/Somefile_exits/AAAAA.php/)"也可造成指针后移，)

2.  path_info[0] = 0 仅能将单字节置零，最好为最低位，否则会造成指针位置偏离过多。

3.  鉴于条件 2 被覆盖写的地址最低位应为 0，且其后为符合条件的可覆盖的环境变量。

4.  被覆盖位置环境变量的 key 必须与预期写入的 key 满足：var、hash_value 和 var_len 均相同，才可能被读取。

5.  执行 FCGI_PUTENV(request, "ORIG_PATH_INFO",
    orig_path_info);时，分别写入 ORIG_SCRIPT_NAME、orig_script_name（"ORIG_SCRIPT_NAME/index.php/PHP_VALUE\nAAAAAA"）。

相应地，我们可以：

1.  通过控制 query_string 的长度，使 path_info 恰好处于新 fcgi_hash_seg 的 data 首位，这时我们仅需移动 8+8+8+len("PATH_INFO\0")+N= 34 + N 即可完成对 char* pos 的篡改。满足条件 1，2 的要求。
2.  通过自定义 http header，操纵 request header 的长度将预期覆盖的环境变量放置到特定的位置（0x____00+len("ORIG_SCRIPT_NAME")+len("/index.php/")）。满足条件 3，5 要求。（在 NGINX 中，HTTP 中的请求头会以"HTTP_XXX"的形式传入 PHP-FPM，随后写入到 request-env 中）
3.  Exp 作者提供了 EBUT 这个自定义头，其 env 变量名 HTTP_EBUT 与 PHP_VALUE 在长度和 hash_value 方面相等，且 PHP_VALUE 会在后续处理中被尝试读取(ini =
    FCGI_GETENV(request, "PHP_VALUE")😉。满足条件 4 的要求。

![Alt](img/cf30c34565a03329c7cedb0d4a5307a1.png)
除此之外，鉴于 PATH_INFO 重新取值部分逻辑主要是处理 PATH_INFO 与真实 path_info 不同的情况，对开头提及的 nginx 配置项，存在一种情况，发起形如 http://localhost/index/info.php/test?a=b 的 url，可以构造以下场景

```
 //以 http://localhost/index/info.php/test?a=b 为例，index 为存在的文件
     PATH_INFO=/test
     PATH_TRANSLATED=/docroot/index/info.php/test
     SCRIPT_NAME=/index/info.php
     REQUEST_URI=/index/info.php/test?a=b
     SCRIPT_FILENAME=/docroot/index/info.php
     QUERY_STRING=a=b

     pt = script_path_translated; // = env_script_filename => "/docroot/index/info.php/test"
    len = script_path_translated_len  // 为"/docroot/index/info.php/test"

    // 经过重新计算处理后
    int ptlen = strlen(pt); // strlen("/docroot/index")
    int pilen = env_path_info ? strlen(env_path_info) : 0;  // 即 len(PATH_INFO) "/test"
    int slen = len - ptlen;   // len("/info.php/test ")

    path_info = env_path_info + pilen - slen;  // pilen < slen， 即偏移为-N 
```

此时 URL 中无需存在%0A，亦可完成指针移位，漏洞过程与上述类似，但是因为 script_name 无效，无法直观显示攻击状态，利用难度较高，不再赘述。

> path_info 指向了 request->env->data->pos 后的内存布局
> ![Alt](img/e4da0647d9612082cfc217c44d464c71.png)

#### 漏洞利用

Exp 作者利用 PHP_VALUE 向 PHP 传递多个环境变量，使 PHP 产生错误，以错误日志的形式将 webshell 输出到/tmp/a，并通过 auto_prepend_file 自动执行/tmp/a 中的恶意代码，达成 getshell。

```
 var chain = []string{
         "short_open_tag=1", //开启 php 短标签
         "html_errors=0",   // 在错误信息中关闭 HTML 标签。
         "include_path=/tmp",  //包含路径
         "auto_prepend_file=a",  //指定脚本执行前自动包含的文件，功能类似 require()。
         "log_errors=1",  //使能错误日志
         "error_reporting=2",   //指定错误级别
         "error_log=/tmp/a",  //错误日志记录文件
         "extension_dir=\"<?=\`\"",   //指定 extension 的加载目录
        "extension=\"$_GET[a]\`?>\"", //指定加载的 extension
    } 
```

#### 影响范围

在文初提到的配置下，该漏洞影响以下版本的 PHP：
7.1.x < 7.1.33
7.2.x < 7.2.24
7.3.x < 7.3.11

#### 漏洞修复

可以通过 Nginx 增添配置 try_files %uri = 404php 设置 cgi.fix_pathinfo=0 选项，临时规避漏洞影响。也可以选择使用官方已经释出的更新进行完全修复。

京东云-WAF 现已支持对该漏洞的防护，点击【[阅读](https://www.jdcloud.com/cn/products/web-application-firewall?utm_source=_cnblogs&utm_medium=Footer&utm_campaign=cnblogs_online_Developer_Community&utm_term=web-application-firewall)】，获取更多产品信息。

欢迎点击“[京东云](https://developer.jdcloud.com/?utm_source=PMM_cnblogs&utm_medium=Footer&utm_campaign=cnblogs_online_Developer_Community&utm_term=jdcloud)”了解更多精彩

![Alt](img/8c85cb2060c49e307eadf6aadbeb743e.png)

![Alt](img/2cc4b9b5396a47066369bc21b64df579.png)