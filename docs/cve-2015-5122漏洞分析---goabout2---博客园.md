# cve-2015-5122 漏洞分析 - goabout2 - 博客园

> 原文：[`www.cnblogs.com/goabout2/p/4655252.html`](https://www.cnblogs.com/goabout2/p/4655252.html)

HackTem 爆出的第二枚 0day，分析了下，做个记录。

Poc 中一开始会分配一个 Array 类型的 _ar 结构。

 ![](img/665fadd4f9fe29d987421e2b2f45752b.png)

第一次赋值

此时在 a[0 ] –a[1e-1] 处已被赋值为 Vector.<uint>(62)结构。

 ![](img/cc57cccc3ab0a502d9e7ace18068894a.png)

任意查询可发现给 vector 的长度已被赋值为 62 生成的 array  0~1e

 ![](img/73141c269b634ebd0fac467a9fe44a44.png)

之后对 1e~7e 间的 ar[i]进行赋值，每个模块为 Vector.<uint>(8),其中第一个字节设置标记位，用于之后快速定位越界单元。

 ![](img/dff8f1be78f781428ab8e93e6e79d7fc.png)

查看对应的内存，可以发现 1e~7e 中为长度为 8 的 Vector.<uint>(8)

 ![](img/94c789fc712fca9eb735d2ce0c945b85.png)

a[i]中被赋值之后的数组 1e~2e 处已被赋值

总的 a[i]内存

 ![](img/00380aa58202cc25ca5891a28bed3464.png)

对 a[i]中 1e~2e 处的单元进行赋值，赋值对象为一个 TextLine 对象

 ![](img/c9122ea07c5bcdbe361f98ab98a8d833.png)

开始赋值

 ![](img/3a1a7c6f0374da9f0427114c79c19e51.png)

赋值结束之后的内存空间

 ![](img/7bc2b1e1aaafa326b35bd43ac8a27dac.png)

此时 a[i]中赋值完毕,整体的 a 结构

 ![](img/ea257293f742f0abf4fdaf0d82f323b0.png)

     ![](img/ff86efeedfed2507d9f7de1dcf42a4d2.png)                       

获取对应的 textline 的对象

 ![](img/10744f1be28349b72cd358d2fc47f4e5.png)

对 a[i]中 1e~2e 中的 textline 单元设置 opaqueBackground 属性，该属性会导致 avm 为每个单元分配大小为 0x390 的内存空间

 ![](img/c8661316ef46ceb767a57ffec57ae74c.png)

获取对应的 textline 对象

首先调用 0418e3b3 处的函数用于返回对应的 textline 单元，获取该单元之后在 0418e3fecc 处通过 call eax 创建 0x390 大小的内存,在该函数中随后会有对 valueOf2 的操作进行判断，成功的话会由此进入 valueOf2 的判断，从而导致 uaf,而在 call eax 返回前会对 0x390 的内存空间偏移 0x320 的地方进行 6a 的赋值，通过精心的内存布局，可致使 6a 被写入到 vector 的 length 域中。

 ![](img/7f363abb1682bcde7aa67f29ce4284a2.png)

整个内存分配结束之后

生成的 vector<uint>(62)

 ![](img/2ba760abfee9e73b6ba9c766c9deff72.png)

生成的 Vector<8>

 ![](img/8c4e2af0c683100527858894c030da3b.png)

生成的 backGroundObj 空间

 ![](img/ff15528e379553f8854821a6da744c00.png)

对 textline 对象的 opaqueBackgroind 属性进行赋值，此处赋值的对象为 MyClass32，由于 array 为 Byte 属性，此时赋值的话将导致 MyClass 类的 valudfo 函数调用。

 ![](img/16a7e3d3bfd3674e4b8ed56f9f082db0.png)

进入 valueOf 函数中，对 a[i]中的 textline 对象进行释放，大小

 ![](img/f1cb3a69308e5fed6d028102225e7651.png)

释放前的 backgroudObj

 ![](img/0e8350e7143d5f12ecdafc4630fcb095.png)

完全释放 5 个 backgroudObj 之后。

 ![](img/09769009354f5262e9e2d078f1041a46.png)

释放之后立即，对 a[i]中 1e~7e 的数据单元的长度进行重置，由于 avm 中的内存管理机制，会导致之前分配的内存被优先分配，从而致使之前释放掉的 5 个 backgroudObj 的内存被重新分配的 ar 数组中的十个单元所占有。

 ![](img/5c306015de4dc9d1579ff29fbae8f352.png)

如下图所示内存出处最后一个单元外，之前所有的单元已经重新分配完毕

 ![](img/0feeae7adb51aba0ebdb5d8273adb3c9.png)

通过对比释放掉的五个 backgroundObj，此处可以在内存中搜索出是那几个单元重用了之前释放的内存，如下图所示。

 ![](img/5b9a9f6abdc5959b1ce3809efa5a5d2c.png)

之前提到该操作会导致对应 MyClass 类的 ValueOf 函数被调用，在该函数中我们释放 5 个 backgroundObj 对象，同时使用通过重置 ar[i]中 1e~7e 单元的大小，重新占有了这 5 个 backgroundObj 对象之前的空间，ValueOf 函数返回后，在其后的对应操作中，会对之前的 5 个 backgroundObj 对象中 x320 的位置进行想 x190 的赋值操作，由于重置之后的 ar[i]单元大小为 x190，因此正好导致其中某处单元的 vector 的长度值从 62 被设置为 6a。

 ![](img/f6ab5f5201d513c9be51343487bedc32.png)

整个过程如下图

 ![](img/f279d2d9cdf6e1d8297f1aa023ace238.png)

被设置的 ar[3b]单元，可见此处的 length 域已经被赋值为 6a。

 ![](img/8501f58ac0f21c888b37054925d45831.png)

获取越界的 a[i],并将其相邻的 vector 结构的长度设置成 40000000，因而获取一个超长的全内存读写 vector

![](img/4ed4f91f98f1002ffddbae05854af166.png) 

生成的全局内存读写 vector

 ![](img/5eb1463aa04ab1d8d52bc096658619c4.png)