# Rand 函数引发的安全问题 —— OSSN 任意文件读取漏洞（CVE-2020-10560） - 0DayBug - 博客园

> 原文：[`www.cnblogs.com/0daybug/p/12801280.html`](https://www.cnblogs.com/0daybug/p/12801280.html)

## 前言

Open Source Social Network（OSSN），是一款用 PHP 编写的社交网络软件。OSSN 允许用户创建一个社交网站，帮助拥有相似专业或个人兴趣的人建立社交关系。该软件拥有约 50 万下载量。

OSSN 官网地址：

[`www.opensource-socialnetwork.org/`](https://www.opensource-socialnetwork.org/)

## 漏洞简介

Open Source Social Network(OSSN)5.3 之前版本中存在一处任意文件读取漏洞（CVE-2020-10560）。漏洞因 OSSN 生成的 Site_Key 强度过低从而可以遭受被暴力破解而产生，成功破解 Site_Key 的攻击者可以利用 Site_Key 构造出任意文件读取链接，通过 components\OssnComments\ossn_com.php 文件提供的文件预览接口，读取文件。

## 漏洞分析

Open Source Social Network 应用可以从如下官网链接下载：

[`www.opensource-socialnetwork.org/download`](https://www.opensource-socialnetwork.org/download)

应用首页如下图

![](https://xzfile.aliyuncs.com/media/upload/picture/20200422115537-204ff9e2-844d-1.png)

OSSN 中提供 Comment 功能，访问者可以对帖子进行评论，见下图:

![](https://xzfile.aliyuncs.com/media/upload/picture/20200422115805-78240802-844d-1.png)

评论帖子时，用户可以上传图片以及表情，如下图红框处：

![](https://xzfile.aliyuncs.com/media/upload/picture/20200422115855-9609c852-844d-1.png)

当选择本地图片并上传后，将在评论中生成一个预览，见下图：

![](https://xzfile.aliyuncs.com/media/upload/picture/20200422115924-a78fc87e-844d-1.png)

注意，这时还没有点击发布评论，上图图片只是上传成功后的一个预览图片。该临时图像文件存储于 tmp 目录并在前端呈现了预览。

我们来看下这个临时图片文件是如何获取并在页面中展示的。查看一下图片链接，如下图：

![](https://xzfile.aliyuncs.com/media/upload/picture/20200422115956-ba4a24dc-844d-1.png)

链接如下：

[`192.167.30.119/comment/staticimage?image=UiszT0RJYStoQll2N2g5cHhmQW9PRHlCNVgrSWFKVzFQRHE4eTJqSWthVUVjUFBIb3pxME1FNUJFdk5ER2pONXI4V2pyeXJSMm9VPQ==`](http://192.167.30.119/comment/staticimage?image=UiszT0RJYStoQll2N2g5cHhmQW9PRHlCNVgrSWFKVzFQRHE4eTJqSWthVUVjUFBIb3pxME1FNUJFdk5ER2pONXI4V2pyeXJSMm9VPQ==)

我们可以猜测出 image 参数对应的字符串应该是文件地址的加密形式，只有构造出正确的 base64 字符串，攻击者就可以读取任意文件。

最重要的是，经过测试发现，访问这个链接并不需要用户登陆。任何人都可以通过这个链接直接访问我们上传的这个图片文件。

接下来分析下后台代码，看看这个 base64 字符串是如何还原出文件路径以及如何被构造出来的

上文链接对应的后台代码位于 \components\OssnComments\ossn_com.php

![](https://xzfile.aliyuncs.com/media/upload/picture/20200422120030-cef58336-844d-1.png)

在 ossn_com.php 中 case 'staticimage'分支里，程序将请求中 image 参数值取出，并进行 base64_decode 解码。见下图：

![](https://xzfile.aliyuncs.com/media/upload/picture/20200422120057-df0c69ce-844d-1.png)

随后，对解码后的值再次 base64_decode 解码，然后利用 ossn_string_decrypt 方法解码并获取文件地址。见下图：

![](https://xzfile.aliyuncs.com/media/upload/picture/20200422120121-ed0884a4-844d-1.png)

接着，通过 ossn_validate_filepath 方法对文件路径进行校验。见下图红框：

![](https://xzfile.aliyuncs.com/media/upload/picture/20200422120159-03917424-844e-1.png)

ossn_validate_filepath 方法如下图所示，可见该方法对目录遍历进行了过滤

![](https://xzfile.aliyuncs.com/media/upload/picture/20200422120230-1610ce9c-844e-1.png)

即使过滤了../ 我们仍然可以通过绝对路径来进行文件读取，例如直接读取/etc/passwd

最后，程序利用 file_get_contents 方法对文件内容进行读取，并使用 echo 进行打印。见下图红框：

![](https://xzfile.aliyuncs.com/media/upload/picture/20200422120258-26c89bde-844e-1.png)

通过阅读代码也可以验证之前的测试结果：该接口并未进行身份校验，未登录的用户依然可以通过该接口访问文件。

问题又回到了如何构造加密字符串上。我们首先来看一下程序是如何解码的，位于 libraries\ossn.lib.system.php 文件中

![](https://xzfile.aliyuncs.com/media/upload/picture/20200422120324-36909b7a-844e-1.png)

通过上图的代码看，在解码过程中，需要用到 site_key 值。

经过分析后发现，程序通过 ossn_site_settings 方法在数据库中读取 site_key 值，我们先来看一下存储于 ossn_site_settings 表中 site_key 值是什么，见下图：

![](https://xzfile.aliyuncs.com/media/upload/picture/20200422120346-4365dc70-844e-1.png)

site_key 值为 c1a725ed，可见是一个 8 位数

这样看来，只要破解出这个 8 位数的 site_key，即可构造出指向任意文件路径的链接。

我们接着分析这个 site_key 是如何生成的，生成代码位于 libraries\ossn.lib.upgrade.php 文件中，见下图：

![](https://xzfile.aliyuncs.com/media/upload/picture/20200422120409-516ddc64-844e-1.png)

通过分析上图加密过程不难发现，该 8 位随机数是通过如下方式产生的：

1.  以字符串“ ossn”开头。

2.  通过 rand 方法生成一个随机数并拼接到“ ossn”字符串后。

3.  计算此字符串的 md5 值。

4.  将字符 3-11 取出作为 site_key 值。

本次漏洞就出在计算 site_key 值的第二步，也就是通过 rand 产生随机数这一步。

关于 rand 方法，可以参考 php 官网

![](https://xzfile.aliyuncs.com/media/upload/picture/20200422120438-62894a56-844e-1.png)

在官网介绍页面中明确的给出了警告，见上图底部

**警告**

此函数不会生成加密安全值，并且不应将其用于加密目的。如果需要密码安全的值，请考虑改用 random_int(),random_bytes()或 openssl_random_pseudo_bytes()。

rand 方法之所以不安全，其中一个比较重要的原因是它能产生的随机数范围有限:

rand 方法在没有提供可选参数 *min* 和 *max*时，返回 0 到 RAND_MAX 之间的伪随机整数.

在笔者的 windows 主机上，RAND_MAX 值仅为 32767

![](https://xzfile.aliyuncs.com/media/upload/picture/20200422120504-721b9578-844e-1.png)

而在笔者的 Linux 环境中，这个值为 2147483647

![](https://xzfile.aliyuncs.com/media/upload/picture/20200422120534-84486212-844e-1.png)

据资料显示，rand 最大可能值为 2,147,483,647

因此，只需要生成最多 20 亿个 rand 值，将其依次带入 ossn_generate_site_secret 计算出对应的 site_key 值，这些 site_key 值即为所有的 site_key 值可能值。如果运气好，目标主机是一台 windows 主机，这样的操作仅仅重复 3 万多次即可，因为 windows 主机下 rand 产生的最大值仅为 32767。

在分析了弱密钥是如何生成之后，我们需要一种方法来识别生成的密钥是否有效。在临时图片文件被上传到服务器时，会被存储于 ossn_data/tmp/photos 文件夹中，见下图：

![](https://xzfile.aliyuncs.com/media/upload/picture/20200422120602-94bd4eb4-844e-1.png)

因此上文中的加密数据成功解码后，其字符串中一定会包含 tmp/photos 字符串。我们这里用我们的密钥解一下上文中的编码，看一下这个推论是否正确，结果如下图：

![](https://xzfile.aliyuncs.com/media/upload/picture/20200422120727-c7548450-844e-1.png)

可见成功解开的文件路径中的确存在 tmp/photos 字符串

因此，暴力破解的思路很明朗了

1、攻击者在评论里上传一个图片，不点击发送，查看此时图片临时预览链接，获取链接中 image 参数值。例如：[`192.167.30.119/comment/staticimage?image=UiszT0RJYStoQll2N2g5cHhmQW9PRHlCNVgrSWFKVzFQRHE4eTJqSWthVUVjUFBIb3pxME1FNUJFdk5ER2pONXI4V2pyeXJSMm9VPQ==`](http://192.167.30.119/comment/staticimage?image=UiszT0RJYStoQll2N2g5cHhmQW9PRHlCNVgrSWFKVzFQRHE4eTJqSWthVUVjUFBIb3pxME1FNUJFdk5ER2pONXI4V2pyeXJSMm9VPQ==)中的 UiszT0RJYStoQll2N2g5cHhmQW9PRHlCNVgrSWFKVzFQRHE4eTJqSWthVUVjUFBIb3pxME1FNUJFdk5ER2pONXI4V2pyeXJSMm9VPQ==>

2、将数字 0-2147483647 依次带入 ossn_generate_site_secret 中计算出对应的 site_key

3、依次将 site_key 与 image 值带入 ossn_string_decrypt 中，获取解密后的明文

4、如果明文中含有 tmp/photos 字符串，解密成功，此时的 site_key 即为正确的 site_key 值

## 漏洞利用

在获取 site_key 值后，可以通过 ossn_string_encrypt 方法，对想要读取的文件进行加密，通过[`192.167.30.119/comment/staticimage?image=`](http://192.167.30.119/comment/staticimage?image=)接口进行读取即可

上文所涉及的工具如下：

site_key 计算工具

[`github.com/LucidUnicorn/CVE-2020-10560-Key-Recovery`](https://github.com/LucidUnicorn/CVE-2020-10560-Key-Recovery)

加密解密工具

[`github.com/kevthehermit/CVE-2020-10560`](https://github.com/kevthehermit/CVE-2020-10560)