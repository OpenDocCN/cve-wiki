# CVE-2010-0249（极光）分析报告 - 一曲沙丶天涯 - 博客园

> 原文：[https://www.cnblogs.com/jf-blog/p/12368687.html](https://www.cnblogs.com/jf-blog/p/12368687.html)

# 1.    发现可疑流量

A.分析流量，导出字节流

 ![](../Images/06782968ed547617d1f13696b825d685.png)

B.得到网页代码，发现需要执行的代码需要解密（加密的字符串部分太长了，就省略了）：

 ![](../Images/20761655116768b6f04fd5421be029b0.png)

    C.通过在网页下断点，将解密后的代码从提取出来，并做修饰（payLoad太长被省略）：

 ![](../Images/22d71e6c0aefa3b51fa8f4d430d503b8.png)

![](../Images/0f7324f7bafb88981f47555b85170cd7.png)

    很明显能看出来，这是在进行堆喷射！应该是在利用漏洞，至于漏洞在哪里，继续分析。

# 2.    漏洞复现

A.使用phpStudy构建网站，在xp虚拟机中用ie6访问

 ![](../Images/23b2351bde9b3f467e2261034e161509.png)

 崩掉了：

 ![](../Images/6e7b754ecfcd47804a1bfd8910be4e48.png)

B.调试

 ![](../Images/0426e8b4d8c3f229f524130096487229.png)

 ![](../Images/a09a162437de645e841c401aa9daaf37.png)

进行栈回溯

 ![](../Images/3d19d23a991c9fb9815208d55d5ebf0c.png)

![](../Images/bbdb77a3bdb5768b1a01f2c3721a6a66.png)

通过栈回溯：ecx来源于[esi],拖入OD调试一下

 ![](../Images/4163e64faa696541d9074dfd2e8c155e.png)

可以看出，ecx = [[[ebp-8]]],这个函数是mshtml.dll中的，把mshtml.dll拖入IDA看一下。

 ![](../Images/8c2b0f8c6f8ab204000feeefe6f43b78.png)

这个函数的参数是一个对象的二级指针

 ![](../Images/983f22ea9dcf6d07943640693ae86aa2.png)

 ![](../Images/43a0e153ad8b58758aa5a24e74ce229e.png)

 ![](../Images/d12c1ea2703d8c30a667f8c911c4d3cd.png)

继续溯源

 ![](../Images/dd8cca6786e08f65b90585634c643cd9.png)

找到上一个函数

 ![](../Images/c41b9e9eae64e53cad8e058923eb0e62.png)

 ![](../Images/123c82fb08cc907442dd4829d6909556.png)

C.根源

①到这里需要知道事件对象是如何创建和保存的，前面已经知道html中创建了一个image对象，对CImgElement下断点在windbg中输入bu mshtml!CImgElement::CImgElement

 ![](../Images/964ea64f4eaa33fe4362280ada5ff927.png)

ecx(01c6cd20)即创造的CImageElement对象指针。

②在CTreeNode下断点

 ![](../Images/df7e0e0c308029788b65208683349f84.png)

ecx(01cb04b0)即创造的CTreeNode对象指针。

 ![](../Images/76e86cae9d542a7e09fe35c329f48d0e.png)

CTreeNode::SetElement将该CImgElement类与CTreeNode关联

为了在event中能够访问相应的Element，CEventObj并不是直接就在其类中保存一个CElement结构的指针，而是在CImgElement对象创建后，又创建了相应的CTreeNode对象，由CTreeNode对象的属性中保存CImgElement类指针。然后将CTreeNode对象的地址，保存在这个img的事件对象CEventObj类的一个EVENTPARAM结构中。

# 3.    漏洞成因

表层：访问了被释放的对象，最后call了不可访问区域

 ![](../Images/227abec3ce0ed7f35ad11f4ec1c3e1bf.png)

通过多层指针访问对象element,通过虚函数表指针找到虚函数表，然后call了虚函数，

原对象已经被释放了，访问的不知道啥东西，就崩了。

# 4.    PoC

原理：创建对象，再释放，向对象里面写数据（如0x0C0D,或者0x0A0D),主要是再次访问释放的对象时，就会将写的数据当成地址调用（虚函数表），因为是大面积覆盖，不论是多少次级指针，都指向同一个地址，就是0x0C0D0C0D周围保存的也是0x0C0D0C0D，最终就会call 0x0C0D0C0D。

这时候我们再针对0x0C0D0C0D或者0x0A0D0A0D，进行堆喷射，使执行到shellcode中。

 ![](../Images/6ed6adbb4f68d06e7a72589fa6a865b6.png)

![](../Images/f83c361e2b9d05cf99ce61fbd37cd6ba.png)

# 5.    结语

通过该漏洞可以进行恶意网站访问时，将被攻击，执行恶意代码，或拒绝服务。

# 6.    参考资料

[http://www.geoffchappell.com/notes/security/aurora/index.htm](http://www.geoffchappell.com/notes/security/aurora/index.htm)