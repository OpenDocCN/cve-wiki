# Apache Tomcat Ajp CVE-2020-1938 漏洞复现 - tr1ple - 博客园

> 原文：[`www.cnblogs.com/tr1ple/p/12346535.html`](https://www.cnblogs.com/tr1ple/p/12346535.html)

# 环境搭建：

sudo docker pull duonghuuphuc/tomcat-8.5.32

sudo docker run -d -it -p 8080:8080 -p 8009:8009   --name ghostcat duonghuuphuc/tomcat-8.5.32

![](img/00de9f6ae882fd344d71c7b95ead0c5d.png)

![](img/9e6dfe3b6a2e4d167be5a8b9ea1b785d.png)

tomcat 调试：

export JAVA_OPTS='-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005'

# 漏洞复现：

## 任意文件读取

![](img/a08fc7efc4f2dbc2f7dc4c2b2e151fe2.png)

![](img/75c3ca7d4997d5745aa507951c0438a9.png)

## 任意文件包含

请求存在的 jsp 使其包含指定的文件中的 jsp 代码

![](img/6444af30fd94add376e9666c645e71b7.png)

![](img/8e9f098ff9222b7d7f4f37b2350d1e3c.png)

实际上根据不同的匹配将由不同的 serverlet 进行处理

# 漏洞分析:

这里根据网上的 exp 来分析一下:

首先去去 github 看看是啥时候 commit 修复的该漏洞

![](img/d4a17f66983258bbdf3206b7c11dae43.png)

 可以确定 2 月 5 号已经修复该问题了，点进去看看修复点

 ![](img/b9cc201eda7429c6b1c697086df2c4f3.png)

可以看到这里把原先的监听外网，改为监听本地地址了，根据网上的资料可以看到实际上攻击过程主要控制以下三个属性，发送的消息如果包含着三个值，那么 serverlet 将根据三个值属性进行 request 请求的改造，而这三个值都可以直接加到 ajp 数据包中

![](img/5e71885fc506939a842ad2a886e5cadc.png)

从修改的文件中大致可以推断到处理 ajp 消息的文件，进去看看

![](img/620938afa3dd44e5d135c8a5e05002d8.png)

其中 AjpProcessor.java 中定义了处理 jsp 数据包中 attributes 中的逻辑，可以看到在处理 attr 属性时 else 了一条 set，那么如果 n，v 可控就可以注入属性了

![](img/c88333e71133b3f3c03361982b3635eb.png)

实际上上面的设置属性是在 prepareRequest 函数中，处理完后将调用 getAdapter 继续之后的请求过程，即匹配 serverlet 了

![](img/c20c76232b959c5fa363851151cbb276.png)

## 文件包含

org/apache/jasper/servlet/JspServlet.java

![](img/9bad20bca96c55641f873b11bf330f8d.png)

实际上这里文件包含只需要用到这两个属性即可，当然前提是匹配到存在的 jsp 文件，例如请求 index.jsp

![](img/c16dae9497e20c4081ff86ad541d6a46.png)

## 文件读取:

直接双 shift 找到 defaultserverlet，在 doget 方法中通过 getRelaticePath 拿到请求的路径

![](img/554df4e81ba93c7407772e6e960eb0c9.png)

 ![](img/25e2278893c6e9be7acdbca367ac754f.png)

 这里将通过设置的属性来获取最重要读取的文件属性，这里需要同时设置这三个属性才可以，因为此时请求路径不存在，所以就从属性中取路径了，只要求该属性不为 null 即可，并重新定义要读取的文件

 ![](img/1f7bd1d605bc2b15e0ed876382ad1da6.png)

 ![](img/2062940f5c4f142ad3e1dcc083d33c79.png)

之后经过处理将这两个属性拼接并返回，即 serverlet_path/path_info，之后就读取文件资源

看一下 git 上的 ajp 的一个 demo

![](img/0a1a54e230497bccf56cd47f77b715f0.png)

 这里调用完 end 以后就构造完数据包，接下来就发包了，所以要改一下 end 函数

![](img/fe8d9dacb68776bb24f0629928b0beed.png)

 这里结束字节是 0XFF，所以要在该字节前面插入

![](img/540b34902d728a413a1e3f75ac1e7609.png)

 抓包可以看到 ajp 协议的通信过程

![](img/80497f5a42f3601dbacf56554102c330.png)

 可以清楚看到所加入的属性值，都是明文，加入位置也可以清楚看到

## 总结：

任意文件读取和任意文件包含范围：

webapps 目录下的文件，默认的 exp 只能读取 webapps/ROOT 下的文件，需对 exp 加以修改才能读取 webapps 下的其他文件，修改如下:

因为 webapps 下可以存在多个应用，那么不同的应用实际上可以认为是不同的 context，则对于 tomcat 容器来说，对于客户端发送的请求将首先对 context 进行匹配，匹配以后则进行相应的 serverlet 的匹配，那么 exp 默认是 ROOT，那么假如想要读取 webapps 下的 manager 下的文件，则可以修改 req_uri 来使 tomcat 匹配到该 context 即可

所以修改 exp：

![](img/c0b6dca203137fd6638d4db46306726d.png)

只需修改上图一处，那么对应 exp 中 ajp_request 的封装中将该值赋给 req_uri

 ![](img/5678be62ea6d5a9d0e1866d13fcfc55d.png)

效果如下图所示：

![](img/78d2399b7e52fdbcbd2b85105ff5035c.png)

任意包含只需要：

1.请求存在的

2.pathinfo 和 serverlet_path 两个属性执行包含的文件

任意文件读取：

1.请求不存在的文件

2.request_uri 属性必须存在，值可为任意

3.pathinfo 和 serverlet_path 组合对应文件路径

# 修复：

1.**若不需要使用 Tomcat AJP 协议，可直接关闭 AJP Connector，或将其监听地址改为仅监听本机 localhost。**

**![](img/12d4a1d656b8272823a711391f7e94d5.png)**

![](img/afa31df973d6eeb49f1a97077b5ea0f4.png)

 监听本地：

```
    <Connector protocol="AJP/1.3" address="::1" port="8009" redirectPort="8443" />
```

此时重启 tomcat 即测试不成功

![](img/d8baf7f5e73f6e65f463c6f36e6fabe5.png)

 2.增加 ajp connector 密钥认证方式

tomcat version7 version9

```
<Connector port="8009" protocol="AJP/1.3" redirectPort="8443" address="YOUR_TOMCAT_IP_ADDRESS" secret="YOUR_TOMCAT_AJP_SECRET"/>
```

tomcat version8

![](img/3dd40fade048760c9facc43d4d68a2b9.png)

# tips：

**影响范围**：   

Apache Software Foundation Tomcat 6.*

Apache Software Foundation Tomcat 7.0.0 - 7.0.99

Apache Software Foundation Tomcat 8.0.0 - 8.5.50

Apache Software Foundation Tomcat 9.0.0 - 9.0.30

poc 地址：

[`github.com/0nise/CVE-2020-1938`](https://github.com/0nise/CVE-2020-1938)

参考：

[`blog.csdn.net/yiqiushi4748/article/details/104428847`](https://blog.csdn.net/yiqiushi4748/article/details/104428847)

[`mp.weixin.qq.com/s?__biz=MzI4NjE2NjgxMQ==&mid=2650241245&idx=1&sn=2ca66d99fafb82b17b9023e65a143d63&chksm=f3e2c2a9c4954bbfa58ed15d4647eab743d79375eb51853ab2aecacf5f5c85b862f91cc0d685&mpshare=1&scene=23&srcid=&sharer_sharetime=1582366241817&sharer_shareid=ae6683d6c0e7df9a0b7c15e7cacf6b3c#rd`](https://mp.weixin.qq.com/s?__biz=MzI4NjE2NjgxMQ==&mid=2650241245&idx=1&sn=2ca66d99fafb82b17b9023e65a143d63&chksm=f3e2c2a9c4954bbfa58ed15d4647eab743d79375eb51853ab2aecacf5f5c85b862f91cc0d685&mpshare=1&scene=23&srcid=&sharer_sharetime=1582366241817&sharer_shareid=ae6683d6c0e7df9a0b7c15e7cacf6b3c#rd)

 [`blog.csdn.net/wangchengsi/article/details/2973012`](https://blog.csdn.net/wangchengsi/article/details/2973012) coyote 框架

 [`youmeek.gitbooks.io/intellij-idea-tutorial/content/remote-debugging.html`](https://youmeek.gitbooks.io/intellij-idea-tutorial/content/remote-debugging.html) idea 之旅

[`xz.aliyun.com/t/7325`](https://xz.aliyun.com/t/7325) 先知讲 tomcat 的，还行