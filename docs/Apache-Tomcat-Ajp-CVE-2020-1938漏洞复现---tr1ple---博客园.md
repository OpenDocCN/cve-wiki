# Apache Tomcat Ajp CVE-2020-1938漏洞复现 - tr1ple - 博客园

> 原文：[https://www.cnblogs.com/tr1ple/p/12346535.html](https://www.cnblogs.com/tr1ple/p/12346535.html)

# 环境搭建：

sudo docker pull duonghuuphuc/tomcat-8.5.32

sudo docker run -d -it -p 8080:8080 -p 8009:8009   --name ghostcat duonghuuphuc/tomcat-8.5.32

![](../Images/00de9f6ae882fd344d71c7b95ead0c5d.png)

![](../Images/9e6dfe3b6a2e4d167be5a8b9ea1b785d.png)

tomcat调试：

export JAVA_OPTS='-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005'

# 漏洞复现：

## 任意文件读取

![](../Images/a08fc7efc4f2dbc2f7dc4c2b2e151fe2.png)

![](../Images/75c3ca7d4997d5745aa507951c0438a9.png)

## 任意文件包含

请求存在的jsp使其包含指定的文件中的jsp代码

![](../Images/6444af30fd94add376e9666c645e71b7.png)

![](../Images/8e9f098ff9222b7d7f4f37b2350d1e3c.png)

实际上根据不同的匹配将由不同的serverlet进行处理

# 漏洞分析:

这里根据网上的exp来分析一下:

首先去去github看看是啥时候commit修复的该漏洞

![](../Images/d4a17f66983258bbdf3206b7c11dae43.png)

 可以确定2月5号已经修复该问题了，点进去看看修复点

 ![](../Images/b9cc201eda7429c6b1c697086df2c4f3.png)

可以看到这里把原先的监听外网，改为监听本地地址了，根据网上的资料可以看到实际上攻击过程主要控制以下三个属性，发送的消息如果包含着三个值，那么serverlet将根据三个值属性进行request请求的改造，而这三个值都可以直接加到ajp数据包中

![](../Images/5e71885fc506939a842ad2a886e5cadc.png)

从修改的文件中大致可以推断到处理ajp消息的文件，进去看看

![](../Images/620938afa3dd44e5d135c8a5e05002d8.png)

其中AjpProcessor.java中定义了处理jsp数据包中attributes中的逻辑，可以看到在处理attr属性时else了一条set，那么如果n，v可控就可以注入属性了

![](../Images/c88333e71133b3f3c03361982b3635eb.png)

实际上上面的设置属性是在prepareRequest函数中，处理完后将调用getAdapter继续之后的请求过程，即匹配serverlet了

![](../Images/c20c76232b959c5fa363851151cbb276.png)

## 文件包含

org/apache/jasper/servlet/JspServlet.java

![](../Images/9bad20bca96c55641f873b11bf330f8d.png)

实际上这里文件包含只需要用到这两个属性即可，当然前提是匹配到存在的jsp文件，例如请求index.jsp

![](../Images/c16dae9497e20c4081ff86ad541d6a46.png)

## 文件读取:

直接双shift找到defaultserverlet，在doget方法中通过getRelaticePath拿到请求的路径

![](../Images/554df4e81ba93c7407772e6e960eb0c9.png)

 ![](../Images/25e2278893c6e9be7acdbca367ac754f.png)

 这里将通过设置的属性来获取最重要读取的文件属性，这里需要同时设置这三个属性才可以，因为此时请求路径不存在，所以就从属性中取路径了，只要求该属性不为null即可，并重新定义要读取的文件

 ![](../Images/1f7bd1d605bc2b15e0ed876382ad1da6.png)

 ![](../Images/2062940f5c4f142ad3e1dcc083d33c79.png)

之后经过处理将这两个属性拼接并返回，即serverlet_path/path_info，之后就读取文件资源

看一下git上的ajp的一个demo

![](../Images/0a1a54e230497bccf56cd47f77b715f0.png)

 这里调用完end以后就构造完数据包，接下来就发包了，所以要改一下end函数

![](../Images/fe8d9dacb68776bb24f0629928b0beed.png)

 这里结束字节是0XFF，所以要在该字节前面插入

![](../Images/540b34902d728a413a1e3f75ac1e7609.png)

 抓包可以看到ajp协议的通信过程

![](../Images/80497f5a42f3601dbacf56554102c330.png)

 可以清楚看到所加入的属性值，都是明文，加入位置也可以清楚看到

## 总结：

任意文件读取和任意文件包含范围：

webapps目录下的文件，默认的exp只能读取webapps/ROOT下的文件，需对exp加以修改才能读取webapps下的其他文件，修改如下:

因为webapps下可以存在多个应用，那么不同的应用实际上可以认为是不同的context，则对于tomcat容器来说，对于客户端发送的请求将首先对context进行匹配，匹配以后则进行相应的serverlet的匹配，那么exp默认是ROOT，那么假如想要读取webapps下的manager下的文件，则可以修改req_uri来使tomcat匹配到该context即可

所以修改exp：

![](../Images/c0b6dca203137fd6638d4db46306726d.png)

只需修改上图一处，那么对应exp中ajp_request的封装中将该值赋给req_uri

 ![](../Images/5678be62ea6d5a9d0e1866d13fcfc55d.png)

效果如下图所示：

![](../Images/78d2399b7e52fdbcbd2b85105ff5035c.png)

任意包含只需要：

1.请求存在的

2.pathinfo和serverlet_path两个属性执行包含的文件

任意文件读取：

1.请求不存在的文件

2.request_uri属性必须存在，值可为任意

3.pathinfo和serverlet_path组合对应文件路径

# 修复：

1.**若不需要使用Tomcat AJP协议，可直接关闭AJP Connector，或将其监听地址改为仅监听本机localhost。**

**![](../Images/12d4a1d656b8272823a711391f7e94d5.png)**

![](../Images/afa31df973d6eeb49f1a97077b5ea0f4.png)

 监听本地：

```
    <Connector protocol="AJP/1.3" address="::1" port="8009" redirectPort="8443" />
```

此时重启tomcat即测试不成功

![](../Images/d8baf7f5e73f6e65f463c6f36e6fabe5.png)

 2.增加ajp connector密钥认证方式

tomcat version7 version9

```
<Connector port="8009" protocol="AJP/1.3" redirectPort="8443" address="YOUR_TOMCAT_IP_ADDRESS" secret="YOUR_TOMCAT_AJP_SECRET"/>
```

tomcat version8

![](../Images/3dd40fade048760c9facc43d4d68a2b9.png)

# tips：

**影响范围**：   

Apache Software Foundation Tomcat 6.*

Apache Software Foundation Tomcat 7.0.0 - 7.0.99

Apache Software Foundation Tomcat 8.0.0 - 8.5.50

Apache Software Foundation Tomcat 9.0.0 - 9.0.30

poc地址：

[https://github.com/0nise/CVE-2020-1938](https://github.com/0nise/CVE-2020-1938)

参考：

[https://blog.csdn.net/yiqiushi4748/article/details/104428847](https://blog.csdn.net/yiqiushi4748/article/details/104428847)

[https://mp.weixin.qq.com/s?__biz=MzI4NjE2NjgxMQ==&mid=2650241245&idx=1&sn=2ca66d99fafb82b17b9023e65a143d63&chksm=f3e2c2a9c4954bbfa58ed15d4647eab743d79375eb51853ab2aecacf5f5c85b862f91cc0d685&mpshare=1&scene=23&srcid=&sharer_sharetime=1582366241817&sharer_shareid=ae6683d6c0e7df9a0b7c15e7cacf6b3c#rd](https://mp.weixin.qq.com/s?__biz=MzI4NjE2NjgxMQ==&mid=2650241245&idx=1&sn=2ca66d99fafb82b17b9023e65a143d63&chksm=f3e2c2a9c4954bbfa58ed15d4647eab743d79375eb51853ab2aecacf5f5c85b862f91cc0d685&mpshare=1&scene=23&srcid=&sharer_sharetime=1582366241817&sharer_shareid=ae6683d6c0e7df9a0b7c15e7cacf6b3c#rd)

 [https://blog.csdn.net/wangchengsi/article/details/2973012](https://blog.csdn.net/wangchengsi/article/details/2973012) coyote框架

 [https://youmeek.gitbooks.io/intellij-idea-tutorial/content/remote-debugging.html](https://youmeek.gitbooks.io/intellij-idea-tutorial/content/remote-debugging.html) idea之旅

[https://xz.aliyun.com/t/7325](https://xz.aliyun.com/t/7325) 先知讲tomcat的，还行