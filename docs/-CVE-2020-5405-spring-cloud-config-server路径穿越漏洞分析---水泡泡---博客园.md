# 【CVE-2020-5405】spring-cloud-config-server路径穿越漏洞分析 - 水泡泡 - 博客园

> 原文：[https://www.cnblogs.com/r00tuser/p/12458518.html](https://www.cnblogs.com/r00tuser/p/12458518.html)

**0x00 产品简介**

Spring Cloud Config是Spirng Cloud下用于分布式配置管理的组件，分为`Config-Server`和`Config-Client`两个角色。其中Config-Server可以配置多种源获取配置，如从git，svn，native等。**0x01 漏洞简介**在配置仓库为本地native的情况下，攻击者可以获取config-server服务器上的任意带后缀文件**0x02 漏洞影响版本**2.2.x prior to 2.2.22.1.x prior to 2.1.7**0x03 漏洞等级**高危（官方评级）**0x04 漏洞分析**基础环境搭建，[https://github.com/spring-cloud/spring-cloud-config/releases/tag/v2.1.1.RELEASE](https://github.com/spring-cloud/spring-cloud-config/releases/tag/v2.1.1.RELEASE)，拉取zip包解压，导入至idea查看官方commit，分析漏洞位置
![](../Images/3a71326dff762701539a9dc625d9eb45.png)

其中第一个红框，[https://github.com/spring-cloud/spring-cloud-config/commit/651f458919c40ef9a5e93e7d76bf98575910fad0](https://github.com/spring-cloud/spring-cloud-config/commit/651f458919c40ef9a5e93e7d76bf98575910fad0)

删除了resolveName和reolveLabel的代码，代码将(_)替换为/，很有可能是造成此次漏洞的原因

 ![](../Images/d42c68ac70b4378d83b8f6ab48aeb071.png)

在下方测试代码进行了一定的增改，其中findOne函数里面的payload为上一次CVE-2019-3799的测试代码，对测试代码进行了增改想必是为了这一次漏洞做变更，**重点留意到这里使用的是native本地仓库配置**

![](../Images/9a6c96b47ad4975667ab3864e3af025b.png)

根据上述分析，尝试配置sping-cloud-config-server的仓库为本地仓库，在进行验证

配置configserver.yml，修改file:///后路径为本地仓库路径，其内容为https://github.com/spring-cloud-samples/config-repo/![](../Images/f3f14eb2f857fa6d5371e16300051d6e.png)

 根据resolveLabel和resolveName的变动，尝试下断点至@RequestMapping("/{name}/{profile}/{label}/**")

![](../Images/d45e81c0cd60ff9787376327ac29c9bd.png)

 在跟踪至GenericResourceRepository findOne函数时

![](../Images/97340efa78715a21e481c74bff5e8e32.png)

对比github commit的变动,新增了一个对location的判断

![](../Images/d9bf5f1b20f546784958f968da362a46.png)

猜测this.service.getLocations中出现了问题，继续跟进

![](../Images/43b45eb1672b31861eae0ef919f19746.png)

 继续跟进getLocations，程序跳至org.springframework.cloud.config.server.environment.NativeEnvironmentRepository getLocations方法

![](../Images/885264321c7cba44a540d20c22e5ecdb.png)

在addLableLocations属性为true时将label与location直接进行拼接，判断目录是否存在，存在则添加到output数组中，最后传进Locations对象中返回，很明显这里就是问题所在

![](../Images/ef1de754caab5b5996a76a0fe5822fb9.png)

结合前面在retrieve方法中resolveLable将label中的(_)替换为/，基本可以摸清payload的构造

![](../Images/8f3262b153fc4c5b1a48b122aa457d26.png)

 ![](../Images/ca88196928169357805e1c34b5bec5bb.png)

 关键点说清楚了，经后续调试，构造payload如下：

```
payload

```

![](../Images/ddb87678c9e33045f0ae3ecb302c7c77.png)

 **疑点1：按照测试的目录，应该是跳两层目录至根目录为什么这里用了三层跳？**

看到FileUrlResource中先是用createRelcativeURL进行了处理

 ![](../Images/b14a26639b5b61c9a61f21c530341ea2.png)

 继续跟进，发现使用URL来处理的

![](../Images/f2ccd82b8b20544f181f81474e080a6d.png)

跟进内部，发现是parseURL会去除第一个/../，所以实际跳目录的时候要多传入

![](../Images/3d5f97a5d898369e4140baf5abe2b3b4.png)

 **疑点2：为什么会获取不到没有后缀的文件？**

看到retrieve函数中在获取到文件内容后面的操作，“StringUtils.getFilenameExtension(resource.getFilename()).toLowerCase();”，尝试获取后缀，由于没有后缀返回null，空对象做toLowerCase操作出现异常，而后又由于没有做异常捕获，导致程序直接退出

![](../Images/54593e453f1b1e23247b7339c824d61c.png)

 后续官方在修补漏洞的时候也顺带把这个bug给修补了，[https://github.com/spring-cloud/spring-cloud-config/commit/740153b5aa74d960116f28be9c755e3b7debd2a2](https://github.com/spring-cloud/spring-cloud-config/commit/740153b5aa74d960116f28be9c755e3b7debd2a2)

![](../Images/31326ddab79d85261988d9cbaaff7c5d.png)