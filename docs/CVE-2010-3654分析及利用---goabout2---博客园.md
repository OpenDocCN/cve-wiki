# CVE-2010-3654 分析及利用 - goabout2 - 博客园

> 原文：[`www.cnblogs.com/goabout2/p/6100024.html`](https://www.cnblogs.com/goabout2/p/6100024.html)

三年前分析的一个漏洞，最近又温习一遍，这个 flash 中混淆漏洞的鼻祖，10 年最经典的漏洞。

## 漏洞触发原因

该漏洞主要因为 avm 对返回的类没有进行校验，通过修改 swf 文件，实现 Ref 类和 Origin 类的混淆。

Poc 如下，可以看到 poc 一共由三个类组成：

PoC_Main

Original_Class

Real_Ref_Class

PoC_Main 类中首先初始化 Real_Ref_Class 类，之后调用 Original_Class 的 static_func1 方法，该方法会返回一个 Original_Class 对象，并通过该对象调用方法 normal_func1（）

 ![](img/863c540a5c5b3b5aa7399e88095af239.png)

Original_Class 中包含两个方法，static_func1，返回一个 Original_Class 对象，normal_func1，不做任何操作

 ![](img/a8f492faba7139a36889d92f6162a379.png)

Real_Ref_Class 类中包含一个函数 func1，该函数返回一个 uint 类型的变量。

 ![](img/372eff757782d787f093374a026eeae6.png)

漏洞实际上上将对类 Origin_Class 的操作混淆成对 Real_Ref_Class 类的操作，为了达到这个效果，需要修改编译好的 swf 文件。

![](img/776e8fad44a4a76fac99c76a74371d31.png)

将上图中的 070102 修改成 070103，实际上就是修改了 avm 运行时需要使用到的编号。

![](img/883013fca4fe10de2653ea6dba5c0dd0.png)

运行样本之后，flash 崩溃，windbg 断下结果如下，可以看到在 mov 操作的时，eax 中的值为 41414141，该地址非法，从而导致崩溃，而 41414141 正是我们可控的数据，崩溃不远处正好有 call eax 可以导致程序执行，而导致漏洞触发的地址位于寄存器 eax 中，通过反编译窗口可以发现 eax 来自于 04c1ff9a 地址的 call eax 这个函数。

![](img/08205a6b61c52fe250ee7b4850b8e313.png)

直接在返回地址下断，重新加载运行，连续断下五次之后，进入对应的 call eax，在函数快返回时，调用指令 call edi，该函数最终会返回 41414141

 ![](img/1a0976bd8e794200bfc5e99efff9b661.png)

如下图所示：

 ![](img/0253c26672f041850cfb9c6442786781.png)

实际上此处下断的函数 call eax 即为 Poc_Main 中语句 var obj:Original_Class = Original_Class.static_func1()对应的 jit 代码，但此时由于 swf 的修改导致 Original_Class.static_func1()这句代码中的 Original_Class 变成了 Real_Ref_Class。 

*![](img/cade5c6bcd45d744838fd5348dea23c9.png) ![](img/f579a7d523ba77adfb8d207df1601a5f.png)*

通过修改可以导致 Main 在实际的调用过程中将 Real_Ref_Class 误以为 Original_Class，由于 avm 虚拟机的工作机制，导致 main 中的处理都是基于 Original_Class 类生成的，故而 Original_Class 中函数的返回类型决定了 Main 可以接受什么样的类型，如 Original_class 中的函数 A 返回 uint，Main 就必须接受 uint 的类型，但是此时如果 Real_Ref_Class 中的对应 A 返回为一个 String 的话，Main 就会将这个 String 当做 uint 对象处理。

## 泄露基地址

修改 poc 将 var obj:Original_Class = Original_Class.static_image();修改为

var obj:uint = Original_Class.static_image();

![](img/a482aa0248d5908608b54df84d2220e6.png) 

由于 main 中的接受的类型变成了 uint，因此 Original_Class 对应返回的类型也要修改成 uint，因为 Original_Classs 虽然被替换了，但是其决定了对应的调用返回的类型。

![](img/9e740098ac116ea8320ec3b098645841.png) 

此时在 Real_Ref_Class 中修改代码，将 string 换成一个 ByteArray 对象。

![](img/95251b68bd31c265b95ad79f3d82b045.png)

这样的结果就是在 Main 函数中我们通过漏洞将一个 ByteArray 的对象当做 uint 对象来处理，正常情况下这样的做法在编码上是无法通过的，在 Main 中直接调用 uint 的方法 toString 即可获取 ByteArray 的地址，如下图所示：

![](img/6b1a3a06a4b7b2d7be96d40b4c66b14a.png)

此时我们获取了该 ByteArray 的地址，通过该地址我们可以尝试获取 flash player 的基地址，从而绕过 aslr，下图即为生成的 ByteArray 在内存中的对象在 Bytearray+10+10 的位置即为对应的内容，如此处的 41414141，为我们 ByteArray 中的内容。

![](img/354e737f786217f8e9fb83452a5a6094.png)

而 01eb4f40 处的值 00572310 即为对应的虚函数，该地址在 flash player 中的偏移是固定的，获取该值，通过简单的数学运算即可获取对应的基址，此处需要涉及到一个问题，如何读取 01eb4f40 中的虚函数值。

![](img/d57248ee33c5445d19cf704a78a6c146.png)

这就需要用到 ascript 中的 Number 类，通过 new Number（address）即可进行读取，但是对于 Number 来说只接受整形对象的参数，此时就需要再次出发该漏洞将我们的 uint 类型混淆成整形对象（前面获取 ByteArray 的时候实际是将 ByteArray 混淆成了 uint）

对于 actionscript 中的所有变量都是一个 32 位的对象，其中末四位决定了该对象的类型，如下图所示。

![](img/547f36a7841fd5345c66a0ecb6ce5b73.png)

如此处我们生成的 ByteArray 第地址就是 01eb4f41，最后一个为 001，即一个 object 类型，而我们的目标是将其混淆为 110 类型。

![](img/930a544ab0fdee5673e7046569b20be6.png) 

如下图所示首先触发漏洞获取 ByteArray 对象，将该地址与&0xFFFFFFF8 做预算，将末尾的类型标志去掉，由于此时为 uint，通过 toString 函数将其装换成 String 对象，再次出发漏洞，将其混淆成整形对象，之后通过 Number 读取对应的值。

![](img/13348716721aec277d3688c6af5dfbff.png)

Real_Ref_Class 中定义函数 static_strToint，该函数接受一个 String 类型的参数，并即将其的做|0x000000007 操作，目的是转换成以 110 为结尾的整形对象。

![](img/b3e74f1497e34fc6978fbc3f7fdde584.png) 

在 Origin_Class 中定义对应的伪函数，我们知道该类中的函数返回值决定了 Real_Ref_Class 中的真实类型，由于此处希望按 Real_Ref_Class 中 static_strToint 定义的整形返回，因此此处在 Origin_Class 中不定义返回的类型 ，这样 Main 就默认接受调用函数返回的类型。

![](img/4f16dcef73506924d677b47c76d3f14a.png)

运行之后，泄露出的地址如下。

![](img/9addf9c73b5b73dd35658c8627f6c113.png)

这样通过读取 ByteArray 的虚函数地址，即可获取对应的 flash player 基址，通过读取 ByteArray+10 的地址，即可获取对应的 shellcode 的地址（将 shellcode 部署到 ByteArray 中）

![](img/fdd13f5e0833a7244c10238970be41ba.png) 

在 Main 中，获取 bytearray 中的 shellcode 地址。

![](img/141fa3ee5033633159e3bbb931bf4d4e.png) 

整个 ByteArray 的内存详细结构如下。

![](img/572c10f0212cfcb44528331fe3ec3e9e.png) 

最后泄露出的 flash player 基址，shellcode 地址如下。

![](img/772d5c5065c6829a2b616670b9f3b258.png)

## 控制 eip

漏洞触发时会 eax+0x48 指向的指针

![](img/c135f8f631ae8a46e772c14d98474629.png)

修改代码，在指向 bytearray 内容的指针前填充 64 长度的字符，这样触发时即可获取 eip 的执行权。

![](img/b60aae530bd896c17545d4b966c641e0.png)

修改 main 中的代码，假设需要执行的 shellcode 的指针为 eip，

![](img/d32331292088aebefc3bdb612216ed9a.png) 

执行之后如下，获取对应的地址 call [41424344]。

![](img/da940753ebdeb134c01ac560010fe846.png) 

## 构建 dep

此时通过漏洞获取了 flash 的基址，获取了可执行权限，获取 shellcode 的地址，通过获取的基址可以构建 rop 链来绕过 dep，这样每次利用运行时获取对应的基址，之后更新 rop 链的地址即可绕过 aslr 的限制,理论上可以直接通过 mona 生成 dep 链，但是这个地方有一个需要注意的地方就是，和一般的栈溢出不同，我们的 dep 链在 bytearray 中，而 bytearray 对象在堆上，这就导致 rop 链中 gaaget 模块连接起来的重要引出 esp 不存在了，本质上 rop 就是利用 ret 指令会直接将 esp 中的内容放到 eip 执行来使整个 rop 链运行起来，如下图所示：获取 eip 时 esp 为 001be2fc，而实际可控的 bytearray 的内容在 0247f000 中，为此需要调整 esp，使其指向 rop 的地址，为 rop 链制造可运行的“堆栈”环境。

 ![](img/8d2b8cb1c8257a56dffbb2f673a38d5e.png)

此时一般最直接的方式其实是 xchg 指令，直接通过该指令交换 esp，和 ecx 的值（触发时 ecx 正好指向我们可控的 bytearray 中 shellcode 的地址），通过 mona 进行指令的搜索，发现 12 条指令，但是并不是所有指令的可以使用这个地方的指令其实是有一个要求的，即交换之后 esp 需要进行加操作，因为本身 xchg 指令是有长度的。

![](img/552b61398d5a43c9672986b685d6f4fa.png)

经过挑选之后选择的交换 gatage 为以下，可以看到此处有一个 add esp，8 的操作，注意此处我们的 gatage 并不会运行到 ret，而是会在 add esp，8 之后进行一个 jmp 操作，可能会问，为什么不找直接 ret 的 gatage，没办法，这条是唯一可行的了。

![](img/dd6831b0b68776018c97ffa15babd5a6.png)

由于此处是 jmp，我们需要到 00d99460 的地方去看看是否有 ret，运气不错，虽然 jmp 了一下，但是 00d99460 位置只有三句指令，这个地方也需要注意，eax 来自 esp+14 的地址，即我们可控的位置，在 00d99460 的指令序列中有一个 and [eax+24],0EFFFFFFF 操作，这里需要保证[eax+24]这出的地址可写可读，写了个脚本跑了下 flash 的地址空间，发现没有类型的地址

![](img/4f2a1b347bbe294c99301322b6db4dc8.png)

因此此处直接选了一个第地址的 50f78，可以看到改地址+24 的地方的内存属性可读可写。

![](img/ac0b129d173539b26323c110056e127d.png)

这样重新调整过 esp 的值之后就可以构造 rop 链了，首先搜取指令用于对 virtualprotect 函数参数进行布置，搜索的指令如下。

![](img/69db87d54bf1568d9adb518fc22235fb.png)

为什么按这样的指令序列进行搜索，直接来看看 flash 中 virtualprotect 函数调用，即可发现原因了。

![](img/04c06a005709cffc3d1dafa66f904e0b.png)

整个 rop 链如下：

![](img/8eedca3e43406c327b9362f09ddd931c.png) 

在 Real_Ref_Class 中定义函数 ropfordep，该函数接受 flash player 的基址和 shellcode，之后按上述的结构将 rop 中的地址更新。

![](img/23e286c21324e65ea96372fb88032c97.png) 

同样编写 shellcode 函数，该函数保存对应的 calc 的 shellcode，此处注意编码，ByteArray 是小端机的排序，所以和内存中的 shellcode 是相反的，当然你也可以把这个地方的 ByteArray 在返回的时候转成 String，这样的的话就和内存中一致了。

![](img/424d1f45478753de5f8346bef7c37492.png) 

Real_Rel_Class 中对应的伪函数。

![](img/cb36d503b7b74509972e42b31f9d5550.png) 

调试运行，进入 rop 链中

![](img/dd2bdf32405334f0c5128dfc7ebbffed.png) 

此时 esp 设置成功。

![](img/7939af6dd770de980b8b7216c85372ee.png) 

堆栈调整之后，esp 执行堆上对应的 ByteArray 中的 rop 链

![](img/83006782a8df46b1c376269bc4267e05.png) 

参数布置

![](img/3575c9ee3979b0e49e02ecd555f3955d.png) 

此时 shellcode 只有读写权。

![](img/cd299e4e51e3459633cd2388acd4b2f7.png)

调用 virtualprotect，将 shellcode 的地址设置为可执行。

![](img/05da0ca29e255f8e5b92df62a4bb12b8.png)

运行之后，shellcode 可执行

![](img/5ebbfa1da7b3d71900fe6d5853dc8e95.png)

Calc 运行，熟悉的计算器。

![](img/76da5a0abd7bf35e85a1f0fc28c910d9.png)

转载请注明出处