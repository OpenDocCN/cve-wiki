# 干货|微软远程桌面服务蠕虫漏洞（CVE-2019-1182）分析 - 京东科技开发者 - 博客园

> 原文：[https://www.cnblogs.com/jdclouddeveloper/p/12091315.html](https://www.cnblogs.com/jdclouddeveloper/p/12091315.html)

![Alt](../Images/d7c46994affff8b287edacb56494be14.png)

> 2019年8月，微软发布了一套针对远程桌面服务的修复程序，其中包括两个关键的远程执行代码（RCE）漏洞，CVE-2019-1181和CVE-2019-1182。与之前修复的“BlueKeep”漏洞（CVE-2019-0708）类似，也具有蠕虫特性，即利用这些漏洞的恶意软件可能会在无需用户交互的情况下在易受攻击的机器间进行传播。
> 
> 本文主要通过对CVE-2019-1182漏洞进行分析，让大家对于漏洞的成因及漏洞修复有一个更加全面的认识。

**系统版本**:Windows 10 1903

**补丁**:windows10.0-kb4512508-x64_1893edc9a11d760be11e49d2500170ceee8026d7

### 漏洞危害

公网开放RDP服务的主机数量巨大，影响面极大。危险等级：严重，请用户尽快升级更新。

### 成因分析

分别提取补丁前和补丁后rds(Remote Desktop Service)进程相关bin文件及相关驱动模块，经过ida和bindiff分析后定位到rdpbase.dll。该模块改动很少(只有一处函数差异)，可以很快定位到问题函数，如下图所示。

![Alt](../Images/9be778745997dbdd3aa00c0c7de7a426.png)

分析差异函数DecompressUnchopper::Decompress发现存在一处整型溢出漏洞。

![Alt](../Images/10d9378b2265fcf6fb4dd69d407f2838.png)

上图左边是patch之后的代码，右边是patch之前的代码，可以看到pcach之前指令eax+0x2000作为函数new的参数使用，patch后增加了对size的校验，会判断edx+0x2000是否大于edx,什么情况下一个值加上0x2000会大于之前的值呢？对于无符号整数来说当0xffffe000<size<0xffffffff时，size+0x2000将位于(0,0x2000)这个区间，size style="font-size: inherit;color: inherit;line-height: inherit;">size+0x2000.补丁后的反编译代码如下</size<0xffffffff时，size+0x2000将位于(0,0x2000)这个区间，size>

![Alt](../Images/c2e7b87ad7cd5cc419428299f8aa4fec.png)

patch的思路很简单，当size>size+0x2000时，new(-1)后续逻辑函数直接return。

下面我们根据DecompressUnchopper::Decompress的逻辑梳理一下该漏洞可能的利用思路。

![Alt](../Images/e976a56f1ea4d4a39f0aaf4ef712e47e.png)

如上图所示，可以看到函数尾部调用了memcpy，第一个参数dest指向的内存为前面new分配的内存空间。如果我们把decompressedSize设置为[0xffffe000,0xffffffff]的一个值，当加上0x2000后decompressedSize小于原值，此时如果buff还是原来的大小，会导致memcpy的操作覆盖掉dest后面buff-(decompressedSize+0x2000)个字节，如果后面的地址空间保存有虚表指针之类的地址则可以导致控制流劫持。

### poc构造

以上的分析基于对相关模块的逆向分析及靠经验猜测，为了验证思路是否正确首先需要能够有触达漏洞函数的rdp包。下面的叙述基于对CVE-2019-0708 poc的理解以及微软官方提供的rdp协议文档。

首先看一下微软的官方公告[1]：

![Alt](../Images/98e0a7f1f130f0ae18721f1c3a68092a.png)

从公告的描述来看这个漏洞跟CVE-2019-0708类似，都可以造成蠕虫传播的效果，所以也是不需要进行登录认证即可利用该漏洞远程代码执行，感觉大部分代码可以复用所以决定在CVE-2019-0708的poc [2]基础上构造CVE-2019-1182的poc。

通过研究CVE-2019-0708的poc和微软官方文档[3]可以了解到rdp协议的通信流程，如下图所示：

![Alt](../Images/b4f4a12d20702cd97b5b5e531c4fd63a.png)

至此找不到触达漏洞函数的任何线索，思路还是要回到逆向漏洞函数周围的处理逻辑上。交叉引用并没有发现对DecompressUnchopper::Decompress的静态调用，搜索一下DecompressUnchopper这个类相关的函数：

![Alt](../Images/e7b959dbf345ca87a47b3da7d16382fc.png)

经过分析发现是DecompressRdp8__CreateInstance这个函数创建了DecompressUnchopper对象，继续查看DecompressRdp8__CreateInstance没有找到对此函数的静态调用，发现这个函数是个导出函数，最后经过搜索发现该函数在rdpserverbase.dll中进行了导入，交叉引用发现有两处调用：

![Alt](../Images/74ee2e01fd8dab7a73739ab89b161059.png)

上图中可以看到是在CRdpDynVC这个类的成员函数中进行了调用，因此猜测可能和rdp的dvc(Dynamic Virtual Channel)信道有关，关于dvc信道的详细信息可参考微软官方文档[4]。通过查阅官方文档初步定位到通过dvc信道发送加密数据可能会触达漏洞函数。

dvc信道的建立流程如下：

(1) dvc init.

![Alt](../Images/fd387af6e5da883757ed613ca08d6922.png)

(2) dvc open

![Alt](../Images/d4a2241f37978f62dc5b67361578792c.png)

(3) dvc send&recv data

![Alt](../Images/f70f7d6c38ed103eae4f82e4581cce9e.png)

dvc信道可分片传输超大数据(最大不超过2^32-1字节)，并支持非加密和加密数据传输。

![Alt](../Images/23af6d5ee53196b0c2c48a69900eece4.png)

(4) dvc close

![Alt](../Images/97790d80f329f3043af238d673ebb953.png)

基于以上的研究，下面尝试构造一个可触达漏洞函数的dvc pdu。加密的dvc pdu结构如下图所示，详细信息参见官方文档。

![Alt](../Images/9093e2c3930985ff3cfbbe62c6e780e4.png)

发送的数据包：

```
dvc_send = ( #pdu header "0300004002F08064000503EC70322A00000003000000" #1st byte cid length "68" + channel_id[-2:] + "01110000" #data "414141414141414141414141414141414141414141414141414141" "414141414141414141414141414141414141414141414141414141" "414141414141414141414141414141414141414141414141414141" "414141414141414141414141414141414141414141414141414141" "414141414141414141414141414141414141414141414141414141" "414141414141414141414141414141414141414141414141414141" ) tls.sendall(Packer(dvc_send).bin_unpack()) 
```

对DecompressUnchopper::Decompress下断，运行脚本，触发断电，证明之前的猜测是正确的。

![Alt](../Images/3ac379720dfb4769da5b1d991ad6acc3.png)

通过调试分析及参考官方文档，构造如下数据包可导致crash:

```
dvc_send2 = ( "0300004002F08064000503EC70322A00000003000000" "68" + channel_id[-2:] + "01E0FFFF" "e122550e0ffff080000002690ce0a2b9f6401070000002630d2b4fc0402" ) tls.sendall(Packer(dvc_send).bin_unpack()) 
```

崩溃现场：

![Alt](../Images/0c5493e97316a3694d1a0e0779bcfef9.png)

调试分析导致crash的原因如下: DecompressedSize为0xffffe001,加0x2000之后为1，new(1)分配了一个字节的堆空间，memcpy多次像new分配的内存拷贝数据，导致数据一直向后覆盖，图中覆盖到了RdpBoundsAccumulator对象，当执行clear操作时访问无效地址造成memory corruption。

关于利用的一些思考：精准控制memcpy拷贝长度，覆盖到某对象的虚表指针或其他可劫持控制流的内存单元，可导致任意代码执行，需要考虑cfg等漏洞利用缓解措施的bypass。

**点击【[阅读](https://developer.jdcloud.com/label?tagName=%E5%AE%89%E5%85%A8&utm_source=_cnblogs&utm_medium=Footer&utm_campaign=cnblogs_online_Developer_Community&utm_term=anquan)】，获取更多信息~**

**References:**

[1] [https://msrc-blog.microsoft.com/2019/08/13/patch-new-wormable-vulnerabilities-in-remote-desktop-services-cve-2019-1181-1182/](https://msrc-blog.microsoft.com/2019/08/13/patch-new-wormable-vulnerabilities-in-remote-desktop-services-cve-2019-1181-1182/)

[2] [https://github.com/algo7/bluekeep_CVE-2019-0708_poc_to_exploit](https://github.com/algo7/bluekeep_CVE-2019-0708_poc_to_exploit)

[3] [https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpbcgr/5073f4ed-1e93-45e1-b039-6e30c385867c](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpbcgr/5073f4ed-1e93-45e1-b039-6e30c385867c)

[4] [https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpedyc/3bd53020-9b64-4c9a-97fc-90a79e7e1e06](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpedyc/3bd53020-9b64-4c9a-97fc-90a79e7e1e06)

![Alt](../Images/63d723e6bfaba37001bb1bf7e9386f97.png)

![Alt](../Images/49a300a78861b86f7209e1c3dc01af7f.png)