# 干货|微软远程桌面服务蠕虫漏洞（CVE-2019-1182）分析 - 京东科技开发者 - 博客园

> 原文：[`www.cnblogs.com/jdclouddeveloper/p/12091315.html`](https://www.cnblogs.com/jdclouddeveloper/p/12091315.html)

![Alt](img/d7c46994affff8b287edacb56494be14.png)

> 2019 年 8 月，微软发布了一套针对远程桌面服务的修复程序，其中包括两个关键的远程执行代码（RCE）漏洞，CVE-2019-1181 和 CVE-2019-1182。与之前修复的“BlueKeep”漏洞（CVE-2019-0708）类似，也具有蠕虫特性，即利用这些漏洞的恶意软件可能会在无需用户交互的情况下在易受攻击的机器间进行传播。
> 
> 本文主要通过对 CVE-2019-1182 漏洞进行分析，让大家对于漏洞的成因及漏洞修复有一个更加全面的认识。

**系统版本**:Windows 10 1903

**补丁**:windows10.0-kb4512508-x64_1893edc9a11d760be11e49d2500170ceee8026d7

### 漏洞危害

公网开放 RDP 服务的主机数量巨大，影响面极大。危险等级：严重，请用户尽快升级更新。

### 成因分析

分别提取补丁前和补丁后 rds(Remote Desktop Service)进程相关 bin 文件及相关驱动模块，经过 ida 和 bindiff 分析后定位到 rdpbase.dll。该模块改动很少(只有一处函数差异)，可以很快定位到问题函数，如下图所示。

![Alt](img/9be778745997dbdd3aa00c0c7de7a426.png)

分析差异函数 DecompressUnchopper::Decompress 发现存在一处整型溢出漏洞。

![Alt](img/10d9378b2265fcf6fb4dd69d407f2838.png)

上图左边是 patch 之后的代码，右边是 patch 之前的代码，可以看到 pcach 之前指令 eax+0x2000 作为函数 new 的参数使用，patch 后增加了对 size 的校验，会判断 edx+0x2000 是否大于 edx,什么情况下一个值加上 0x2000 会大于之前的值呢？对于无符号整数来说当 0xffffe000<size<0xffffffff 时，size+0x2000 将位于(0,0x2000)这个区间，size style="font-size: inherit;color: inherit;line-height: inherit;">size+0x2000.补丁后的反编译代码如下</size<0xffffffff 时，size+0x2000 将位于(0,0x2000)这个区间，size>

![Alt](img/c2e7b87ad7cd5cc419428299f8aa4fec.png)

patch 的思路很简单，当 size>size+0x2000 时，new(-1)后续逻辑函数直接 return。

下面我们根据 DecompressUnchopper::Decompress 的逻辑梳理一下该漏洞可能的利用思路。

![Alt](img/e976a56f1ea4d4a39f0aaf4ef712e47e.png)

如上图所示，可以看到函数尾部调用了 memcpy，第一个参数 dest 指向的内存为前面 new 分配的内存空间。如果我们把 decompressedSize 设置为[0xffffe000,0xffffffff]的一个值，当加上 0x2000 后 decompressedSize 小于原值，此时如果 buff 还是原来的大小，会导致 memcpy 的操作覆盖掉 dest 后面 buff-(decompressedSize+0x2000)个字节，如果后面的地址空间保存有虚表指针之类的地址则可以导致控制流劫持。

### poc 构造

以上的分析基于对相关模块的逆向分析及靠经验猜测，为了验证思路是否正确首先需要能够有触达漏洞函数的 rdp 包。下面的叙述基于对 CVE-2019-0708 poc 的理解以及微软官方提供的 rdp 协议文档。

首先看一下微软的官方公告[1]：

![Alt](img/98e0a7f1f130f0ae18721f1c3a68092a.png)

从公告的描述来看这个漏洞跟 CVE-2019-0708 类似，都可以造成蠕虫传播的效果，所以也是不需要进行登录认证即可利用该漏洞远程代码执行，感觉大部分代码可以复用所以决定在 CVE-2019-0708 的 poc [2]基础上构造 CVE-2019-1182 的 poc。

通过研究 CVE-2019-0708 的 poc 和微软官方文档[3]可以了解到 rdp 协议的通信流程，如下图所示：

![Alt](img/b4f4a12d20702cd97b5b5e531c4fd63a.png)

至此找不到触达漏洞函数的任何线索，思路还是要回到逆向漏洞函数周围的处理逻辑上。交叉引用并没有发现对 DecompressUnchopper::Decompress 的静态调用，搜索一下 DecompressUnchopper 这个类相关的函数：

![Alt](img/e7b959dbf345ca87a47b3da7d16382fc.png)

经过分析发现是 DecompressRdp8__CreateInstance 这个函数创建了 DecompressUnchopper 对象，继续查看 DecompressRdp8__CreateInstance 没有找到对此函数的静态调用，发现这个函数是个导出函数，最后经过搜索发现该函数在 rdpserverbase.dll 中进行了导入，交叉引用发现有两处调用：

![Alt](img/74ee2e01fd8dab7a73739ab89b161059.png)

上图中可以看到是在 CRdpDynVC 这个类的成员函数中进行了调用，因此猜测可能和 rdp 的 dvc(Dynamic Virtual Channel)信道有关，关于 dvc 信道的详细信息可参考微软官方文档[4]。通过查阅官方文档初步定位到通过 dvc 信道发送加密数据可能会触达漏洞函数。

dvc 信道的建立流程如下：

(1) dvc init.

![Alt](img/fd387af6e5da883757ed613ca08d6922.png)

(2) dvc open

![Alt](img/d4a2241f37978f62dc5b67361578792c.png)

(3) dvc send&recv data

![Alt](img/f70f7d6c38ed103eae4f82e4581cce9e.png)

dvc 信道可分片传输超大数据(最大不超过 2³²-1 字节)，并支持非加密和加密数据传输。

![Alt](img/23af6d5ee53196b0c2c48a69900eece4.png)

(4) dvc close

![Alt](img/97790d80f329f3043af238d673ebb953.png)

基于以上的研究，下面尝试构造一个可触达漏洞函数的 dvc pdu。加密的 dvc pdu 结构如下图所示，详细信息参见官方文档。

![Alt](img/9093e2c3930985ff3cfbbe62c6e780e4.png)

发送的数据包：

```
dvc_send = ( #pdu header "0300004002F08064000503EC70322A00000003000000" #1st byte cid length "68" + channel_id[-2:] + "01110000" #data "414141414141414141414141414141414141414141414141414141" "414141414141414141414141414141414141414141414141414141" "414141414141414141414141414141414141414141414141414141" "414141414141414141414141414141414141414141414141414141" "414141414141414141414141414141414141414141414141414141" "414141414141414141414141414141414141414141414141414141" ) tls.sendall(Packer(dvc_send).bin_unpack()) 
```

对 DecompressUnchopper::Decompress 下断，运行脚本，触发断电，证明之前的猜测是正确的。

![Alt](img/3ac379720dfb4769da5b1d991ad6acc3.png)

通过调试分析及参考官方文档，构造如下数据包可导致 crash:

```
dvc_send2 = ( "0300004002F08064000503EC70322A00000003000000" "68" + channel_id[-2:] + "01E0FFFF" "e122550e0ffff080000002690ce0a2b9f6401070000002630d2b4fc0402" ) tls.sendall(Packer(dvc_send).bin_unpack()) 
```

崩溃现场：

![Alt](img/0c5493e97316a3694d1a0e0779bcfef9.png)

调试分析导致 crash 的原因如下: DecompressedSize 为 0xffffe001,加 0x2000 之后为 1，new(1)分配了一个字节的堆空间，memcpy 多次像 new 分配的内存拷贝数据，导致数据一直向后覆盖，图中覆盖到了 RdpBoundsAccumulator 对象，当执行 clear 操作时访问无效地址造成 memory corruption。

关于利用的一些思考：精准控制 memcpy 拷贝长度，覆盖到某对象的虚表指针或其他可劫持控制流的内存单元，可导致任意代码执行，需要考虑 cfg 等漏洞利用缓解措施的 bypass。

**点击【[阅读](https://developer.jdcloud.com/label?tagName=%E5%AE%89%E5%85%A8&utm_source=_cnblogs&utm_medium=Footer&utm_campaign=cnblogs_online_Developer_Community&utm_term=anquan)】，获取更多信息~**

**References:**

[1] [`msrc-blog.microsoft.com/2019/08/13/patch-new-wormable-vulnerabilities-in-remote-desktop-services-cve-2019-1181-1182/`](https://msrc-blog.microsoft.com/2019/08/13/patch-new-wormable-vulnerabilities-in-remote-desktop-services-cve-2019-1181-1182/)

[2] [`github.com/algo7/bluekeep_CVE-2019-0708_poc_to_exploit`](https://github.com/algo7/bluekeep_CVE-2019-0708_poc_to_exploit)

[3] [`docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpbcgr/5073f4ed-1e93-45e1-b039-6e30c385867c`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpbcgr/5073f4ed-1e93-45e1-b039-6e30c385867c)

[4] [`docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpedyc/3bd53020-9b64-4c9a-97fc-90a79e7e1e06`](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpedyc/3bd53020-9b64-4c9a-97fc-90a79e7e1e06)

![Alt](img/63d723e6bfaba37001bb1bf7e9386f97.png)

![Alt](img/49a300a78861b86f7209e1c3dc01af7f.png)