# CVE-2019-0230 s2-059 漏洞分析 - ph4nt0mer - 博客园

> 原文：[`www.cnblogs.com/ph4nt0mer/p/13512599.html`](https://www.cnblogs.com/ph4nt0mer/p/13512599.html)

## 0x01 问题原因

Apache Struts 框架在强制时对分配给某些标记属性的属性值执行双重计算，以便可以传递一个值，该值将在呈现标记的属性时再次计算。对于精心设计的请求，这可能会导致远程代码执行 （RCE）。
只有在 Struts 标记属性内强制使用 OGNL 表达式时，当表达式用于计算攻击者可以通过创建相应请求直接修改的原始未验证输入时，问题才适用。

## 0x02 例子

`<s:url var="url" namespace="/employee" action="list"/><s:a id="%{skillName}" href="%{url}">List available Employees</s:a>`
如果攻击者能够修改请求中的属性，使原始 OGNL 表达式传递到属性而无需进一步验证，则当作为请求呈现标记时，属性中包含的提供的 OGNL 表达式将计算。

## 0x03 影响范围

Struts 2.0.0 - Struts 2.5.20

官方建议升级到 2.5.22 以后。

## 0x04 环境

*   tomcat7
*   jk8
*   struts2.3.7-src

## 0x05 源码部署

在 showcase 项目中，在首页 showcase.jsp 的 head 标签中加入

```
<head>
    <title>Struts2 Showcase</title>
<%--    <s:head theme="simple"/>--%>
	<s:a id="%{1+1}" href="xxx.jsp"></s:a>
</head> 
```

在 struts 项目中，view 里需要加入`<%@ taglib prefix="s" uri="/struts-tags" %>`才可解析 jsp 里的 struts 标签。

参考`https://blog.csdn.net/sho_ko/article/details/84175306`对 struts 的标签源码解析过程。

![](img/b355091d4fb6acaf610e2f0b5f4dc869.png)

当用户发出请求时，`doStartTag()`开始执行，首先就调用 getBean 获取对应的标签组件类实例，构造函数参数值栈 stack 由基类`StrutsBodyTagSupport`的`getStack()`获得，request 和 response 对象在 PageContext 实例中获取。然后调用`populateParams();`进行初始参数值的填充，`populateParams()`也将调用具体类中的 populateParams()对自己的属性成员进行初始化。

所以我们直接 debug 断点在解析标签的`ComponentTagSupport`类的`doStartTag()`函数的第一行。
![image.png](img/2d0336ad59659c3572c2df946e9a7ac1.png)
可以看到 this 的 href 属性就是 xxx.jsp，因为文章说的在`this.populateParams();`里进行填充，所以我们跟进 populateParams()看看，一直到抽象类的父类`AbstractUITag`类的 populateParams 操作里看到了`uiBean.setId(this.id);`，对 id 里的值进行了填充。
![image.png](img/d09426b4683d947976ede2c3bb59c2f4.png)
通过该类:

```
 UIBean uiBean = (UIBean)this.component;
        uiBean.setCssClass(this.cssClass);
        uiBean.setCssStyle(this.cssStyle);
        uiBean.setCssErrorClass(this.cssErrorClass);
        uiBean.setCssErrorStyle(this.cssErrorStyle);
        uiBean.setTitle(this.title);
        uiBean.setDisabled(this.disabled);
        uiBean.setLabel(this.label);
        uiBean.setLabelSeparator(this.labelSeparator);
        uiBean.setLabelposition(this.labelposition);
        uiBean.setRequiredPosition(this.requiredPosition);
        uiBean.setErrorPosition(this.errorPosition);
        uiBean.setName(this.name);
        uiBean.setRequiredLabel(this.requiredLabel);
        uiBean.setTabindex(this.tabindex);
        uiBean.setValue(this.value);
        uiBean.setTemplate(this.template);
        uiBean.setTheme(this.theme);
        uiBean.setTemplateDir(this.templateDir);
        uiBean.setOnclick(this.onclick);
        uiBean.setOndblclick(this.ondblclick);
        uiBean.setOnmousedown(this.onmousedown);
        uiBean.setOnmouseup(this.onmouseup);
        uiBean.setOnmouseover(this.onmouseover);
        uiBean.setOnmousemove(this.onmousemove);
        uiBean.setOnmouseout(this.onmouseout);
        uiBean.setOnfocus(this.onfocus);
        uiBean.setOnblur(this.onblur);
        uiBean.setOnkeypress(this.onkeypress);
        uiBean.setOnkeydown(this.onkeydown);
        uiBean.setOnkeyup(this.onkeyup);
        uiBean.setOnselect(this.onselect);
        uiBean.setOnchange(this.onchange);
        uiBean.setTooltip(this.tooltip);
        uiBean.setTooltipConfig(this.tooltipConfig);
        uiBean.setJavascriptTooltip(this.javascriptTooltip);
        uiBean.setTooltipCssClass(this.tooltipCssClass);
        uiBean.setTooltipDelay(this.tooltipDelay);
        uiBean.setTooltipIconPath(this.tooltipIconPath);
        uiBean.setAccesskey(this.accesskey);
        uiBean.setKey(this.key);
        uiBean.setId(this.id);
        uiBean.setDynamicAttributes(this.dynamicAttributes); 
```

进入 setId 操作
![image.png](img/e477c9fb959ce8866fe002ea2148b8b9.png)

```
 public void setId(String id) {
        if (id != null) {
            this.id = this.findString(id);
        }

    } 
```

跟进`findString`:

```
 protected String findString(String expr) {
        return (String)this.findValue(expr, String.class);
    } 
```

在跟进`findValue`:

```
 protected Object findValue(String expr, Class toType) {
        if (this.altSyntax() && toType == String.class) {
            return ComponentUtils.containsExpression(expr) ? TextParseUtil.translateVariables('%', expr, this.stack) : expr;
        } else {
            expr = this.stripExpressionIfAltSyntax(expr);
            return this.getStack().findValue(expr, toType, this.throwExceptionOnELFailure);
        }
    } 
```

然后可以看到`TextParseUtil`类了，根据 if 条件可知，`this.altSyntax()`需要 ture，默认是 true 的。
所以默认是进入`TextParseUtil.translateVariables('%', expr, this.stack)`。
一直跟入，来到`translateVariables`
![image.png](img/eb3f152150b2b0cd765f0de848cba696.png)

在这个 while 里，

```
while(true) {
                int start = expression.indexOf(lookupChars, pos);
                if (start == -1) {
                    ++loopCount;
                    start = expression.indexOf(lookupChars);
                }

                if (loopCount > maxLoopCount) {
                    break;
                } 
```

![image.png](img/5fdc9f5fc1c00ec6f856cdc27b1f818c.png)

在 `Object o = evaluator.evaluate(var);`里进行了值计算，
![image.png](img/adc786ab7784106e9e3b2bad7e84c791.png)

但是如果`%{%{1+1}+1}`,
![image.png](img/42f8b563f2594bc44c397e10e4aa878c.png)
因为 start=-1，所以执行`++loopCount`，
因为 loopCount=2>maxLoopCount=1，所以会 break 这个 while，导致不能执行`Object o = evaluator.evaluate(var);`，所以会返回值为空。
这是一个埋点。

所以我们继续追踪，来到`boolean evalBody = this.component.start(this.pageContext.getOut());`
![image.png](img/2b9a27bf827cdd0b1bf1dd76acc320ff.png)
我们看下这时的`this.component`变量，
![image.png](img/a0f0423a0fd91037b41c53e6fc3cd849.png)
可以看到 id 已经计算出来了。

进入 start 函数，最终来到：

```
 public boolean start(Writer writer) {
        boolean result = super.start(writer);

        try {
            this.evaluateParams();
            this.mergeTemplate(writer, this.buildTemplateName(this.openTemplate, this.getDefaultOpenTemplate()));
        } catch (Exception var4) {
            LOG.error("Could not open template", var4, new String[0]);
        } 
```

进入`evaluateParams`，
![image.png](img/db71e907f6dcdf01f6caa11fdc5f32b5.png)
可以看到大量熟悉的`findString`函数，也就是说这边是有可能再次进行 ognl 表达式计算的。

一路跟踪：
![image.png](img/33dafadbe49cf6aa3cae8ee67d75ab4b.png)
进入`this.populateComponentHtmlId(form);`

```
 protected void populateComponentHtmlId(Form form) {
        String tryId;
        if (this.id != null) {
            tryId = this.findStringIfAltSyntax(this.id);
        } else {
            String generatedId;
            if (null == (generatedId = this.escape(this.name != null ? this.findString(this.name) : null))) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug("Cannot determine id attribute for [#0], consider defining id, name or key attribute!", new Object[]{this});
                }

                tryId = null;
            } else if (form != null) {
                tryId = form.getParameters().get("id") + "_" + generatedId;
            } else {
                tryId = generatedId;
            }
        } 
```

![image.png](img/4d1dffe31188cb5963bfe500d50cf740.png)

来到`tryId = this.findStringIfAltSyntax(this.id);`

![image.png](img/077a922975a6479610ac25a8cfdc434d.png)

因为 altSyntax()默认 true，所以来到熟悉的 findString 计算操作。所以 this.id 在第一次 ognl 计算成功后还会进行一次 ognl 计算，假如第一次 ognl 计算表达式的结果是`%{1+2}`，
![image.png](img/843be037c1c399feafc0fc16309e04d1.png)

那么此处就存在一定的风险。但是实际情况下，不管是第一次 ognl 计算还是第二次 ognl 计算，均都没法执行复杂计算。等有进一步的 poc 消息。

## 0x6 参考

*   [`cwiki.apache.org/confluence/display/WW/S2-059`](https://cwiki.apache.org/confluence/display/WW/S2-059)
*   [`blog.csdn.net/sho_ko/article/details/84175306`](https://blog.csdn.net/sho_ko/article/details/84175306)