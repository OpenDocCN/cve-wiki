# frome CVE-2018-8174 to CVE-2018-8625 - goabout2 - 博客园

> 原文：[`www.cnblogs.com/goabout2/p/10259308.html`](https://www.cnblogs.com/goabout2/p/10259308.html)

2018 年，vbscript 相关的漏洞异军突起，两个在野 0day 的 APT 攻击使得 Vbscript 相关的漏洞再次进入大众的视野，其中 CVE-2018-8174 这个发生在 erase 函数中的 uaf 漏洞更是分外出众。

该漏洞最有意思的地方不仅在于其在野 0day 的身份，其本身 exp 编写的利用方式也可作为 vbscript uaf 类漏洞利用的典范，其 exp 中大部分代码皆可复用，而这些都不是本文的重点，我想通过这篇文章来聊聊微软对于这个漏洞的修复历程，并以此谈谈一些漏洞相关的事情。

CVE-2018-8174 这个漏洞的修复很有意思：

2018 年 5 月 9 日：360 第一次披露该在野漏洞，微软修复

2018 年 7 月 23 日：360 Vulcan Team 的古河披露了漏洞 CVE-2018-8242，该漏洞和 CVE-2018-8174 发生在同一个函数 erase，之前的补丁没有补全，微软再次修复。

2018 年 9 月 18 日：google project-zero 的[ifratric](https://bugs.chromium.org/u/ifratric@google.com/ "ifratric@google.com")又给出了一个 erase 内相关的 poc，之后被微软命名为 CVE-2018-8625，并再次修复。

可以看到该漏洞的修复一波三折，需要注意的是，这并不是三个发生在同一函数中不同机制的漏洞，相反这三个漏洞关系密切，关注过的朋友就应该知道，实际上三个漏洞在 poc 的构造上都大同小异，而微软在修复补丁上的疏忽却导致了之后连续两个 cve 的诞生，废话不多说，我们来看看这三个漏洞的修复历程。

如下所示可以看到 CVE-2018-8174 相关 erase 函数在调用时的相关处理逻辑，其中最需要注意的是 vbscript!VbsErase 和 oleaut32!_SafeArrayDestroyData，因为微软对于漏洞的相关修复都在这两个函数中。

![](img/c7af260ff889173fd767ea394a1c7c63.png)

由于相关漏洞中需要进行大量的 array 的操作，所以简单来看看 array 在内存中的结构，如下所示为 erase 调用时，栈中传入的 array,array 中包含一个 obj 对象，其中第一个绿色框标记了 array 对象，第二个绿色框标记了一个 tagSAFEARRAY，第三个绿色框标记了 array 对应的元素对象，其类型结构如下所示：

| typedef struct tagSAFEARRAY {USHORT cDims;          //数组维度 USHORT fFeatures;ULONG cbElements;      //一个元素所占字节 ULONG cLocks;PVOID pvData;          //数据的 BufferSAFEARRAYBOUND rgsabound[1];} SAFEARRAY, *LPSAFEARRAY;typedef struct tagSAFEARRAYBOUND {ULONG cElements;      //元素个数 LONG lLbound;         //索引的起始值} SAFEARRAYBOUND, *LPSAFEARRAYBOUND; |

 ![](img/e0dd4d8853eea12bae78a276ea1226d8.png)

# CVE-2018-8174

首先来看看 CVE-2018-8174，如下所示，ClassVuln 类中实现了 Class_Terminate

函数。

1.  poc 中创建一个 ClassVuln 的对象并赋值到 ArrA  array 中
2.  通过 erase 删除 ArrA，从而导致 ArrA(0)中的 ClassVuln 对象被删除，由于 ClassVuln 中定义了 Class_Terminate，因此会进入到 Class_Terminate 中执行。
3.  Class_Terminate 中将 ArrA(0)赋值给 ArrB，并返回，返回后 erase 正常清除 ArrA 中的元素，此时 ClassVuln 被删除。
4.  但是 ArrB 中却保存了 ClassVuln 的引用，从而导致 uaf

 ![](img/a3792221e80304c11275c30ba08c8549.png)

对于 array 中的每一个元素，通过 VariantClear 来进行清空。

![](img/48615d2c150c36712e3df29c0aca9a1f.png)

如下所示对 ArrA 调用 erase 时 ArrA 的内存状态如下所示：

 ![](img/1a7f3d35cb0043b72b9af1eeb22bd9c9.png)

第二次对 ArrB 调用 erase 时，此时可以看到其中的 ArrB(0)已经被删除，从而导致之后的奔溃。

 ![](img/d894ce5359a5543b94ea97eccdc8cd4e.png)

如上所示，可以知道漏洞在于通过 Erase 释放一个 array 对象时，可以通过 Class_Terminater 回调函数将该对象中的元素进行复制，从而在 Erase 删除后获取一个悬挂指针，因此这个地方如果进行修复的话应该是保证在 Erase 函数中不能再对释放的数组元素中的内容进行操作，我们来看看微软的补丁，8174 的补丁对函数 VariantClear 进行了以下修改，可以看到修改很简单，即当 VariantClear 处理对应的 array 对象的 element 时，将其类型设置为 null，此时由于 element 类型被设置为 null，进入到之后的回调函数时将无法获取到 ArrA 中的漏洞对象元素。

![](img/49b62ba3b889e41a3927dc4b293a149c.png)

如下所示此时 Erase 调用时 ArrA 的内存对象。

![](img/61fa0ae17b7a00fecbf89abcc43e66cf.png)

漏洞对象的类型由 9 被设置 0.

![](img/90f2eb647d5f3d4fd17ffc950c6ebecc.png) 

往下执行 vbscript 引擎报错，因为 ArrA(0)中的漏洞对象类型被设置为 0，vbs 将默认该位置的元素为空。

![](img/4822eae20bd88e66897db2fb02236ae3.png) 

此时 Erase ArrB，我们可以看实际上 ArrB(0)并没有获取到对应的 ArrA(0)引用。

![](img/24c3acd592bb0110312a0c12d9b43de8.png)

# CVE-2018-8242

实际上 8174 的补丁却并没有考虑周全，这就导致了古河发现了第二个漏洞 CVE-2018-8242，在其相关的分析文章中提到，8174 实际只是考虑了在每一个 array 元素进行释放前，将其 type 修改为 null，这确实可以有效的防止攻击者在回调函数中读取 array 中的元素并赋值，从而在 Erase 函数结束后获取一个悬挂指针，但是却并不能防止以下两种情况：

1.  在回调函数中如果再次释放 array 是否可能导致二次释放?
2.  如果 array 中有两个元素，在 VariantClear 处理第二个元素 ray(1)时，其中的元素触发回调是否可以往第一个元素 array(0)进行写操作？

就以上的两个攻击面，当时古河都给出了相关 poc，并证明都是可行的，可以看到这两个攻击面总结起来分别如下：

1.  array 本身是否可以在回调函数中进行修改（但是这里古河只是给出了再次释放的例子，实际上读写也是应该考虑的，这就为第三个漏洞 CVE-2018-8265 埋下了种子）
2.  array 中的元素在回调函数中是可以进行写入的

此处我们通过第一个攻击面二重释放来看看具体效果，poc 如下，和之前 8174 差不多，只是在回调函数中再次调用 erase 将 ArrA 释放，当回调函数返回，会进行二次释放，从而导致崩溃。

 ![](img/b24cd64333b77fb9ea3dd0dc131786be.png)

进入 Erase 函数，此时的 ArrA 数组的内存对象如下所示：

![](img/aa346417f008d4b15cef0d501c5a1068.png)

回调函数中再次调用 Erase。

 ![](img/e50f34b23cd0aaf10ec703048e21e182.png)

此时可以看到 ArrA(0)中的漏洞变量已经设置为 null。

 ![](img/7dd822bdc193786200721cc514633651.png)

回调返回，进入到第一次 Erase 流程时由于对应的 ArrA(0)已经被设置为 null，之后的 memset 函数将直接导致崩溃。

 ![](img/555c8133d15875a9d835ba72525e77bd.png)

此时我们来看看微软对该漏洞的补丁，补丁的位置在 vbscript!VbsErase，此时从函数流程上来看可以发现微软已经将修补的执行流前置了，这是好事，可以看到

1.  VbsRrase 在进入 SafeArrayDestoryData 前直接将将 Safedescription 设置为 0
2.  调用 SafeArrayDestoryData 清空 ArrA 中的元素
3.  Safedescription 恢复
4.  调用 SafeArrayDestroyDescriptor，整个 tagSAFEARRAY 被设置为 null
5.  Safedescription 设置为 0

由于在进入 SafeArrayDestoryData 前 Safedescription 被设置为 0，这将导致在回调函数中再也不能对 array 中的元素进行任何的读写操作，同时回调函数中进行 Erase 操作时，由于会先判断 Safedescription，因此也不能进入到 SafeArrayDestoryData，从而造成二次释放。

![](img/365c2d51113398f69fe745c1ad80041e.png)

对应的汇编补丁如下所示：

 ![](img/8ac76dc2d1b04ba93dd1823c8bd4bbf8.png)

Erase 函数调用，ArrA 函数的内存如下所示：

![](img/f04a06b0c5f7e0a2a241cdf130e6a97d.png) 

对应 Safedescription 被保存，并置空。

![](img/f02fb9dd86718c25f64b36e3315112eb.png) 

如下所示，Safedescription 被设置为 0.

 ![](img/17127240e386d89dd8fd0ec859ed1263.png)

此时第二次调用 Erase，获取的 Safedescription 为空，无法通过判断，从而不会进行之后的释放流程。

![](img/07a062eeb669cb664b016b9e75fa86c9.png)

# CVE-2018-8625

如之前攻击面所述，实际上之前的补丁只是将针对 array 中元素的操作，array 对象释放的操作进行了遏制，但是对于 array 对象本身的读写操作，确实可以进行的，这就是 2018 年 9 月 18 日 google projectzero 报的第三个相关漏洞。

poc 如下所示可以看到依然和 8174 基本一致，只是在回调函数中将 array 对象直接赋值成了 class1 对象，注意这里是针对 array 对象本身，而不是 array 对象中的元素。

 ![](img/6a2d71f5705cd3bcb6599d4fd57975eb.png)

可以看到 Erase 调用前 a 对象的内存结构如下所示： ![](img/c61d206addbf7eb843cee637f3fdee79.png)

Safedescription 被设置为 0.进入函数 SafeArrayDestroyData

![](img/7a773a6c685f561578c5327279ab7ee9.png)

SafeArrayDestroyData 返回，此时可以看 array object 的位置直接被修改了一个对象（8242 中的补丁只是确保 Safedescription 为 0 来防止之后的读写，但是却并没有保障 array 对象本身是否能被修改），回调中直接将 a 这个之前的 array 对象修改为了一个 Class1 对象。

 ![](img/411ee2daa4b83c51bc382d065d4c6e90.png)

此时当 SafeArrayDestroyData 返回，对应的

1.  Safedescription 恢复
2.  调用 SafeArrayDestroyDescriptor，整个 tagSAFEARRAY 被设置为 null
3.  Safedescription 设置为 0

最终 Safedescription 设置为 0，这将导致 class1 对象对应的位置被设置为 null，从而造成之后的 null 地址访问崩溃。

![](img/322867733eb2fb4a25b9bdc7ee3387d0.png)

为了彻底杜绝 Erase 中的漏洞，微软对 vbscript!VbsErase 再次进行了较大的改动。首先在新版本中进入 SafeArrayDestroyData 前，保存 array 对象的 16 个字节的内存，并将 array 的 type 类型设置为 0，并在 SafeArrayDestroyData 返回后判断对应的 array 对象的 type 类型是否被修改，因为凡是在回调中直接尝试对 array 对象本身进行的修改操作肯定会将之前的 type 0 类型的字段修改，因此该判断能防止任何针对该对象的写操作，同时由于 array 对象本身 type 类型被修改为 0，应此不能对该 a 进行相关的读取操作（危害类似 8174），在判断完类型是否修改后，并没有直接信任内存中的 array 对象，而是将之前保存的备份内存进行了还原。

![](img/87f527fa1898237b26c225dc76fc4d87.png)

Erase 函数调用，此时的 a 对象内存。

![](img/f15d018bed4664aaa5c67e5d56ecfbe1.png)

修改 a 对象的 type 类型，注意并没有将 Safedescription 置 null。

![](img/38a7fccb62a9bc3d849fa3438b3d0140.png)

此时 SafeArrayDestroyData 返回，可以看到 array 对象内存数据已经被修改为 class1 对象。

![](img/84b87dae53dc60da6436846ae9be22c4.png)

判断对应的 type 类型标记是否被修改，如果被修改则设置 flag 位。

 ![](img/6a4f18de0cb694135b3aec387a971d0c.png)

将备份数据中 Safedescription 字段设置为 0，并通过备份数据还原之前的 array 对象内存。

 ![](img/0755657c920354ad2d0f0cf14ad12ccc.png)

检测 type 修改的 flag 标记位，由于对应的 type 已经被修改。

 ![](img/d96e138e2a8b4a09cdfc65b33c56e222.png)

直接弹窗报错。

 ![](img/cb4bc115c251483372806b22823dedda.png)![](img/68f724bad5a33d9a9f6bd2ca7369ecb7.png)

错误如下所示：

 ![](img/0c3f871d7d1e5d9cd58c5f62e2da61bf.png)

此时对比之前的那张流程图即可看到微软对 Erase 中相关这个漏洞的三个尝试修改。

![](img/73d89bb74e7aaf6c8797fa2225e75e19.png)

# 总结

最终的 VbsErase 如下：

1.  备份 array 对象的 16 个字节
2.  在进入 SafeArrayDestoryData 前直接 array 对象中的 type 字段设置为 0（CVE-2018-8174 中通过在 VariantClear 中将 array 对象中的元素类型设置为 null，只能防止对 array 中元素的非法读取，CVE-2018-8242 将 array 对象中 Safedescription 设置为 0，可以有效的防止对 array 中元素的修改及 array 对象释放，但是并不能防止对 array 对象本身的修改）
3.  调用 SafeArrayDestoryData 清空 ArrA 中的元素，被设置为 null，pvData 被设置为 0
4.  判断 type 标记是否被修改并设置标记位
5.  调用 SafeArrayDestroyDescriptor，整个 tagSAFEARRAY 被设置为 null
6.  备份中的 Safedescription 被再次设置为 0
7.  array 对象备份写回

可以看到实际上无论是 CVE-2018-8174 还是 CVE-2018-8242，其实瞄准的都是对象中的元素（CVE-2018-8242 二次释放的类型除外），直到两个 0day 连续拳把微软打蒙了，才直接在删除操作前直接将对象中的 Safedescription 指针直接置空，但是 CVE-2018-8625 漏洞却并不是出自对象中的元素，而是对象本身。

利用 CVE-2018-8242 和 CVE-2018-8625 有所区别，但却有着千丝万缕的联系，CVE-2018-8242 主要是在通过 array 对象中的 elment 来实现对对象引用的递增，而 CVE-2018-8625 则是直接通过 array 对象本身来实现对象引用的递增，即 a 与 a(0)的区别，但是本质上却都是引用计数的问题，两个漏洞不过是从 array 对象元素到 array 对象本身的一次升级。

由此可以看到 8174->8242->8625 的以此升级，但本质上都是 array 中的 Erase 删除操作

最早是 array 对象回调可读取 array 对象中的元素，到 array 对象回调可写入 array 对象中的元素，最终到 array 对象回调可修改 array 对象本身，而微软在对 Erase 函数漏洞的补丁修补上却每次都只考虑删除对象的最小校验集，从而导致每次都只能修复其中的某一方面，最终导致了另外两个 cve 的产生。

2018 年自己的工作基本往漏洞分析利用，及在野 0day 发现上转移，其中也发现了 flash 0day 相关的在野攻击，感谢团队各位给予帮助的小伙伴（当然还有小笨蛋），去年最遗憾的是没抓到一个 vbs 的 0day，而在这里作为漏洞研究者其实自己是应该检讨的，之前 CVE-2018-8174 分析得很早，在 vbs 这块也投入较多，却遗漏了微软在修复补丁后多次留下的攻击面。

分析漏洞到底应该做到何种地步，我想不仅仅是对漏洞本身成因，利用原理的理解，更应该是以点破面扩展攻击面眼见的过程，不断重复上述训练，直至相信：挖洞只是体力消耗，而非能力问题（这里无耻借用泉哥的原话）。

最后一首石岩先生的永夜送给各位：

https://music.163.com/playlist?id=38136682&userid=44168812

致我逝去的 2018，声声慢慢，2019。。。。。。

# 参考链接

https://blog.csdn.net/qq_32400847/article/details/77799191

http://blogs.360.cn/post/from-a-patched-itw-0day-to-remote-code-execution-part-i-from-patch-to-new-0day.html

https://googleprojectzero.blogspot.com/2018/12/on-vbscript.html

https://bugs.chromium.org/p/project-zero/issues/detail?id=1668

https://mp.weixin.qq.com/s/WrSZpqgq6gvZwEIqghqggg

 https://music.163.com/playlist?id=38136682&userid=44168812

 转载请注明出处