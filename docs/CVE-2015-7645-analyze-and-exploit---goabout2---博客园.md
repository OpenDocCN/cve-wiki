# CVE-2015-7645 analyze and exploit - goabout2 - 博客园

> 原文：[`www.cnblogs.com/goabout2/p/6209468.html`](https://www.cnblogs.com/goabout2/p/6209468.html)

Hack team 之后 adobe 和 google 合作对 flash 进行了大改，一度提高了 flash 的利用门槛，CVE-2015-7645 作为第一个突破这些限制的漏洞利用方式，可以作为 vetect 利用方式之后的一个模板，应该是今年最后一篇技术文章了哈哈。

# 漏洞分析

POC 由三个 as 文件 superexternalizable，subexternalizable，externalizable 组成。

该漏洞由 IExternalizable 导致，这个类导出两个函数 readExternal 和 writeExternal，poc 创建一个子类 superexternalizable 继承 IExternalizable，并声明对应的 readExternal 和 writeExternal 函数。

 ![](img/ec49c72f9104ec9956f7b770a32c59d1.png)

创建 subexternalizable 类，该类继承 superexternalizable，其中的红框中的 triteExternal 变量的赋值调用是造成漏洞的关键。

![](img/f1ac00cc530f7264ec0234176f1ead88.png) 

此时当 subexternalizable 或 superexternalizable 中存在同名的 writeExternal 的变量时会触发漏洞，编译的时候不要申明成 writeExternal，因为默认编译器是不允许这么写的（野外的该漏洞 exploit 通过将该同名变量申明在 namespace 中绕过该编译器的检测）。

在 externalizable 类里，ByteArray 对象在对 subexternalizable 类进行 writeObject 操作时（该处为一个反序列化操作，此时会去调用 subexternalizable 中的 writeExternal 函数），但是由于 avm 中的问题，对 writeExternal 函数的引用被混淆为对应变量 writeExternal 的引用，从而导致代码混淆可执行，该漏洞也是自 adobe 对 flash 中 vector 的 length 增加校验并配备隔离堆之后，首个突破次限制的漏洞。

 ![](img/cee2695be459d55384b1164697418b4b.png)

编译好之后将其中的 74 改成 77，即 triteExternal->writeExternal.

 ![](img/02f9f2c0fe34ab378f053dd00fd2ffa4.png)

漏洞触发时的地址如下，熟悉 flash 的同学可以发现此处实际上为一处对象中的虚函数调用。

 ![](img/6fcfc66dc35d44a50d4951ad0b63e9b4.png)

下断点 bp FlashPlayer+0063a67a，重启 windbg 之后断下，单步即可。

 ![](img/40ec3bfd48e944b06809afb4dbffc7f5.png)

在 avm 中通过 getproperty 获取对应 object 的 Property 的类型，如下图所示，其中的 getBinding 根据属性名字返回对应的 bindID，该 id 低三位表示对应的 property 类型，其余位表示对应的真正值。

 ![](img/82ac3a7670398ef08bc9906857e81cdb.png)

下图为不同 id 值对应的 property。

![](img/da2a59520ac79f83b41be9cf5e0e110f.png) 

如下图漏洞触发后调试图所示，在进行 sar eax，3 这条指令时，此时 eax 为 19a，该值即为对应的 writeExternal 的 id，通过计算 A=1010->010，此时可以看到为一个 BKIND_VAR 的类型，而不是我们需要的 method 类型。

 ![](img/0487af368a8f235d3e0a22be7a4306d1.png)

之后去掉后三位，获取对应的取值，为 0x33，通过该值获取 method array 中对应的 writeExternal 函数的地址。

![](img/a28736c8b6a5c34fb3ece3758325890e.png)

之后的触发代码相当于执行 call [eax+8]，如下图此时由于 0x33 这个错误的 id（注意此处的 id 是可控的，具体方式就是通过修改 superexternalizable 中变量的个数，每多一个变量增加一）导致计算的 eax 出错，call [eax+8]相当于 call 0，从而报错。

 ![](img/e241882cc6fb836f433423a0ac590548.png)

接下来看看正常版本的情况，如下图所示将触发代码去掉后运行到漏洞触发点时，对应的 eax 为 21。

![](img/0d99e01415c249b38c865e9426ed1f5f.png) 

后三位 id 标识为 1，1=0001->001 BKIND_MOTHED 类型，此时为正常的 mothed 类型。

 ![](img/9a73da63c7e30fafd1638aa0d0388714.png)

此时对应的 edx 即为对应对象的 vtable（虚函数列表对象，该对象偏移 0x8 的位置保存的 methods 数组保存了不同虚函数对象对应的 MethodEnv，如 eax 所示，MethodEnv 对象+0x8 的位置保存了 MethodInfo 对象，MethodInfo 偏移 0x8 的位置保存了该虚函数要调用的函数指针，通过该函数指针最终调用的 writeExternal，具体如下图所示）。

 ![](img/2fd16c47ec2d73a2a9aeb6115c680b2a.png)

对应 Methods 数组。

 ![](img/f3594faf112a07e6924434273b09cfee.png)

对应漏洞的源码如下，漏洞的问题主要在 ClassInfo 中，一开始获取对应 wirteExternal 的 id 时没有对该 id 的类型进行校验，此时攻击者通过特殊的构造可以导致获取的 id 值为对应的构造变量 writeExternal 的 id。

 ![](img/67f0a59930c474fe6e22f31a4d348c91.png)

之后 A 类对象在 writeExternal 函数的真实调用时，该 id 被用作索引，在 MethodEnv 中获取对应的函数指针，通过构造的 writeExternal 变量的 id 通常很大，从而导致 vtable 对象的越界，访问到相邻的 vtable 对象 B 中的方法中，如果此时 B 类的对象为攻击者可控，就会导致 avm 调用该 B 对象的方法，但是涉及到的内存操作却是 A 对象的内存，此时如果 B 类的内存空间远大于 A 类的话，B 类函数的调用就有可能造成 A 内存操作的越界访问。

![](img/01b4b6096f2966df805f7868d62babd6.png)

 ![](img/81705d5b6873d2f37dd2dde833f796c1.png) 

# 漏洞利用

整个漏洞利用思路如下：

1.  vtable 维度上使 subexternalizable 类的 vtable 和可控 MyExt 类的 vtable 相邻
2.  对象内存维度上使 subexternalizable 类的对象和 MyBy（继承自 ByteArray）对象相邻
3.  触发漏洞修改 MyBy 中的 length

 ![](img/991b07e549ef38113c9a8c331aca2a34.png)

## Vtable 布局

因此需要触发漏洞的 A 类（此处使用 subexternalizable）的 vtable 对象和可控 B 类（此处使用 MyExt3）的 vtable 对象在内存中相邻。如下图为对应的类 MyExt3，在该类中包含了三个虚函数 f1-f3。

 ![](img/f7b021e9ae7f2dc22f53e136859c6e3f.png) 

下图为 subexternalizable 类对象和对应的 vtable 对象。

![](img/e7e812c6bdb671b8d8f70b0ecd91e9f9.png)

下图为 MyExt3 对象的 vtable 对象，明显处于低地址可以看到此时 MyExt3 的 vtable 对象要比 subexternalizable 对象的 vtable 小 8 个字节（/4=2），即少了两个虚函数，flash 中的 vtable 是以对象的大小在内存中分配的，即大小相同的 vtable 的在内存中的相邻存储的。

![](img/3015c560ae505dce1df93ec5c7c81613.png)

superexternalizable 类加对应继承类 subexternalizable 一共 2+3=5 个虚函数（要把 sub 中的三个算上），但是 MyExt3 中只有 3 个，因此需要在 MyExt3 中的增加两个虚函数。

补充之后重新编译，两个虚函数已经相邻了

![](img/0fc2809882cb196ae25b60e00035c9c6.png) 

修改后的代码，MyExt4-7 分别继承 MyExt3，并补充了增加的两个虚函数。

![](img/e99559eace3231faf014e7c0bcad1a70.png) 

对应的 MyExt4 类，5-7 类似。

![](img/f6a447ba58624b84b29cf09a45343b2a.png) 

此时再编译运行之后

Subexternalizable 的 vtable 如下为 044b6b20。

![](img/a5e3e81d339e818e4b64f4697d622139.png) 

MyExt3 对应的四个子类的对象分别如下，在 044b6b60，044b6b80，044b6bc0，044b6be0 四个地址

 ![](img/a3e93f482e38eab91500291f0171e132.png)

对应的 sub myext myext 三个 vtable 对象的内存情况如下，此时在漏洞触发代码调用即会索引 044b6b20 这个函数指针，如果 id 过大，就会访问到相邻 044b6b80（即 MyExt*对应的 vtable 中），由于 id 可控，即可控制调用任意的 044b6b80 中的函数，如下图所示 origin 函数指针为 0455e20，混淆盗用的函数指针为 0455fd00，即 MyExt3 中的 f2 函数，此时 MyExt3 类的大小结构就决定了之后如何覆盖相邻的对象。

 ![](img/7a29f4e128f99a14bbbaaaade81838a4.png)

## 堆 fengshui

现在 subexternalizable 的 vtable 对象已经和 MyExt3 的 vtable 对象内存相邻了，接下来是让 subexternalizable 对象的内存和 bytearray 相邻（主要是 vector 在 19.0.0.193 之后就被增加了对应的安全机制），此处是通过将 subexternalizable 的 vtable 对象混淆成大空间 MyExt3 的 vtable 对象来实现对 subexternalizable 对象之后的 bytearray 对象的 length 修改，从而获取一个全内存读写的 bytearray，下图中通过堆 fengshui 实现将 bytearray 对象稳定的分配到 subexternalizable 对象之后。

 ![](img/0a8d4528f89a6b76419f908e1865f766.png)

MyBy1 为继承 ByteArray 之后的类，其中增加的变量主要用于后期的利用和定位。

 ![](img/9857b754fc0e033e2352cbf0796b25b9.png)

此时的真实内存如下，可以看到相邻的 subexternalizable 和 MyBy 对象。

 ![](img/fa548c9efa2c5e57cc517679febab656.png)

## 修改长度

此时 vtable 维度上 subexternalizable 的 vtable 和 MyExt3 的 vtable 内存相邻，对象维度上 subexternalizable 和 MyBy 内存相邻，混淆发生后，subexternalizable 的 vtable 会被混淆为对应的 MyExt3 的 vtable，即函数调用为 MyExt3 的 vtable，而该函数的 this 指针却没变，因此此时该函数操作的内存空间是 subexternalizable 的内存，如果此时 MyExt3 内中的变量很多，对应函数操作的内存就能大到超过 subexternalizable 对象的内存空间，从而起到修改 MyBy 长度的作用。

如下图所示 MyExt3 中定义大量的 uint 变量，之后在混淆触发函数 f2 中对这些变量的操作实际上就已经超出了 subexternalizable 的内存范围，如下图中 f2 首先通过 MyBy 中的标记 123,11223344 判断位置，之后获取对应 MyBy 中的 buf 指针，并将其长度修改为 0xFFFFFFF6.

 ![](img/6de552825eafdb1cb8c39dfd69e44afc.png)

如下图所示即为 MyBy 的判断指标及对应的 bufaddr（通过该地址可以确认这个超长 bytearray 的位置）。

![](img/52062a7cc8c54a746d4bd1821ec090d0.png) 

测试此时的 ByteArray 的 length。

![](img/0b4dfb604ac1d43f5b732571405c33ee.png) 

此时获取一个巨大的 array。

![](img/44155d565df8c556c1094edc7b8a2f7b.png) 

此时对应的内存如下

![](img/076f087d668a61d04a137138246ae2ab.png) 

此时该处为被修改的 MyBy 对象，由于在 MyExt3 中记录了偏移 0x44 的内容对应的地址，即 0448c500 的地址 A（bufAddre），有了该地址通过减去偏移就可以算出该 MyBy 的地址 04483ca0，及其中对应的 a4（下图中 0448f641），a5，a6 的地址。

![](img/d78f0c4fed2f6542ba7462498c33ca9b.png)

打印出的地址

![](img/5639e2b6e9da2702e670e992588b5d44.png) 

通过该超长的 ByteArray，可以访问内存任意地址，注意将 infiniteBy 设置成小端显示，由 ByteArray 的问题导致，设置 position 时需要减去 287454020，这个地方导致 MyBy 的 a0 值需要被设置成了 0。

![](img/c287d0936650dcf0c5bbdd9ca048f53b.png) 

通过调试确定虚函数及 a4 变量的地址分别在 bufAddr 地址-68，和+40 的位置。

在 externalizable 中将 trige 设置为全局变量

![](img/47d8f9cf1a507dd5b75544d63011d024.png) 

通过设置 a0，将 position 设置为 0，这样的话读取的时候就不需要做-11223344 的操作了，在 GerAddr 函数中将 infiniteBy 中的 a4 域作为对象容器，以后对于任意的对象只要将其赋值到 infiniteBy.a4 中，即可对该对象的地址进行读取，GetAddrV0 用于读取对应的 vector 对象中的 buf 对象（shellcode 会保存在该对象中）

![](img/6bdd2d477e8d1a9425c1d87f08fcedfe.png) 

此时拥有了全内存读写及对应的对象地址获取的能力之后，即可以对内存中的 virtualprotect 函数进行搜索，之后的代码可以借鉴 HackTeam 泄露出来的 flash 利用代码来实现。

首先按 MZ 搜索出对应 pe 文件。

![](img/3b18ebe5e27687ce21365100bad28f95.png) 

搜索出对应的 kernel32.dll

![](img/043d4feef44a4423d3d489c7863500b2.png) 

最后找到对应 virtualprotect 函数

![](img/f7baee0def4bedcb0d7c82a0b153621f.png) 

如下图所示获取的 virtualprotect 函数地址。

![](img/5ba761e37598f046d77e49825c5ec998.png) 

CallVP 调用 virtualprotect 将 shellcode 设置为可执行。

使用的 Shellcode 会保存在 vector 中。

![](img/d2d11da8887bb0d0dd1d169e8264bf42.png)

获取 vector 中的 content 中的指针，即上图中对应的 shellcode 地址，其实就是获取 vector 对象偏移 1c 处的 content 指针（调试版本和正常版本有所区别），content 指针偏移+8 的位置即为对应的内容。

 ![](img/d78825beaed2d3df897306c19423b20d.png)

运行之后结果如下，此时的 shellcode 是不可执行的。

![](img/b1bcbe0948d5b962ae0178954523f1c1.png)

首先定义一个 PayLoad 函数，通过修改该函数的 vtable 函数实现 virtualprotect 函数的调用（即将其 vtable 函数替换为 virtualprotect 函数即可），如下图所示首先获取该函数对象的地址，之后分别保存对象指针，及 vtable 指针。

![](img/cea884ed38d8242c880123111dd159cf.png) 

将 vtable 替换成 virtualprotect 函数，并设置对应参数（将对应的 Payload vector 中 shellcode 的地址，长度传入，可执行标志），调用 virtualprotect，最后通过 Set 将修改的 vtable 修改回来。

![](img/6d7e0a26eef277cf7ba946508171145b.png) 

运行之后可以发现此时 shellcode 获取了对应的执行权。

![](img/8d22497ebd4e3fb4e406f57288e64344.png)

此时 shellcode 已经绕过 dep，再次通过 PayLoad 将其 vt 函数修改为对应的 shellcode 地址

 ![](img/432bcca8810184860d707969abaeeb0a.png)

运行之后，熟悉的计算器。

 ![](img/8b27180308c1aa34ad5a0a89717e3c91.png)

 转载请注明出处