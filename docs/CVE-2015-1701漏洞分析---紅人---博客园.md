# CVE-2015-1701 漏洞分析 - 紅人 - 博客园

> 原文：[`www.cnblogs.com/feizianquan/p/16297938.html`](https://www.cnblogs.com/feizianquan/p/16297938.html)

### 0x00 漏洞信息

漏洞影响：本地提权

漏洞文件：win32k.sys

漏洞函数：xxxCreateWindowEx

漏洞原因：释放重引用

漏洞日期：2015 年 5 月 12 号

### [【漏洞分析合集】](https://www.cnblogs.com/feizianquan/p/10882161.html)

### 0x01 漏洞分析

漏洞函数流程就是

user32!CreateWindowExW

user32!NtUserCreateWindowEx

进内核

win32k!NtUserCreateWindowEx+0x2a8

win32k!xxxCreateWindowEx+0x4a8

win32k!xxxCreateClassSmIcon+0x7f

win32k!xxxClientCopyImage

KeUserModeCallback  用户回调 这里

xxxCreateClassSmIcon 该窗口类的图标创建小图标缓存  会回到用户层 这时可以 hook ClientCopyImage 函数 实现权限提升

权限提权函数调用

win32k!xxxCreateWindowEx+0xcec  

win32k!xxxClientCopyImage   

win32k!xxxAdjustSize+0x24

win32k!xxxInitSendValidateMinMaxInfo+0x14

win32k!xxxInitSendValidateMinMaxInfoEx+0x281

win32k!xxxSendMessage+0x28

win32k!xxxSendMessageTimeout+0x1ac  call esi 到 3 环地址 执行 shellcode

完成利用流程就是

1.先注册一个 RegisterClassEx  窗口类 注册时  自定义字段 lpfnWndProc 一个窗口过程函数

2.InterlockedExchangePointer  hook  User32_ClientCopyImage 3 环函数

3\. 调用 CreateWindowEx   执行到 xxxCreateClassSmIcon  会回到 3 环 User32_ClientCopyImage  函数 已经被 hook

4\. hook 函数 调用 SetWindowLongPtr 重新设置 lpfnWndProc 窗口过程函数  为默认的系统内核函数 DefWindowProc

5.SetWindowLongPtr，当 index(GWLP_WNDPROC(-4) ) <0，会调用 SetWindowData 来完成最终的设置。

6.User32_ClientCopyImage   返回 进行执行 CreateWindowEx 内核 的 MapClientNeuterToClientPfn 转化当前窗口类函数的默认 WindowProc（也就是用户模式可控的函数），再将窗口对象的 WindowProc 设置为用户自己的窗口对象

SetWindowData 修改窗口的 WindowProc 为 DefWindowProc 是无效的，窗口的 WindowProc 还是被修改为用户模式应用程序设置的 WindowProc，窗口过程处理函数也变成了用户的窗口函数。而此时，这个窗口的标志已经被设置为是需要在内核模式执行 WindowProc，那么接下来再遇到 SendMessage 等函数对这个窗口发送消息时，就会在内核模式下直接跳转、调用实际在用户模式的函数来进行处理，从而直接导致内核模式代码执行

7.xxxAdjustSize  里面有 xxxSendMessage  会发送消息 默认调用到前面 3 环的函数 就是 shellcode 完成提权

![](img/b4d49f6827341d3d22e7e8569922d07b.png)

###  0x02 参考链接

https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-1701