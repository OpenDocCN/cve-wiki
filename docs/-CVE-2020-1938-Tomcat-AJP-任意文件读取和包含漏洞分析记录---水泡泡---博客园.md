# 【CVE-2020-1938】Tomcat AJP 任意文件读取和包含漏洞分析记录 - 水泡泡 - 博客园

> 原文：[https://www.cnblogs.com/r00tuser/p/12343153.html](https://www.cnblogs.com/r00tuser/p/12343153.html)

**0x00 前言**2020年2月20日傍晚，在某群看到有群友问CNVD的tomcat文件包含漏洞有什么消息没![](../Images/1f8b88677e083aca987387931de12f6d.png)接着看到安恒信息应急响应中心公众号发了个漏洞公告随后chy师傅也在群里发了个阿里云的公告链接根据安恒和阿里云公告给出的信息我们知道是tomcat ajp服务出了问题，但具体是哪里出了问题却不知道。（这个时候我就在想阿里云是怎么知道ajp服务出了问题的呢？![](../Images/4e2b2ebdc85f25cdbc3d472916b57ad9.png)以tomcat7为例给出的修复版本是100，遂去github看commit，看100版本release之前的commit记录。**0x01 初见端倪**找到15天前相关ajp的commit![](../Images/c72ab778444d59d29692b3bfa0210f19.png)从最下面往上看：1，先是默认不开启AJP connector，然后又是修改默认绑定地址，绑定在本地![](../Images/4da381ec72cfaac0fa97d1d31ad766ec.png)

2，修改一个属性设置

[https://github.com/apache/tomcat/commit/40d5d93bd284033cf4a1f77f5492444f83d803e2](https://github.com/apache/tomcat/commit/40d5d93bd284033cf4a1f77f5492444f83d803e2)

![](../Images/c59b338741bb67b54e6985fbdb7551ee.png)

 强制设置认证secret，否则不启动AJP Connector

3，添加一个新AJP属性

[https://github.com/apache/tomcat/commit/b99fba5bd796d876ea536e83299603443842feba](https://github.com/apache/tomcat/commit/b99fba5bd796d876ea536e83299603443842feba)![](../Images/18c473c3eb1377047b39e066adcc3c43.png)

 应该就是新属性这里。

因为原本的代码里面会把不识别的属性添加进去，从而导致操纵内部数据。（但怎么操纵呢？）

[https://github.com/apache/tomcat/commit/b99fba5bd796d876ea536e83299603443842feba#diff-e5bf250e10dab446db3ee424bc5c9ba8L871](https://github.com/apache/tomcat/commit/b99fba5bd796d876ea536e83299603443842feba#diff-e5bf250e10dab446db3ee424bc5c9ba8L871)

![](../Images/390572c00f88f48fd03a01774568c63d.png)

接下来重点是分析ajp协议交互，如何发送属性后面翻资料，看到cnvd的公告（[https://www.cnvd.org.cn/webinfo/show/5415](https://www.cnvd.org.cn/webinfo/show/5415)）![](../Images/f14e2399cba7e00eea1ee5ae702ff44a.png)

注意公告里面的这句话

> 相关参数可控，构造特定参数”

加上前面对commit的分析，也从侧面证实了自己的想法。课间休息，吃个饭回来安恒研究院公众号直接发了分析文章（https://mp.weixin.qq.com/s/GzqLkwlIQi_i3AVIXn59FQ）直接就抛出了要控制的三个属性

 ![](../Images/9cff033728fde85612cbedff531a84a8.png)

与及两种利用方式

> 1、利用DefaultServlet实现任意文件下载 (不带后缀)
> 
> 2、通过jspservlet实现任意后缀文件包含 （带jsp后缀）

 这下子就全明白了，接下来就是下载tomcat源码调试了。

**0x02 环境搭建**

环境搭建这块其实是在吃饭之前就弄了，因为一直被吹去吃饭，导致一直配置不成功源码导入idea。根据这个文章：[https://blog.csdn.net/u013268035/article/details/81349341](https://blog.csdn.net/u013268035/article/details/81349341)，我用的是tomcat 7.0.99搭建环境有几个注意点：**1，我们需要下载两个tomcat，一个是tomcat源码压缩包（https://archive.apache.org/dist/tomcat/tomcat-7/v7.0.99/src/apache-tomcat-7.0.99-src.zip），另一个是tomcat可执行的压缩包。（https://archive.apache.org/dist/tomcat/tomcat-7/v7.0.99/bin/apache-tomcat-7.0.99-windows-x64.zip）****2，根据文章，注意是将tomcat可执行文件压缩包里面的webapps和conf拷贝到源码的home目录****3，新建一个pom.xml，复制一下即可**

```
<?xml version="1.0" encoding="UTF-8"?>
<project 

         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

    <modelVersion>4.0.0</modelVersion>
    <groupId>org.apache.tomcat</groupId>
    <artifactId>Tomcat7.0.99</artifactId>
    <name>Tomcat7.0.99</name>
    <version>7.0</version>

    <properties>
        <java.version>1.7</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.apache.ant</groupId>
            <artifactId>ant</artifactId>
            <version>1.7.1</version>
        </dependency>
        <dependency>
            <groupId>ant</groupId>
            <artifactId>ant-apache-log4j</artifactId>
            <version>1.6.5</version>
        </dependency>
        <dependency>
            <groupId>ant</groupId>
            <artifactId>ant-commons-logging</artifactId>
            <version>1.6.5</version>
        </dependency>
        <dependency>
            <groupId>wsdl4j</groupId>
            <artifactId>wsdl4j</artifactId>
            <version>1.6.2</version>
        </dependency>
        <dependency>
            <groupId>javax.xml.rpc</groupId>
            <artifactId>javax.xml.rpc-api</artifactId>
            <version>1.1</version>
        </dependency>
        <dependency>
            <groupId>org.eclipse.jdt.core.compiler</groupId>
            <artifactId>ecj</artifactId>
            <version>4.5.1</version>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <finalName>Tomcat7.0</finalName>
        <sourceDirectory>java</sourceDirectory>
        <resources>
            <resource>
                <directory>java</directory>
            </resource>
        </resources>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.0</version>
                <configuration>
                    <encoding>UTF-8</encoding>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

```

成功跑起来（后补的图）

![](../Images/f310eaf19c25224557db2da3c4365c97.png)

接下来的问题就在于如何用ajp协议与tomcat交互，然后动态调试了交互这块，两个方法：1，直接根据官方文档手撸2，找人家写好的在之前长亭科技（漏洞发现者）发了漏洞公告，还起了个名字叫“幽灵猫”，搭配发了poc检测到xray，拉下xray用wireshark抓包分析了一下发现只是检测一下版本而已，但是有一个标头让我觉得奇怪，“AJP_REMOTE_PORT”，这个东西应该就是属性了。![](../Images/e58017a617faab2d0a8bb23a1a4a297e.png)

回到正题，代码太水，手撸时间花费太多了，直接找别人写好的，github大法好，直接搜索ajp

![](../Images/e088180b96f4593441d444d0f5ea220b.png)

找到两个库，看一下READEME，选择了python版本拉下来研究一下代码(代码很熟悉就是chy师傅推特gif图上面的)，又看到了我们熟悉的"AJP_REMOTE_PORT"![](../Images/a626eb8f0d51884c909675f483aa78b2.png)

接着研究一下代码，改写一下就可以发送我们自己的属性了。

![](../Images/7bcc0dfc8f0625e508a2ec169f1371da.png)

 wireshark抓包，跟xray的poc一样了

![](../Images/4663ff6a2d7cbbcd69734ee1d8cfb911.png)

 **0x03 源码调试**

根据前面，我们可以知道关键点在org.apache.coyote.ajp.AbstractAjpProcessor prepareRequest方法在org.apache.coyote.ajp.AbstractAjpProcessor process方法中 在调用prepareRequest方法的地方下一个断点![](../Images/627c5f5a9c301a292eb65af73b7e24ca.png)

 跟进，直接跟进到Decode extra attributes，也就是获取解析属性设置属性的地方

![](../Images/67ffd13fc9d5fac448db51c1422f3cfb.png)

循环获取，switch判断，看到如果case是属性类型，在最后的一个else里面把没有判断到的属性直接设置到request里面

 ![](../Images/fb63841dd1cbb8a59eab9c90b8956d4c.png)

代码接着往下走，在预处理完了request headers之后，在adapter里面处理request

![](../Images/665ae8c144ca00760266a38100e4ebce.png)

 接着调用容器来处理

![](../Images/3941c2a3c9ea6afc4f69023b271c6180.png)

 根据请求的url是否带JSP后缀，tomcat会将request交由不同的servlet来处理

**不带jsp后缀的，直接用DefaultServlet来处理的情况（文件读取）**

在HttpServlet中根据请求方法调用不同的方法处理

![](../Images/870e71f838dc1b86326966ee375413b9.png)

这里方法是GET，一路跟进去

![](../Images/a046a0cdcae557ac1d2b1de169b41787.png)

 跟进，最后看到处理路径的方法getRelativePath

![](../Images/83c1f3b06d50e1ce021964236cc0d966.png)

 也就是在这里对安恒说的那三个值进行判断

![](../Images/4a929ec5d6b64200824e107eed1c8851.png)

 当javax.servlet.include.request_uri不为空的时候，取javax.servlet.include.path_info和javax.servlet.include.servlet_path的值进行拼接，然后返回path，之后进入lookupCache方法

 ![](../Images/3b538c99b220b2c945edd3c47a14a87d.png)

 这里面的流程先是在缓存里面找，找不到了，然后在本地找，最终来到 org.apache.naming.resources.FileDirContext 的file方法，然后new一个File类对象。

![](../Images/81c3228fed6daa3836337441961bc776.png)

 在File构造函数中会对path进行净化，限制了跨目录

![](../Images/727cd1e906e03c863d364ed276698566.png)

 调用栈

```
file:811, FileDirContext (org.apache.naming.resources)
doLookup:208, FileDirContext (org.apache.naming.resources)
doLookupWithoutNNFE:494, BaseDirContext (org.apache.naming.resources)
lookup:475, BaseDirContext (org.apache.naming.resources)
lookupCache:1463, ProxyDirContext (org.apache.naming.resources)
serveResource:831, DefaultServlet (org.apache.catalina.servlets)
doGet:435, DefaultServlet (org.apache.catalina.servlets)
service:621, HttpServlet (javax.servlet.http)
service:415, DefaultServlet (org.apache.catalina.servlets)
service:728, HttpServlet (javax.servlet.http)
internalDoFilter:303, ApplicationFilterChain (org.apache.catalina.core)
doFilter:208, ApplicationFilterChain (org.apache.catalina.core)
invoke:219, StandardWrapperValve (org.apache.catalina.core)
invoke:110, StandardContextValve (org.apache.catalina.core)
invoke:492, AuthenticatorBase (org.apache.catalina.authenticator)
invoke:165, StandardHostValve (org.apache.catalina.core)
invoke:104, ErrorReportValve (org.apache.catalina.valves)
invoke:1025, AccessLogValve (org.apache.catalina.valves)
invoke:116, StandardEngineValve (org.apache.catalina.core)
service:452, CoyoteAdapter (org.apache.catalina.connector)
process:190, AjpProcessor (org.apache.coyote.ajp)
process:654, AbstractProtocol$AbstractConnectionHandler (org.apache.coyote)
run:317, JIoEndpoint$SocketProcessor (org.apache.tomcat.util.net)
runWorker:1145, ThreadPoolExecutor (java.util.concurrent)
run:615, ThreadPoolExecutor$Worker (java.util.concurrent)
run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)
run:745, Thread (java.lang)

```

最后就是将读取到的资源输出回来

**带JSP后缀jspservlet处理情况（文件包含）**

在jspservlet的service方法断点，从request中属性中取出org.apache.catalina.jsp_file的值放到jspFile中，之后传入到serviceJspFile中处理。

![](../Images/2421dc3f845ed0bc57bbe58b14cc804a.png)

 继续跟进，会先判断jsp 文件是否存在，如果存在，随后才会初始化wrapper，最后调用JspServletWrapper的service方法来解析。

![](../Images/e86d2996323b887ed2175e3592f3c785.png)

 这里继续跟进getResource，当System.getSecurityManager()=true的时候，可从远程加载文件

![](../Images/81267bfbcced7c73c0007a3f8b7f9567.png)

 继续走，先是对path进行规范化处理

![](../Images/8681b3e2d305d690e86ebf899e907c2b.png)

 继续跟进，到最后同样也是在org.apache.naming.resources.FileDirContext file方法中新创建一个File对象，判断文件是否存在。

![](../Images/612b4a5801802a7cc946b7ae47ab94ca.png)

而其中base变量的值为访问的容器的web根目录

**题外：****tomcat内部是如何判断使用哪个servlet的呢？**

在org.apache.tomcat.util.http.mapper internalMapExtensionWrapper方法进行一系列判断，设置wrapper，其中有判断，根据后缀设置warpper，当后缀为jsp或jspx的时候都会用jspServlet来处理

![](../Images/e51af3b6073e52ed084772312e3aa54a.png)

 ![](../Images/a4fa11272cfd41258d30dd4b39618e11.png)

 调用栈如下：

```
internalMapExtensionWrapper:1170, Mapper (org.apache.tomcat.util.http.mapper)
internalMapWrapper:945, Mapper (org.apache.tomcat.util.http.mapper)
internalMap:874, Mapper (org.apache.tomcat.util.http.mapper)
map:742, Mapper (org.apache.tomcat.util.http.mapper)
postParseRequest:782, CoyoteAdapter (org.apache.catalina.connector)
service:446, CoyoteAdapter (org.apache.catalina.connector)
process:190, AjpProcessor (org.apache.coyote.ajp)
process:654, AbstractProtocol$AbstractConnectionHandler (org.apache.coyote)
run:317, JIoEndpoint$SocketProcessor (org.apache.tomcat.util.net)
runWorker:1145, ThreadPoolExecutor (java.util.concurrent)
run:615, ThreadPoolExecutor$Worker (java.util.concurrent)
run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)
run:745, Thread (java.lang)

```

具体的处理逻辑就不说了

**0x04 总结**0，思路一定要冷静清晰，分析清楚最重要的点，明白自己应该做什么这里总结一下自己的思路：看公告，寻蛛丝马迹，然后到github找commit记录，大概理解漏洞的原理，然后根据需要的东西一步步进行（需要AJP交互，如何解决？需要源码调试，环境搭建？）1，漏洞公告以官方为准，细心留意公告的用词2，开源的代码首先想到到github找commit记录3，多方资料辅助验证不足的地方：0，tomcat源码运行流程，安恒是怎么知道DefaultServlet和jspservlet的呢？1，代码能力提升，如果没有人家的轮子，你能自己快速造出来吗？