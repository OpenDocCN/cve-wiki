# 【CVE-2020-1938】Tomcat AJP 任意文件读取和包含漏洞分析记录 - 水泡泡 - 博客园

> 原文：[`www.cnblogs.com/r00tuser/p/12343153.html`](https://www.cnblogs.com/r00tuser/p/12343153.html)

**0x00 前言**2020 年 2 月 20 日傍晚，在某群看到有群友问 CNVD 的 tomcat 文件包含漏洞有什么消息没![](img/1f8b88677e083aca987387931de12f6d.png)接着看到安恒信息应急响应中心公众号发了个漏洞公告随后 chy 师傅也在群里发了个阿里云的公告链接根据安恒和阿里云公告给出的信息我们知道是 tomcat ajp 服务出了问题，但具体是哪里出了问题却不知道。（这个时候我就在想阿里云是怎么知道 ajp 服务出了问题的呢？![](img/4e2b2ebdc85f25cdbc3d472916b57ad9.png)以 tomcat7 为例给出的修复版本是 100，遂去 github 看 commit，看 100 版本 release 之前的 commit 记录。**0x01 初见端倪**找到 15 天前相关 ajp 的 commit![](img/c72ab778444d59d29692b3bfa0210f19.png)从最下面往上看：1，先是默认不开启 AJP connector，然后又是修改默认绑定地址，绑定在本地![](img/4da381ec72cfaac0fa97d1d31ad766ec.png)

2，修改一个属性设置

[`github.com/apache/tomcat/commit/40d5d93bd284033cf4a1f77f5492444f83d803e2`](https://github.com/apache/tomcat/commit/40d5d93bd284033cf4a1f77f5492444f83d803e2)

![](img/c59b338741bb67b54e6985fbdb7551ee.png)

 强制设置认证 secret，否则不启动 AJP Connector

3，添加一个新 AJP 属性

[`github.com/apache/tomcat/commit/b99fba5bd796d876ea536e83299603443842feba`](https://github.com/apache/tomcat/commit/b99fba5bd796d876ea536e83299603443842feba)![](img/18c473c3eb1377047b39e066adcc3c43.png)

 应该就是新属性这里。

因为原本的代码里面会把不识别的属性添加进去，从而导致操纵内部数据。（但怎么操纵呢？）

[`github.com/apache/tomcat/commit/b99fba5bd796d876ea536e83299603443842feba#diff-e5bf250e10dab446db3ee424bc5c9ba8L871`](https://github.com/apache/tomcat/commit/b99fba5bd796d876ea536e83299603443842feba#diff-e5bf250e10dab446db3ee424bc5c9ba8L871)

![](img/390572c00f88f48fd03a01774568c63d.png)

接下来重点是分析 ajp 协议交互，如何发送属性后面翻资料，看到 cnvd 的公告（[`www.cnvd.org.cn/webinfo/show/5415`](https://www.cnvd.org.cn/webinfo/show/5415)）![](img/f14e2399cba7e00eea1ee5ae702ff44a.png)

注意公告里面的这句话

> 相关参数可控，构造特定参数”

加上前面对 commit 的分析，也从侧面证实了自己的想法。课间休息，吃个饭回来安恒研究院公众号直接发了分析文章（https://mp.weixin.qq.com/s/GzqLkwlIQi_i3AVIXn59FQ）直接就抛出了要控制的三个属性

 ![](img/9cff033728fde85612cbedff531a84a8.png)

与及两种利用方式

> 1、利用 DefaultServlet 实现任意文件下载 (不带后缀)
> 
> 2、通过 jspservlet 实现任意后缀文件包含 （带 jsp 后缀）

 这下子就全明白了，接下来就是下载 tomcat 源码调试了。

**0x02 环境搭建**

环境搭建这块其实是在吃饭之前就弄了，因为一直被吹去吃饭，导致一直配置不成功源码导入 idea。根据这个文章：[`blog.csdn.net/u013268035/article/details/81349341`](https://blog.csdn.net/u013268035/article/details/81349341)，我用的是 tomcat 7.0.99 搭建环境有几个注意点：**1，我们需要下载两个 tomcat，一个是 tomcat 源码压缩包（https://archive.apache.org/dist/tomcat/tomcat-7/v7.0.99/src/apache-tomcat-7.0.99-src.zip），另一个是 tomcat 可执行的压缩包。（https://archive.apache.org/dist/tomcat/tomcat-7/v7.0.99/bin/apache-tomcat-7.0.99-windows-x64.zip）****2，根据文章，注意是将 tomcat 可执行文件压缩包里面的 webapps 和 conf 拷贝到源码的 home 目录****3，新建一个 pom.xml，复制一下即可**

```
<?xml version="1.0" encoding="UTF-8"?>
<project 

         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

    <modelVersion>4.0.0</modelVersion>
    <groupId>org.apache.tomcat</groupId>
    <artifactId>Tomcat7.0.99</artifactId>
    <name>Tomcat7.0.99</name>
    <version>7.0</version>

    <properties>
        <java.version>1.7</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.apache.ant</groupId>
            <artifactId>ant</artifactId>
            <version>1.7.1</version>
        </dependency>
        <dependency>
            <groupId>ant</groupId>
            <artifactId>ant-apache-log4j</artifactId>
            <version>1.6.5</version>
        </dependency>
        <dependency>
            <groupId>ant</groupId>
            <artifactId>ant-commons-logging</artifactId>
            <version>1.6.5</version>
        </dependency>
        <dependency>
            <groupId>wsdl4j</groupId>
            <artifactId>wsdl4j</artifactId>
            <version>1.6.2</version>
        </dependency>
        <dependency>
            <groupId>javax.xml.rpc</groupId>
            <artifactId>javax.xml.rpc-api</artifactId>
            <version>1.1</version>
        </dependency>
        <dependency>
            <groupId>org.eclipse.jdt.core.compiler</groupId>
            <artifactId>ecj</artifactId>
            <version>4.5.1</version>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <finalName>Tomcat7.0</finalName>
        <sourceDirectory>java</sourceDirectory>
        <resources>
            <resource>
                <directory>java</directory>
            </resource>
        </resources>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.0</version>
                <configuration>
                    <encoding>UTF-8</encoding>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

```

成功跑起来（后补的图）

![](img/f310eaf19c25224557db2da3c4365c97.png)

接下来的问题就在于如何用 ajp 协议与 tomcat 交互，然后动态调试了交互这块，两个方法：1，直接根据官方文档手撸 2，找人家写好的在之前长亭科技（漏洞发现者）发了漏洞公告，还起了个名字叫“幽灵猫”，搭配发了 poc 检测到 xray，拉下 xray 用 wireshark 抓包分析了一下发现只是检测一下版本而已，但是有一个标头让我觉得奇怪，“AJP_REMOTE_PORT”，这个东西应该就是属性了。![](img/e58017a617faab2d0a8bb23a1a4a297e.png)

回到正题，代码太水，手撸时间花费太多了，直接找别人写好的，github 大法好，直接搜索 ajp

![](img/e088180b96f4593441d444d0f5ea220b.png)

找到两个库，看一下 READEME，选择了 python 版本拉下来研究一下代码(代码很熟悉就是 chy 师傅推特 gif 图上面的)，又看到了我们熟悉的"AJP_REMOTE_PORT"![](img/a626eb8f0d51884c909675f483aa78b2.png)

接着研究一下代码，改写一下就可以发送我们自己的属性了。

![](img/7bcc0dfc8f0625e508a2ec169f1371da.png)

 wireshark 抓包，跟 xray 的 poc 一样了

![](img/4663ff6a2d7cbbcd69734ee1d8cfb911.png)

 **0x03 源码调试**

根据前面，我们可以知道关键点在 org.apache.coyote.ajp.AbstractAjpProcessor prepareRequest 方法在 org.apache.coyote.ajp.AbstractAjpProcessor process 方法中 在调用 prepareRequest 方法的地方下一个断点![](img/627c5f5a9c301a292eb65af73b7e24ca.png)

 跟进，直接跟进到 Decode extra attributes，也就是获取解析属性设置属性的地方

![](img/67ffd13fc9d5fac448db51c1422f3cfb.png)

循环获取，switch 判断，看到如果 case 是属性类型，在最后的一个 else 里面把没有判断到的属性直接设置到 request 里面

 ![](img/fb63841dd1cbb8a59eab9c90b8956d4c.png)

代码接着往下走，在预处理完了 request headers 之后，在 adapter 里面处理 request

![](img/665ae8c144ca00760266a38100e4ebce.png)

 接着调用容器来处理

![](img/3941c2a3c9ea6afc4f69023b271c6180.png)

 根据请求的 url 是否带 JSP 后缀，tomcat 会将 request 交由不同的 servlet 来处理

**不带 jsp 后缀的，直接用 DefaultServlet 来处理的情况（文件读取）**

在 HttpServlet 中根据请求方法调用不同的方法处理

![](img/870e71f838dc1b86326966ee375413b9.png)

这里方法是 GET，一路跟进去

![](img/a046a0cdcae557ac1d2b1de169b41787.png)

 跟进，最后看到处理路径的方法 getRelativePath

![](img/83c1f3b06d50e1ce021964236cc0d966.png)

 也就是在这里对安恒说的那三个值进行判断

![](img/4a929ec5d6b64200824e107eed1c8851.png)

 当 javax.servlet.include.request_uri 不为空的时候，取 javax.servlet.include.path_info 和 javax.servlet.include.servlet_path 的值进行拼接，然后返回 path，之后进入 lookupCache 方法

 ![](img/3b538c99b220b2c945edd3c47a14a87d.png)

 这里面的流程先是在缓存里面找，找不到了，然后在本地找，最终来到 org.apache.naming.resources.FileDirContext 的 file 方法，然后 new 一个 File 类对象。

![](img/81c3228fed6daa3836337441961bc776.png)

 在 File 构造函数中会对 path 进行净化，限制了跨目录

![](img/727cd1e906e03c863d364ed276698566.png)

 调用栈

```
file:811, FileDirContext (org.apache.naming.resources)
doLookup:208, FileDirContext (org.apache.naming.resources)
doLookupWithoutNNFE:494, BaseDirContext (org.apache.naming.resources)
lookup:475, BaseDirContext (org.apache.naming.resources)
lookupCache:1463, ProxyDirContext (org.apache.naming.resources)
serveResource:831, DefaultServlet (org.apache.catalina.servlets)
doGet:435, DefaultServlet (org.apache.catalina.servlets)
service:621, HttpServlet (javax.servlet.http)
service:415, DefaultServlet (org.apache.catalina.servlets)
service:728, HttpServlet (javax.servlet.http)
internalDoFilter:303, ApplicationFilterChain (org.apache.catalina.core)
doFilter:208, ApplicationFilterChain (org.apache.catalina.core)
invoke:219, StandardWrapperValve (org.apache.catalina.core)
invoke:110, StandardContextValve (org.apache.catalina.core)
invoke:492, AuthenticatorBase (org.apache.catalina.authenticator)
invoke:165, StandardHostValve (org.apache.catalina.core)
invoke:104, ErrorReportValve (org.apache.catalina.valves)
invoke:1025, AccessLogValve (org.apache.catalina.valves)
invoke:116, StandardEngineValve (org.apache.catalina.core)
service:452, CoyoteAdapter (org.apache.catalina.connector)
process:190, AjpProcessor (org.apache.coyote.ajp)
process:654, AbstractProtocol$AbstractConnectionHandler (org.apache.coyote)
run:317, JIoEndpoint$SocketProcessor (org.apache.tomcat.util.net)
runWorker:1145, ThreadPoolExecutor (java.util.concurrent)
run:615, ThreadPoolExecutor$Worker (java.util.concurrent)
run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)
run:745, Thread (java.lang)

```

最后就是将读取到的资源输出回来

**带 JSP 后缀 jspservlet 处理情况（文件包含）**

在 jspservlet 的 service 方法断点，从 request 中属性中取出 org.apache.catalina.jsp_file 的值放到 jspFile 中，之后传入到 serviceJspFile 中处理。

![](img/2421dc3f845ed0bc57bbe58b14cc804a.png)

 继续跟进，会先判断 jsp 文件是否存在，如果存在，随后才会初始化 wrapper，最后调用 JspServletWrapper 的 service 方法来解析。

![](img/e86d2996323b887ed2175e3592f3c785.png)

 这里继续跟进 getResource，当 System.getSecurityManager()=true 的时候，可从远程加载文件

![](img/81267bfbcced7c73c0007a3f8b7f9567.png)

 继续走，先是对 path 进行规范化处理

![](img/8681b3e2d305d690e86ebf899e907c2b.png)

 继续跟进，到最后同样也是在 org.apache.naming.resources.FileDirContext file 方法中新创建一个 File 对象，判断文件是否存在。

![](img/612b4a5801802a7cc946b7ae47ab94ca.png)

而其中 base 变量的值为访问的容器的 web 根目录

**题外：****tomcat 内部是如何判断使用哪个 servlet 的呢？**

在 org.apache.tomcat.util.http.mapper internalMapExtensionWrapper 方法进行一系列判断，设置 wrapper，其中有判断，根据后缀设置 warpper，当后缀为 jsp 或 jspx 的时候都会用 jspServlet 来处理

![](img/e51af3b6073e52ed084772312e3aa54a.png)

 ![](img/a4fa11272cfd41258d30dd4b39618e11.png)

 调用栈如下：

```
internalMapExtensionWrapper:1170, Mapper (org.apache.tomcat.util.http.mapper)
internalMapWrapper:945, Mapper (org.apache.tomcat.util.http.mapper)
internalMap:874, Mapper (org.apache.tomcat.util.http.mapper)
map:742, Mapper (org.apache.tomcat.util.http.mapper)
postParseRequest:782, CoyoteAdapter (org.apache.catalina.connector)
service:446, CoyoteAdapter (org.apache.catalina.connector)
process:190, AjpProcessor (org.apache.coyote.ajp)
process:654, AbstractProtocol$AbstractConnectionHandler (org.apache.coyote)
run:317, JIoEndpoint$SocketProcessor (org.apache.tomcat.util.net)
runWorker:1145, ThreadPoolExecutor (java.util.concurrent)
run:615, ThreadPoolExecutor$Worker (java.util.concurrent)
run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)
run:745, Thread (java.lang)

```

具体的处理逻辑就不说了

**0x04 总结**0，思路一定要冷静清晰，分析清楚最重要的点，明白自己应该做什么这里总结一下自己的思路：看公告，寻蛛丝马迹，然后到 github 找 commit 记录，大概理解漏洞的原理，然后根据需要的东西一步步进行（需要 AJP 交互，如何解决？需要源码调试，环境搭建？）1，漏洞公告以官方为准，细心留意公告的用词 2，开源的代码首先想到到 github 找 commit 记录 3，多方资料辅助验证不足的地方：0，tomcat 源码运行流程，安恒是怎么知道 DefaultServlet 和 jspservlet 的呢？1，代码能力提升，如果没有人家的轮子，你能自己快速造出来吗？