# 看个 AV 也中招之 cve-2010-2553 漏洞分析 - i 春秋 - 博客园

> 原文：[`www.cnblogs.com/ichunqiu/p/7910704.html`](https://www.cnblogs.com/ichunqiu/p/7910704.html)

试想：某一天，你的基友给你了一个视频文件，号称是陈老师拍的苍老师的老师题材的最新电影.avi，你满心欢喜，在确定文件格式确实为 avi 格式后，愉快的脱下裤子准备欣赏，打开后却发现什么也没有，而随后你的基友就控制了你的电脑，把你辛辛苦苦珍藏了二十年的片源全部偷走了…….

> **本文作者：[i 春秋作家——降草](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)**

**今天我们分析的漏洞就是一个利用播放器解压缩时处理不当引起的远程执行漏洞，这个漏洞并没有大规模流行，我们只是从技术角度解析漏洞成因。**

**0x 00 漏洞介绍**  

CVE 2010-2553 漏洞，也称为 MicrosoftWindows Cinepak 编码解码器解压缩漏洞，影响的操作系统版本有：Microsoft Windows XP SP2 和 SP3，WindowsVista SP1 和 SP2，以及 Windows 7。

漏洞原因在于 Cinepak 编码解码器对媒体文件解压缩时代码控制不恰当，可导致远程代码执行。如果用户打开特制的媒体文件，此漏洞可能允许执行代码。如果用户使用管理用户权限登录，成功利用此漏洞的攻击者便可完全控制受影响的系统。

漏洞利用 wmplay.exe，而 wmplay.exe 这个播放器在国内很少有人使用，如果被攻击者使用了第三方的视频播放软件，很难攻击成功，这可能也是这一漏洞不被分析重视的一大原因。

**0x 01 漏洞触发**

本文分析环境如下：

| **操作系统** | Xp sp3 |
| --- | --- |
| **iccvid.dll****版本** | 1.10.0.12 |

通过在 exploit-db 网站上得到触发漏洞的 python 脚本，运行 python 脚本后，生成可触发漏洞的 poc.avi，这就是我们分析的样本文件。(python 脚本在文末的附件中)
通过公告可知，这个漏洞是个堆溢出漏洞，在分析堆漏洞时，肯定是 hpa + ust 大法好。所以，首先我们要开启 hpa、ust

![1.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

使用 windbg 加载 wmplay.exe，使用 g 命令，运行 wmplay.exe

将 poc.avi 拖入 wmplay 中，windbg 会触发异常

![2.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

通过崩溃信息猜测是堆中的内存被破坏了，我们看下 edi 的值，并看下这个值是不是堆地址

![3.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

可以看到堆底地址为： [76ad000+600=76b3000](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)，这个地址也正好是 edi 的地址，这正是由于我们使用 glags.exe 开启了页堆检查，堆管理器会在堆块中增加不可访问的栅栏页，当溢出覆盖到栅栏页时就触发了异常。

崩溃的指令为 rep movs 指令，我们看下此时 movs 的内存大小保存在 ecx，内存大小为：

![4.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

只能知道此时，是因为向 edi 中拷贝 800 大小字节的内容时，导致了堆溢出。

在 rep movs 这条指令的上一条指令下断，重新运行

bu iccvid!CVDecompress+0×118:

第一次断下后，查看 edi,ecx 的值：

![5.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

走过 rep movs 指令后，此时并没有崩溃，这就说明，并不是一次**[rep movs](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)**就导致了堆溢出，而是通过多次运行 rep movs 指令，逐渐到到达堆尾，然后就溢出了。。。。

第二次断下的，

![6.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

第二次调用 rep movs 时，还是没有到达堆尾，还没有溢出

第三次断下时，

![7.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

这时，可以看到，edi=76b3000, 76b3000 这个就是我们在一开始崩溃的地方啊！！！

在这里，可以看下 esi 的值

![8.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

可以看到，现在用来覆盖目标地址的数据并不直接就是我们在 poc.avi 中填充的数据，而是一些不知来自何处去向哪里的数据。这点就造成了我们对这个漏洞的利用不能向**[cve 2010 0158](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)**之类的漏洞利用一样通过修改文件内容即可实现覆盖。

**0x 02 漏洞分析**

定位函数
现在我们就定位到漏洞所在的函数，然后通过 ida 分析漏洞所在函数的功能。

在崩溃位置通过 kb 进行栈回溯来定位所在的函数

![9.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

我们 so easy 的就把漏洞所在的函数找到了，这个函数就是 iccvid!CVDecompress 函数。

使用 IDA 查看**[iccvid.dll](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)**文件，找到函数 73b7cbee，发现 ida 并不能识别出函数为**[CVDecompress](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)**函数，纳尼？？这一定是在逗我

这是因为 IDA 没有找到 pdb 文件，但是我们 windbg 却找到了 pdb 文件，我们将 windbg 的 pdb 文件拷贝出来，

在 windbg 中查看 pdb 文件路径

使用[**ida file — load file —pdb file**](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)选择 pdb 文件路径，就可以在 ida 中看到函数名称了。

![10.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

效果如图

![11.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

**分析函数**在函数 73B7CAD6 头下断点后，重新加载程序，断下后，可以看到[**CVDecompress**](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)函数有七个参数：

![12.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

还记得上面分析的 rep movs 指令吗？调用它第三次后就会崩溃，而第一次调用这条指令时的 edi 的值为 076af000，这个 076af000 是什么鬼呢？来自于哪里呢？

答案就是它是 CVDecompress 函数的从第一个参数，偏移 1c 的值(076ad000)加上 2000 后得到的……

CVDecompress 函数的第三个参数 68，代表了未解压的数据长度。

![13.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

这个函数首先会对 cinepak 的压缩格式结构进行判断，随后会按照[cinepak](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)压缩格式解析结构。

Cinepak 压缩格式的总体框架如下：
+———————–+
| Frame Header          |
+———————–+
| Strip 1 Header        |
+———————–+
| Strip 1 Codebooks     |
+———————–+
| Strip 1 Frame Vectors |
+———————–+
| Strip 2 Header        |
+———————–+
| Strip 2 Codebooks     |
+———————–+
| Strip 2 Frame Vectors |
+———————–+
| Strip 3 Header        |

其中  Frame Header 的结构如下：
  7 6 5 4 3 2 1 0        Field Name                    Type
     +—————+
  0  |             | |       Flags                         Byte
     +—————+
  1  |               |       Length of CVID data           Unsigned
     +-             -+
  2  |               |
     +-             -+
  3  |               |
     +—————+
  4  |               |       Width of coded frame          Unsigned
     +-             -+
  5  |               |
     +—————+
  6  |               |       Height of coded frame         Unsigned
     +-             -+
  7  |               |
     +—————+
  8  |               |       Number of coded strips        Unsigned
     +-             -+
  9  |               |
     +—————+

函数首先判断未解压缩的数据长度是不是小于 20H 大小

![14.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

再判断未解压缩的数据长度是不是小于 FrameHeader 中的数据长度

![15.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

比较 Frame Header 中的**[Number of coded strips](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)**是不是小于 0

![16.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

**然后就会对每个 strip****进行遍历，以下都是在对每个 strip****的处理中**

对未解压的数据大小做比较

![17.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

对编码条数据大小做判断

![18.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

判断编码条 ID 为 10 还是 11:

![19.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

对 strip header 中的底部 Y 坐标与顶部 Y 坐标做差，结果乘以一个数后存储起来。

![20.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

当 strip header 中的编码条 ID 为 10 时，会向堆中拷贝数据。

![21.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

最后，会指向下一个 stripHeader 结构。上面这些是对每个 strip 的处理

![22.png](http://image.3001.net/images/20171128/15118469982468.png)

结合 poc.avi 的内容，与上面 IDA 中的结果

![23.png](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

每次当解析到 chunkID 为 20 时，此时，不会向堆里覆盖内容，当解析到 chunkid=0×1100 时，就会向堆数据中复制数据。

因为 poc.avi 中有三处**[chunkid](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)**为 11 的数据块，因此向堆中复制了三次数据，而正是第三次复制时，使堆溢出而崩溃。

**0x 04 漏洞利用**
在 metasploit 平台中暂时没有该漏洞利用的相关模块，在互联网搜索引擎中也暂未找到相关利用样本。本人感觉这个漏洞利用最大的难点在于，拷贝时触发堆溢出时，拷贝的内容很难通过文件内容进行控制，因而无法很好的控制 EIP 指针，无法精准的执行 payload。怎样精准的控制 esi 中的内容，是我以后将在研究学习的内容。本文不再深入。

附件：链接：[`pan.baidu.com/s/1bLLx98`](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl) 密码：mlbj

**0x 05 参考资料**
[`www.cvedetails.com/cve/CVE-2010-2553/`](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

[`technet.microsoft.com/library/security/ms10-055`](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

[`www.cnblogs.com/Ox9A82/p/5715673.html`](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

[`cve.scap.org.cn/CVE-2010-2553.html`](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

[`www.exploit-db.com/moaub-26-microsoft-cinepak-codec-cvdecompress-heap-overflow-ms10-055/`](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

[`multimedia.cx/mirror/cinepak.txt`](https://bbs.ichunqiu.com/thread-10108-1-1.html?from=bkyl)

《漏洞战争》83 页-90 页