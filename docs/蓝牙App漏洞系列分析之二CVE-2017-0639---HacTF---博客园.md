# 蓝牙 App 漏洞系列分析之二 CVE-2017-0639 - HacTF - 博客园

> 原文：[`www.cnblogs.com/HacTF/p/8052238.html`](https://www.cnblogs.com/HacTF/p/8052238.html)

# 蓝牙 App 漏洞系列分析之二 CVE-2017-0639

#### 0x01 漏洞简介

Android 本月的安全公告，修复了我们发现的另一个蓝牙 App 信息泄露漏洞，该漏洞允许攻击者获取 bluetooth 用户所拥有的私有文件，绕过了将应用数据与其他应用隔离的操作系统防护功能。

漏洞信息如下：

*   CVE: CVE-2017-0639
*   BugID: A-35310991
*   严重性: 高危
*   漏洞类型: 信息泄露
*   Updated AOSP versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2

#### 0x02 漏洞缘起

在发现这个漏洞之前，我浏览了 Android [2017 年 2 月的安全公告](https://source.android.com/security/bulletin/2017-02-01)，其中两个并排的高危信息泄露漏洞引起了我的注意：

*   CVE-2017-0420: AOSP 邮件中的信息泄露漏洞
*   CVE-2017-0414: AOSP 短信中的信息泄露漏洞

查看这两个信息漏洞的补丁注释，分别为

*   Don't allow file attachment from /data through GET_CONTENT
*   Thirdparty can attach private files from "/data/data/com.android.messaging/" directory to the messaging app。

涵义非常清晰，似乎邮件和短信 App 均遗漏了对发送的文件进行验证，本地攻击者可以添加 App 私有目录的数据文件发送出去，从而破坏了 Android 沙箱所提供的应用数据相互隔离的安全防护功能。

这两个漏洞可以归纳为一类针对具有对外发送或共享功能 App 的攻击，Android 中会不会还有类似的功能具有类似的漏洞？另外，注意到上述两个漏洞的发现者并非一人，只是巧合地同时出现在 2 月份的安全公告之中，发现者似乎还没有意识到这类攻击的通用性，也许真的还没有搜刮干净？

#### 0x03 攻击面——蓝牙的信息分享

除了短信、邮件，很容易想到蓝牙也是 Android 一个很重要的信息对外发送出口。通常，我们选择一个文件的分享按钮，选择蓝牙，就可以触发蓝牙的文件发送功能，这是通过蓝牙 App 暴露的 BluetoothOppLauncherActivity 所实现。该 Activity 根据传入的 `Intent.ACTION_SEND` 或 `Intent.ACTION_SEND_MULTIPLE` ，启动一个线程处理单个文件或多个文件的对外发送。主要代码如下

```
           /*
 * Other application is trying to share a file via Bluetooth,
 * probably Pictures, videos, or vCards. The Intent should contain
 * an EXTRA_STREAM with the data to attach.
 */
            if (action.equals(Intent.ACTION_SEND)) {
                // TODO: handle type == null case
                final String type = intent.getType();
                final Uri stream = (Uri)intent.getParcelableExtra(Intent.EXTRA_STREAM);
                CharSequence extra_text = intent.getCharSequenceExtra(Intent.EXTRA_TEXT);
                // If we get ACTION_SEND intent with EXTRA_STREAM, we'll use the
                // uri data;
                // If we get ACTION_SEND intent without EXTRA_STREAM, but with
                // EXTRA_TEXT, we will try send this TEXT out; Currently in
                // Browser, share one link goes to this case;
                if (stream != null && type != null) {
                    if (V) Log.v(TAG, "Get ACTION_SEND intent: Uri = " + stream + "; mimetype = "
                                + type);
                    // Save type/stream, will be used when adding transfer
                    // session to DB.
                    Thread t = new Thread(new Runnable() {
                        public void run() {
                            BluetoothOppManager.getInstance(BluetoothOppLauncherActivity.this)
                                .saveSendingFileInfo(type,stream.toString(), false);
                            //Done getting file info..Launch device picker and finish this activity
                                launchDevicePicker();
                                finish();
                            }
                        });
                        t.start();
                        return;
                    } else {
                        Log.w(TAG,"Error trying to do set text...File not created!");
                        finish();
                        return;
                    }
                } else {
                    Log.e(TAG, "type is null; or sending file URI is null");
                    finish();
                    return;
                }
            } else if (action.equals(Intent.ACTION_SEND_MULTIPLE)) {
                final String mimeType = intent.getType();
                final ArrayList<Uri> uris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
                if (mimeType != null && uris != null) {
                    if (V) Log.v(TAG, "Get ACTION_SHARE_MULTIPLE intent
```