# linux CVE-2019-13272 本地特权漏洞 - yunying - 博客园

> 原文：[`www.cnblogs.com/BOHB-yunying/p/11758083.html`](https://www.cnblogs.com/BOHB-yunying/p/11758083.html)

# 漏洞描述

在 5.1.17 之前的 Linux 内核中，kernel / ptrace.c 中的 ptrace_link 错误地处理了想要创建 ptrace 关系的进程的凭据记录，这允许本地用户通过利用父子的某些方案来获取 root 访问权限 进程关系，父进程删除权限并调用 execve（可能允许攻击者控制）。 一个影响因素是对象寿命问题（也可能导致恐慌）。 另一个影响因素是将 ptrace 关系标记为特权，这可以通过（例如）Polkit 的 pkexec 帮助程序与 PTRACE_TRACEME 进行利用。 注意：在某些环境中，SELinux deny_ptrace 可能是一种可用的解决方法。

# 影响版本

```
Linux Kernel < 5.1.17
```

# 复现

```
OS: Ubuntu 16.04

Kernel: 4.15.0-47-generic

```

![](img/a5fc8cfa1a4df10b5755710c6b321cb1.png)

poc 地址：

```
https://github.com/bcoles/kernel-exploits/tree/master/CVE-2019-13272　　
```

下载 poc：

```
wget https://raw.githubusercontent.com/bcoles/kernel-exploits/master/CVE-2019-13272/poc.c　　
```

但是 ubuntu 没装代理的，于是用 curl 下来，传到 ubuntu 上

然后编译

```
gcc -s poc.c -o test

```

![](img/68f54f0015010da50e8fdd8913ae0992.png)

 赋予权限

```
chmod +x test　　
```

创建普通用户

```
useradd test01
su test01
```

![](img/367ea5295c5947867fc1605079d395a1.png)

 运行 poc

```
./test　　
```

第一次实验执行失败：

![](img/888902da890094c400f8d56dfe2edaff.png)

因为在创建用户时候没有创建对应的用户文件夹

```
useradd -d /home/test01  test01 创建用户
passwd test01 设置密码
```

第二次实验复现成功

![](img/933dcfb6916610356d3e6f29e846be45.png)

在 ssh 上同一个普通用户复现

![](img/bcdc0be510db42c537edc429127bf787.png)

 发现是失败的，看了一些文章。发现 ssh 并不能完成提权操作。

# 具体细节

[来源于大佬的博客](https://0x20h.com/p/fe4f.html)

> ```
>  kernel 5.1.17 之前版本中存在安全漏洞，该漏洞源于 kernel/ptrace.c 文件的 ptrace_link 没有正确处理对凭证的记录。攻击者可利用该漏洞获取 root 访问权限。由于 PTRACE_TRACEME 允许的 borked 权限，利用 bug 在概念上很有趣。对象生命周期处理问题可能会导致内存损坏，但它需要以精确的方式进行代码竞争。事实 PTRACE_TRACEME 证明，除了父进程之外，内核还记录了跟踪器的凭据。研究人员概述的方案涉及一个父进程，该进程创建一个子进程，这个子进程会创建子进程。第一个子进程使用命令 pkexec（用于以 root 身份运行程序），第二个子进程运行 PTRACE_TRACEME，然后第一个子进程丢弃其权限。最终结果是父进程可以使用 ptrace 来控制第一个子进程，后者可以使用 ptrace 来控制第二个子进程 - 从而让攻击者获得对两个进程的控制权。
> ```

### Polkit

`Polkit` 在系统层级进行权限控制，提供了一个低优先级进程和高优先级进程进行通讯的系统。和`sudo`等程序不同，`Polkit`并没有赋予进程完全的 root 权限，而是通过一个集中的策略系统进行更精细的授权。

`Polkit`定义出一系列操作，例如运行`GParted`, 并将用户按照群组或用户名进行划分，例如 `wheel`群组用户。然后定义每个操作是否可以由某些用户执行，执行操作前是否需要一些额外的确认，例如通过输入密码确认用户是不是属于某个群组。

### pkexec

> **pkexec** allows an authorized user to execute *PROGRAM* as another user. If *username* is not specified, then the program will be executed as the administrative super user, *root*.

`pkexec 允许授权用户作为另一个用户执行程序。如果没有指定用户名，则程序将作为管理超级用户 root 执行。`

普通用户在 SSH 中使用 pkexec 时会显示如下需要密码验证

> test@ubuntu-vm:~$ pkexec –user root whoami
> ==== AUTHENTICATING FOR org.freedesktop.policykit.exec ===
> Authentication is needed to run `/usr/bin/whoami’ as the super user
> Authenticating as: test,,, (test)
> Password:

在 Gnome 桌面中

![](img/2b55acd8fd2ccaa46de0a140c0e00464.png)

## 在 server 版本中实测无法提权

![](img/6ed2c836554f166dd4aa38a7daf77f33.png)

# 总结

> 通过 poc 代码中的部分代码，推测为`gnome`桌面程序存在的缺陷导致用户可以实现代码层面的条件竞争导致了提权，但是实战中多数服务器不会配备桌面环境，属比较鸡肋的提权漏洞