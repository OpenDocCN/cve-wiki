# phpmyadmin 4.8.1 远程文件包含漏洞（CVE-2018-12613） - 小丸子3689 - 博客园

> 原文：[https://www.cnblogs.com/ffx1/p/12653550.html](https://www.cnblogs.com/ffx1/p/12653550.html)

phpMyAdmin是一套开源的、基于Web的MySQL数据库管理工具。其index.php中存在一处文件包含逻辑，通过二次编码即可绕过检查，造成远程文件包含漏洞。

### phpmyadmin登录模式设置

我们通过身份验证模式的要求，可以有两种配置方案，一种是HTTP和cookie身份验证模式。在这两种模式下，用户必须先在一个登录窗口里输入MySQL数据库的有效用户名和密码，才能使用phpMyAdmin程序。这种做法有两个明显的好处：首先，因为MySQL数据库的密码没有出现在config.inc.php文件里，所以身份验证过程更加安全；其次，允许以不同的用户身份登录对自己的数据库进行管理。这两种身份验证模式尤其适合数据库中多个用户账号的情况。

第二种方案是，config身份验证模式。这种模式下，密码以明文形式保存在config.inc.php文件里。只需要把MySQL用户名和密码直接写入到config.inc.php文件即可。这样，在登录phpMyAdmin时就不会提示输入用户名和密码了，而只直接用config.inc.php文件里写入的用户登录。如果只是在一个本地测试系统上使用phpMyAdmin，可以使用这种模式。

### 漏洞分析

攻击者必须拥有后台权限，phpMyAdmin4.8.0 - 4.8.1版本均受漏洞影响。
漏洞的入口在index.php 54-63行：

```
$target_blacklist = array (
    'import.php', 'export.php'
);

// If we have a valid target, let's load that script instead
if (! empty($_REQUEST['target'])
    && is_string($_REQUEST['target'])
    && ! preg_match('/^index/', $_REQUEST['target'])
    && ! in_array($_REQUEST['target'], $target_blacklist)
    && Core::checkPageValidity($_REQUEST['target'])
) {
    include $_REQUEST['target'];
    exit;
} 
```

`include $_REQUEST['target'];` , 这里的target可以直接传值输入，我们可以传入一个本地文件路径去让其包含，就会造成LFI漏洞。
要想成功包含target，需要满足五个条件：

*   非空
*   必须为字符串
*   不能是index开头
*   不能是黑名单中的文件名（import.php、export.php）
*   通过函数`Core::checkPageValidity`的校验

进入函数 `libraries/classes/Core.php`

```
public static function checkPageValidity(&$page, array $whitelist = [])
{
    if (empty($whitelist)) {
        $whitelist = self::$goto_whitelist;
    }
    if (! isset($page) || !is_string($page)) {
        return false;
    }

    if (in_array($page, $whitelist)) {
        return true;
    }

    $_page = mb_substr(
        $page,
        0,
        mb_strpos($page . '?', '?')
    ); //按?分割字符串，取前半部分
    if (in_array($_page, $whitelist)) {
        return true;
    }

    $_page = urldecode($page);
    $_page = mb_substr(
        $_page,
        0,
        mb_strpos($_page . '?', '?')
    ); //按?分割字符串，取前半部分
    if (in_array($_page, $whitelist)) {
        return true;
    }

    return false;
} 
```

要想使该函数返回true，包含的文件必须包含在白名单`$whitelist`中，
下面是白名单`$whitelist`的内容：
`\libraries\classes\Core.php`

![image.png](../Images/c41f1b838e74fdfabd4ccb39c4e1ddd3.png)

第一个返回true的地方，`$page`参数必须要在白名单中

第二个返回ture的地方需要通过 `mb_substr()和`mb_strpos()`函数处理。

```
$_page = mb_substr(
        $page,
        0,
        mb_strpos($page . '?', '?')
    ); //按?分割字符串，取前半部分
    if (in_array($_page, $whitelist)) {
        return true;
    } 
```

`mb_substr()` 截取字符串：
![image.png](../Images/d0c06852a28de78837d60b27f92ec7e4.png)

`mb_strpos()`查找字符串在另一字符串中的首次出现位置
![image.png](../Images/5ba11fedb608f97c2e8d9b7c9f0c1a8d.png)

即判断?后面的字符串是否满足白名单.

第三处返回true的地方：

```
$_page = urldecode($page);
    $_page = mb_substr(
        $_page,
        0,
        mb_strpos($_page . '?', '?')
    ); //按?分割字符串，取前半部分
    if (in_array($_page, $whitelist)) {
        return true;
    } 
```

此处判断，先将\(page进行urldecode解码，然后再进行？的分割，取值进行判断，只要解码后分割出来的值在\)whitelist中即可满足条件。而在$target 里问号被二次编码为%253f， db_sql.php%253f也会被认为是一个目录，可以用../跨越，成功实现包含。因此命名规范里面没有将%放进去也是该漏洞能在windows下成功利用的一个关键点。（windows文件名不能包含`? /\ *`等符号。）
这样我们可以将？进行二次编码。如果传入target=db_sql.php%253f。在倒数第二个判断中进行白名单校验时，为db_sql.php%3f，不满足，最后一个判断的urldecode后，进行校验时为db_sql.php,符合条件，然后即可成功包含文件。

### 漏洞复现

![](../Images/380b492252bc1e2c7ece432269583ab8.png)

可以利用本地文件包含漏洞的特点：

*   上传sql文件，然后进行包含；
*   开启webshell日志功能，查询webshell语句后，包含日志；
*   将webshell写入字段中，如果数据库在本地，可以直接通过查询数据库文件位置：select @@datadir；然后得到数据库文件存放路径，而字段内容则在数据库名/表名.frm中