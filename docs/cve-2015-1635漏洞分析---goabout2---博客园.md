# cve-2015-1635 漏洞分析 - goabout2 - 博客园

> 原文：[`www.cnblogs.com/goabout2/p/4454294.html`](https://www.cnblogs.com/goabout2/p/4454294.html)

   上周（2015.4.15）爆出的 cve-2015-1635 漏洞，遂分析一番，留作记录。使用 poc 如下。

wget 192.168.16.168/welcome.png --debug --header='Range:bytes=10-18446744073709551615'

从之前的各种报告可知该漏洞起始于 UlpParseRange 函数，对该函数下断，发送 poc 之后断下。查看 HTTP!UlpParseRange 的堆栈情况，从堆栈可以清晰的发现，此时的内核正在对用户发送的 http 包头进行解析。

 ![](img/85dba71b39366f91b87f3b7727e997f5.png)

单步进入该函数，在这个位置会对 poc 中 Range 域的数值进行校验，首先校验 lower 的数值是否大于 0xFFFFFFFFFFFFFFFFFF,此处我们的输入为 a。

 ![](img/d8ecee593bd4b45e31cb2373d53020cb.png)

对比 upper 的数值是否大于 lower。

 ![](img/c213e594b58d7c643b69f548bc5438ad.png)

计算 length 的数值，公式为 length = upper – lower + 1。

 ![](img/86a97776c07fad1f1a4044d38baad51e.png)

实例中 length 为 0xFFFFFFFFFFFFFFFF-a+1 =0xFFFFFFFFFFFFFFF6

总的校验图

 ![](img/d575349893d1cbe460f93f8f24a9a761.png)

在该函数中的校验伪代码

 ![](img/6d380b6cfab9b708f879f5202b5421e7.png)

因此在 HTTP!UlpParseRange 中实现了对 lower，upper 的简单校验，同时生成了 length（注意，此处并没有对生成的 length 的值做任何校验）。

然后函数会继续运行，直到 UlAdjustRangesToContentSize，在该函数中同样会对包括 upper，lower，length 在内的多项数值进行校验，以下为该函数调用时的堆栈。

 ![](img/dce28b9bbe0c98624c6260bd28fadcd1.png)

首先在该函数中同样会检测 lower 的值是否大于 0xFFFFFFFFFFFFFFFF（同于之前 HTTP!UlpParseRange）。

 ![](img/6362da49e518386594d7e352ce61e9f7.png)

校验 lower 是否小于请求的内容的大小 0x2d272（该值为发送请求中的资源的大小）。

 ![](img/7542605fd222fe508a37db042367cb85.png)

通过计算（0x2d272 = 184946）确实与我们请求的图片的大小一致.

 ![](img/fffdc54c6532afe0806b16a4e21efc27.png)

取之前函数 HTTP!UlpParseRange 中生成的 length，校验 length 的值是否大于 0xFFFFFFFFFFFFFFFF。

 ![](img/1f1abc0b2b0b47cd21206a3ceebaef13.png)

计算 Legtncheck = length + setoff（实际就是 lower 的数值）。

![](img/34d773caf5303a20bd5742a7c90c7519.png)

并校验该值是否大于请求内容的大小 0x2d272，此处 lengthcheck = upper-lower+1 +lower ==0

因此此处一定绕过（当 upper 设置为 0xFFFFFFFFFFFFFFFF），该安全校验（而此处也是唯一针对 length 的校验）。

 ![](img/1312d43047e97f70bed5a7967aac1992.png)

在函数的结束处，该问题 length 会被返回，并继续向下传递。

 ![](img/bbae5e9d540fdd273394f5134107cc9d.png)

该函数中的主要校验步骤。

 ![](img/938c29da77e8ceb8c59192bd59e4ff78.png)

该函数的主要校验伪代码

![](img/d3bbd509a0f289e5892f3feacf9b98ab.png) 

之后该参数会传递到 UlBuildFastRangeCacheMdlChain 函数中

UlBuildFastRangeCacheMdlChain,该函数的调用栈

 ![](img/dac51ee5fb793bbe7df435a76cb34ee3.png)

在该函数中会对传入的 length 进行截断，致使 0xFFFFFFFFFFFFFFF6->0xFFFFFFF6。

 ![](img/3be614b706ba257673d662a502782f00.png)

之后会在该函数中连续调用三次 IoBuildPartialMdl，此处可以看看 msdn 中对于该函数的解释。可以使用 IoBuildPartialMdl 来把一个 IRP 请求分解成多个 IRP 请求。

 ![](img/9cdf22ed5e56162e15f6e3c8041eb59f.png)

在第四次时会触发真正的漏洞。此处为传入的第四个参数 SourceMdl。

 ![](img/55816d5df8c0300447284bd54384ca10.png)

第三个参数 length（该值前面生成），也是造成最后蓝屏的原因。

 ![](img/9878e699a3e8b9a127daccdaa8cb745a.png)

此处为第二个参数 TargetMdl。

 ![](img/554baa48a8f6e3f98caaf4e4ee886949.png)

最后是第一个参数 VirtualAddress

 ![](img/52837189aede1b812d861621c10f10f3.png)

此处为函数调用前的两个 Mdl 结构，其中 sourceMdl 的大小只有 2d316 大小，TargetMdl 的大小为 ffffff6，因此理论上通过 targetMdl 能都有足够的空间存储来自 TargetMdl 的值。

 ![](img/11629bfb9b8de6aa3ccca23f4e5fe568.png)

跟进该函数 nt! IoBuildPartialMdl，最后会完成由 SourceMdlàTargetMdl 的赋值，赋值循环之前两个 Mdl 结构的内存状态。

 ![](img/38f5f2d51b225f2d83e4677d823782c7.png)

从 SourceMdl+30 出按 8 比特取值，并赋值到 TargetMdl+30 处

 ![](img/c99d22cbc65b1aa9f41b4c498d2cd344.png)

此处计算之后即为 Target+30 出的地址，复制前两个结构

 ![](img/99651b5bfa22b40e311771ff25bafe14.png)

一次赋值之后

 ![](img/22122a5a9ba70bf53173a39d04b518b9.png)

整个赋值的循环很简单如下，但是为啥会蓝屏了？仔细看下汇编指令就会发现一个可疑的值 rsd，整个过程的循环由该寄存器控制，我们来看看他是如何生成的。

![](img/6e2498b4a2f62b719784a69dbe20d275.png) 

通过 ida 的分析可知 r8d 的生成过程如下，总结起来是:r8d=target.cout&fff+target.offset+fff+1

此处我们生成的结果即为 100000；

![](img/90a9d12b3749ad6da2d2593632839ffd.png) 

次数通过 r8d = r8d + ffffffff，当 r8d 为零时，停止循环赋值，通过编程可知该处会循环 1048576 次，每次赋值 8 位，即为 1048576*8  = 8388608 = 0x800000，即需要从 sourceMdl 中赋值出 0x800000 长度的内容，当通过之前 source.count 的值即可知 count 为 0x2d316<<0x800000,因此此处循环赋值的结果就是越界读取内存，而此时的操作位于内核中，所以 duan 蓝屏了

![](img/6dfe3869078db38e7ab9a26bc4b86cf6.png) 

此处 sourceMdl 的起始位 fffffa800287e930，count 为 2d316，所以 sourceMdl 的结束应该为

fffffa800287e930+2d316=FFFFFA80028ABC46（此处计算方式存在疑问，对内核其实不是很了解），此处发现 FFFFFA80028ABC46 是不能下断，退而求其次，对 FFFFFA80028ABC40 内存度断点，运行。

![](img/e400ec776a8d3a72c20370f8c9736bda.png) 

断下之后，在进行两次循环，此时 FFFFFA80028ABC50 依然可读。

 ![](img/bf76f2ec43526b0802019b4865303b44.png)

但是在 FFFFFA80028ABC58 读取是，发生 pagefault 错误，从而导致蓝屏。

 ![](img/e8da3c7714f7bbed455f2a984df1f677.png)

duan 蓝屏了。。。。

 ![](img/cee0348854318a6e9e60b2ae472f76ce.png)

下图为总的函数触发流程

 ![](img/35f14d6568070956196f1089567af962.png)

一些其他问题

蓝屏的问题

关于蓝屏的限制问题，通过之前的分析出发时需要如下限制

lower<0xffffffffffffffffff

lower<upper

lower<contenlength

length+lower<contenlength

通过上面的总结发现要稳定的触发蓝屏 upper 的值必须恒定为 0xFFFFFFFFFFFFFFFF，lower 的值必须小于 contenlength。满足以上调节即可稳定触发蓝屏。

contenlength 问题

触发蓝屏时需要 poc 中必须有请求资源，即如果只是一个简单的根目录，则不会蓝屏。原因如下图所示，漏洞触发前在韩式 UlSendHttpResponseIoctl 中会有一个判断，请求资源为空进入上一个分支，不为空则进入漏洞触发的分支。

 ![](img/9688d49dc8923ce8f9225b8b72747600.png)

如下图，影响源头来源于其中的 rsp+3C8h+var_333 中的值（该处没有做详细分析）。

![](img/0668f09940b18ad6c836ab20fa1e2f22.png) 

32 位触发的问题

之前漏洞刚爆出来的时候，部门有小伙伴提到 18446744073709551615 这个数 32 为操作系统不识别，32 为系统应该不收影响，但是实际结果是 32 位体统也不能幸免，揪其原因是该大数在 32 位系统中被截断了，如下图所示，对于存储远内存中 length，在传入函数 HTTP!UlAdjustRangesToContentSize 之前，是按 32 为进行的取值，所以该整数溢出绕过在 32 为依然可行。

![](img/fc79aeab0fc1e342ea6b022c2ae4b615.png)

最后感谢某人晚上陪我聊微信，否则一晚上的蓝屏真的会疯的，感谢。。。。