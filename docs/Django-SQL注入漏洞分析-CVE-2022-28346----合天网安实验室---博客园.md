# Django SQL 注入漏洞分析（CVE-2022-28346） - 合天网安实验室 - 博客园

> 原文：[`www.cnblogs.com/hetianlab/p/17390237.html`](https://www.cnblogs.com/hetianlab/p/17390237.html)

## 漏洞简介

Django 在 2022 年发布的安全更新，修复了在 QuerySet 的 annotate()， aggregate()， extra() 等函数中存在的 SQL 注入漏洞。

### 影响版本

2.2<= Django Django <2.2.28 3.2<= Django Django <3.2.13 4.0<= Django Django <4.0.4

需要使用了 annotate 或者 aggregate 或 extra 方法

## 环境搭建

### 搭建特定版本的 django 项目

利用 pycharm 创建一个 python 项目

![image](img/1195c9ff368c8dfc2efc22a55bd687ae.png)​

创建完成项目后在 Settings 中找到 Project: CVE202228346 对应的 Python Interpreter

![image](img/92d7513f706930793014b4ccc014fd58.png)添加存在问题的 Django 版本

![image](img/b205524d8a385e26679c3cce329522cc.png)​

在 Terminal 中执行命令，创建 django 项目

`django-admin startproject CVE202228346`​

![image](img/8ec3449df2088443909eb1a870f5b44a.png)​

配置启动设置

![image](img/c039b2e441965a5f1d5dd2616f936307.png)​

![image](img/ce419e22d6c7e9d9205bb833298ef15b.png)​

运行后就启动了最简单的 django 项目

![image](img/be3d79720c0be50962bcfac2928d3170.png)​

![image](img/7e7a9df2fb07060cf7d89480c4ec2d9b.png)

‍

### 编写配置漏洞代码

折腾来折腾去，出现了很多问题，一度想要放弃说直接采用 docker ，但是在不断的试错下，最终还是编写成功

因为对 python 的 django 不太熟悉，所以其中可能更多的是比较偏向于基础的操作

【----帮助网安学习，以下所有学习资料免费领！加 vx：yj009991，备注 “博客园” 获取！】

　① 网安学习成长路径思维导图
　② 60+网安经典常用工具包
　③ 100+SRC 漏洞分析报告
　④ 150+网安攻防实战技术电子书
　⑤ 最权威 CISSP 认证考试指南+题库
　⑥ 超 1800 页 CTF 实战技巧手册
　⑦ 最新网安大厂面试题合集（含答案）
　⑧ APP 客户端安全检测指南（安卓+IOS）

进入到项目目录下创建命令 创建第一个应用

![image](img/9383914f72d7e33c0397bf53392fe03c.png)​

在 settings.py 中添加配置

![image](img/e9f876e1155d8e0a335eef3c0ac6fd71.png)在 urls.py 中添加 对应的 url，urls.py 相当于路由解析器，将路由解析到对应的 views.py 中对应的函数上

![image](img/d0e25a5b36ffa1f628787868967f7eb6.png)​

```
urlpatterns = [
    path('admin/', admin.site.urls),
    path('index/',views.index),
    path('demo/',views.users),
    path('initialize/',views.loadexampledata)
]
```

‍

models.py 是创建表结构的时候使用，通过类的定义，可以创建一个表

![image](img/7c7f830792915bfda00b53aae781afd3.png)

```
from django.db import models
​
# Create your models here.
class User(models.Model):
    name = models.CharField(max_length=200)
​
    def __str__(self):
        return self.name
```

‍

views.py 主要定义了对应路由所响应的函数

![image](img/634abb8f6efe40bd8b3436e16337f541.png)​

```
from django.db.models import Count
from django.http import HttpResponse
from django.shortcuts import render
from .models import User
​
# Create your views here.
def index(request):
    return HttpResponse('hello world')
​
def users(request):
    field = request.GET.get('field', 'name')
    user_amount = User.objects.annotate(**{field: Count("name")})
    html = ""
    for u in user_amount:
        html += "<h3>Amoount of users: {0}</h3>".format(u)
    return HttpResponse(html)
​
def loadexampledata(request):
    u = User(name="Admin")
    u.save()
    u = User(name="Staff1")
    u.save()
    u = User(name="Staff12")
    u.save()
    return HttpResponse("ok")
```

三个函数分别是 helloword 函数，往数据库中加参数，以及查询数据库中的字段

‍

编写好代码后，需要对数据库执行初始化操作

```
python manage.py makemigrations
python manage.py migrate
```

‍

## 漏洞复现

先访问 initialize 为数据库中添加信息

构造 payload

```
http://127.0.0.1:8000/demo/?field=demo.name" FROM "demo_user" union SELECT "1",sqlite_version(),"3" --
```

![image](img/e81910827dda00cdc51ee726b7efc434.png)​

## 漏洞分析

发现一个问题，在加上断点调试以后，每次运行输出的结果跟不加断点运行的结果存在很大的差异，结果完全不同。不断尝试之后发现是因为在某些地方加上断点之后，在调试器中查看变量和状态可能会影响程序的执行速度和内存使用情况，为了方便的输出某些位置的变量，采用 print 的方法结合断点调试。

![image](img/6e2e282dbb606f610758fd78a7dde620.png)

通过 get 传入的参数 field

`CVE202228346.demo.views.users`​

![image](img/6268b33309b99bc92c812ac39d000dd7.png)

此处的`**{field: Count("name")}`​ 用来表示拆分字典

跟进 `annotate`​ 对传入参数的处理

`django.db.models.query.QuerySet.annotate`​

![image](img/bf540ab40f2a7dbae68adf3f8bc928cb.png)​

继续将参数传入到 `_annotate`​ 进行处理

`django.db.models.query.QuerySet._annotate`​

![image](img/cbdd1ab95aadc97f8e1807eaf9d00359.png)

在将 `kwargs`​ 的值 `update`​ 到 `annotations`​ 后，调用 `add_annotation`​ 进行处理

`django.db.models.sql.query.Query.add_annotation`​​

![image](img/be23a439f480d7473ac23db421e2db54.png)`add_annotation`​ 也是漏洞存在的关键位置，因为修复漏洞的关键位置也在此处

调用 `resolve_expression`​ 解析表达式

`django.db.models.aggregates.Aggregate.resolve_expression`​

![image](img/f8ad924edb927c53fcfbb4489f98011f.png)​

`django.db.models.expressions.Func.resolve_expression`​

![image](img/a05b29174746c4779dec7b78d5b39b13.png)​

`django.db.models.expressions.F.resolve_expression`​​

![image](img/b4fa6cdf4b2e9bcd12fd282f81c80e3d.png)​

`django.db.models.sql.query.Query.resolve_ref`​

![image](img/c8bc82478ce949f9141e12187840ab0f.png)最后我们可以看到 clone 对应的值 以及执行的 SQL 语句

![image](img/3a26ccb59c68f39ec0495fd98f7a752a.png)整个漏洞分析下来，仍然有很多不太清楚的地方，可能再分析几个关于 Django 的漏洞会好一些

‍

## 漏洞修复

![image](img/f80b2c38487cf92298baa2ed230b6c44.png)在 `add_annotation`​ 添加了 `check_alias`​ 来对传入的参数进行校验

**更多网安技能的在线实操练习，[请点击这里>>](https://www.hetianlab.com/)**