# CVE-2018-20169 漏洞学习 - 番茄汁汁 - 博客园

> 原文：[`www.cnblogs.com/likaiming/p/10886154.html`](https://www.cnblogs.com/likaiming/p/10886154.html)

# 简介

在 4.19.9 之前的 Linux 内核中发现了一个问题。USB 子系统在读取与驱动程序/ USB /core/usb.c 中的 _usb_get_extra_descriptor 相关的额外描述符时错误地检查了大小。

# 补丁分析

补丁见这里：[`git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=704620afc70cf47abb9d6a1a57f3825d2bca49cf`](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=704620afc70cf47abb9d6a1a57f3825d2bca49cf)

```
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 5286640..f76b2e0a 100644
--- a/drivers/usb/core/hub.c +++ b/drivers/usb/core/hub.c
@@ -2251,7 +2251,7 @@ static int usb_enumerate_device_otg(struct usb_device *udev) /* descriptor may appear anywhere in config */ err = __usb_get_extra_descriptor(udev->rawdescriptors[0],
                 le16_to_cpu(udev->config[0].desc.wTotalLength), -                USB_DT_OTG, (void **) &desc); +                USB_DT_OTG, (void **) &desc, sizeof(*desc)); if (err || !(desc->bmAttributes & USB_OTG_HNP)) return 0;

diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 79d8bd7..4ebfbd7 100644
--- a/drivers/usb/core/usb.c +++ b/drivers/usb/core/usb.c
@@ -832,14 +832,14 @@ EXPORT_SYMBOL_GPL(usb_get_current_frame_number); */

 int __usb_get_extra_descriptor(char *buffer, unsigned size, -                   unsigned char type, void **ptr) +                   unsigned char type, void **ptr, size_t minsize)
 { struct usb_descriptor_header *header; while (size >= sizeof(struct usb_descriptor_header)) {
         header = (struct usb_descriptor_header *)buffer; -        if (header->bLength < 2) { +        if (header->bLength < 2 || header->bLength > size) {
             printk(KERN_ERR "%s: bogus descriptor, type %d length %d\n",
                 usbcore_name,
@@ -848,7 +848,7 @@ int __usb_get_extra_descriptor(char *buffer, unsigned size, return -1;
         } -        if (header->bDescriptorType == type) { +        if (header->bDescriptorType == type && header->bLength >= minsize) { *ptr = header; return 0;
         }
diff --git a/drivers/usb/host/hwa-hc.c b/drivers/usb/host/hwa-hc.c
index 684d6f0..09a8ebd 100644
--- a/drivers/usb/host/hwa-hc.c +++ b/drivers/usb/host/hwa-hc.c
@@ -640,7 +640,7 @@ static int hwahc_security_create(struct hwahc *hwahc)
     top = itr + itr_size;
     result = __usb_get_extra_descriptor(usb_dev->rawdescriptors[index],
             le16_to_cpu(usb_dev->actconfig->desc.wTotalLength), -            USB_DT_SECURITY, (void **) &secd); +            USB_DT_SECURITY, (void **) &secd, sizeof(*secd)); if (result == -1) {
         dev_warn(dev, "BUG? WUSB host has no security descriptors\n"); return 0;
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 4cdd515..5e49e82 100644
--- a/include/linux/usb.h +++ b/include/linux/usb.h
@@ -407,11 +407,11 @@ struct usb_host_bos {
 }; int __usb_get_extra_descriptor(char *buffer, unsigned size, -    unsigned char type, void **ptr); +    unsigned char type, void **ptr, size_t min); #define usb_get_extra_descriptor(ifpoint, type, ptr) \ __usb_get_extra_descriptor((ifpoint)->extra, \
                 (ifpoint)->extralen, \ -                type, (void **)ptr) +                type, (void **)ptr, sizeof(**(ptr)))
```

总共修改了四个文件，但是修改都围绕着 __usb_get_extra_descriptor 这个函数，包括这个函数的定义以及引用这个函数的位置。补丁中位这个函数增加了一个参数 minsize，然后在 __usb_get_extra_descriptor 的逻辑中增加了判断，在 __usb_get_extra_descriptor 正常退出也就是返回 0 的逻辑之中，让 bLength 必须大于 minsize

# 源码分析

USB 中的 5 种描述符中，都有共同的两个字段，这个两个字段放在描述符的头部，表示描述符长度，描述符类型编号，用 usb_descriptor_header 来表示

```
struct usb_descriptor_header {
    __u8  bLength;
    __u8  bDescriptorType;
} __attribute__ ((packed)); struct usb_device_descriptor {
    __u8  bLength;
    __u8  bDescriptorType;

    __le16 bcdUSB;
    __u8  bDeviceClass;
    __u8  bDeviceSubClass;
    __u8  bDeviceProtocol;
    __u8  bMaxPacketSize0;
    __le16 idVendor;
    __le16 idProduct;
    __le16 bcdDevice;
    __u8  iManufacturer;
    __u8  iProduct;
    __u8  iSerialNumber;
    __u8  bNumConfigurations;
} __attribute__ ((packed)); struct usb_config_descriptor {
    __u8  bLength;
    __u8  bDescriptorType;

    __le16 wTotalLength;
    __u8  bNumInterfaces;
    __u8  bConfigurationValue;
    __u8  iConfiguration;
    __u8  bmAttributes;
    __u8  bMaxPower;
} __attribute__ ((packed)); struct usb_string_descriptor {
    __u8  bLength;
    __u8  bDescriptorType;

    __le16 wData[1];        /* UTF-16LE encoded */ } __attribute__ ((packed)); struct usb_interface_descriptor {
    __u8  bLength;
    __u8  bDescriptorType;

    __u8  bInterfaceNumber;
    __u8  bAlternateSetting;
    __u8  bNumEndpoints;
    __u8  bInterfaceClass;
    __u8  bInterfaceSubClass;
    __u8  bInterfaceProtocol;
    __u8  iInterface;
} __attribute__ ((packed)); struct usb_endpoint_descriptor {
    __u8  bLength;
    __u8  bDescriptorType;

    __u8  bEndpointAddress;
    __u8  bmAttributes;
    __le16 wMaxPacketSize;
    __u8  bInterval; /* NOTE:  these two are _only_ in audio endpoints. */
    /* use USB_DT_ENDPOINT*_SIZE in bLength, not sizeof. */ __u8  bRefresh;
    __u8  bSynchAddress;
} __attribute__ ((packed));
```

在 include\linux\usb\ch9.h 中，可以找到上述这些描述符的定义，然后在该文件中，同样可以找到这些描述符中各个字段的取值，我们看前两个字段 bLength 和 bDescriptorType。

有 USB_DT_CONFIG_SIZE 和 USB_DT_DEVICE_SIZE 等这些宏，这就是 bLength 的取值，表示这个描述符中占多少个字节，__u8 就表示一个字节，__lel16 就表示两个字节。

bDescriptorType 同样，取值是 USB_DT_DEVICE，USB_DT_CONFIG 等，就是单纯用来区分这些描述符的类型

但是除了上述几种描述符之外，还有一类设备定义的描述符和厂商为设备特别定义的描述符。在内核中描述设备、接口、配置、端口等信息的时候，使用的是另外的结构，他们以 usb_host_ 开头，看 include\linux\usb.h 中关于端口的描述，描述符被存放在第一个字段

```
struct usb_host_endpoint { struct usb_endpoint_descriptor        desc; struct usb_ss_ep_comp_descriptor    ss_ep_comp; struct list_head        urb_list; void                *hcpriv; struct ep_device        *ep_dev;    /* For sysfs info */ unsigned char *extra;   /* Extra descriptors */
    int extralen; int enabled;
};
```

结构体中，还会有 extra 字段，这就是上面所说的设备定义的描述符和厂商为设备特别定义的描述符。

好，接下来看 __usb_get_extra_descriptor 的实现，这个函数用来在 buffer 中取出一个特定类型的描述符，地址写在 ptr 中。在修改之前，这个函数有 4 个参数，第一个参数表示描述符数组，第二个参数表示这个 buffer 中描述符项数，第三个参数为需要寻找的描述符类型，第四个参数表示最终结果，描述符位置

```
int __usb_get_extra_descriptor(char *buffer, unsigned size,
                   unsigned char type, void **ptr)
{ struct usb_descriptor_header *header; while (size >= sizeof(struct usb_descriptor_header)) {
        header = (struct usb_descriptor_header *)buffer; if (header->bLength < 2) {
            printk(KERN_ERR "%s: bogus descriptor, type %d length %d\n",
                usbcore_name,
                header->bDescriptorType,
                header->bLength); return -1;
        } if (header->bDescriptorType == type) { *ptr = header; return 0;
        }

        buffer += header->bLength;
        size -= header->bLength;
    } return -1;
}
EXPORT_SYMBOL_GPL(__usb_get_extra_descriptor);
```

所以上面这个函数的逻辑也比较清楚了，从 buffer 中不断遍历，直到找到需要类型的描述符为止。

接下来看调用这个函数的位置，也是上述补丁中调用 __usb_get_extra_descriptor 的两个函数：

usb_enumerate_device_otg 中，需要从 rawdescriptors 中取出 usb_otg_descriptor。rawdescriptors 是字符指针数组，在 USB 枚举阶段，主机使用 GET_DESCRIPTOR 请求去获得配置描述符所得到的结果。所有的配置描述符都放着这里，这个函数中需要取出 USB_DT_OTG，类型的描述符，OTG 是电源管理相关的配置。从这个函数也可以看得出来。config 表示所有的配置描述符，wTotalLength 表示 USB 枚举阶段从设备默认端口获得的配置描述信息的长度

```
__usb_get_extra_descriptor (udev->rawdescriptors[0],
                    le16_to_cpu(udev->config[0].desc.wTotalLength),
                    USB_DT_OTG, (void **) &desc) == 0)
```

hwahc_security_create 中同样的用法，actconfig 表示的是当前正在使用的配置描述符，其他同上。

```
result = __usb_get_extra_descriptor(usb_dev->rawdescriptors[index],
            le16_to_cpu(usb_dev->actconfig->desc.wTotalLength),
            USB_DT_SECURITY, (void **) &secd);
```

# 漏洞分析

所以该漏洞的核心点在于 bLength 的值，补丁在 bLength 异常时会返回-1，有判断 bLength 小于 2 的情况，但是没有判断 bLength 大于 size 的情况，所以最终会造成不正确的数据向上传递。