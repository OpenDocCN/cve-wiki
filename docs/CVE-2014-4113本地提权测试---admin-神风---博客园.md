# CVE-2014-4113 本地提权测试 - admin-神风 - 博客园

> 原文：[`www.cnblogs.com/wh4am1/p/6736768.html`](https://www.cnblogs.com/wh4am1/p/6736768.html)

**CVE-2014-4113 本地提权漏洞分析****By Netfairy**

**前言**

2014 年 10 月 14 日, Crowdstrike 和 FireEye 发表了一篇文章, 描述了一个新的针对 Windows 的提权漏洞. Crowdstrike 的文章表明:这一新漏洞是在追踪一个高度先进攻击团队飓风熊猫(HURRICANE PANDA)发现的, 这之前, 飓风熊猫利用此漏洞进行攻击已至少五个月了.原文 http://www.crowdstrike.com/blog/crowdstrike-discovers-use-64-bit-zero-day-privilege-escalation-exploit-cve-2014-4113-hurricane-panda/. 通用漏洞发布平台随后披露了这个漏洞的部分细节, 该漏洞的 CVE 编号为 CVE-2014-4113\. 报告指出：Microsoft Windows 下的 win32k.sys 是 Windows 子系统的内核部分，是一个内核模式设备驱动程序，它包含有窗口管理器、后者控制窗口显示和管理屏幕输出等。如果 Windows 内核模式驱动程序不正确地处理内存中的对象，则存在一个特权提升漏洞。成功利用此漏洞的攻击者可以运行内核模式中的任意代码。攻击者随后可安装程序；查看、更改或删除数据；或者创建拥有完全管理权限的新帐户。

**环境**
操作系统：windows XP SP3
漏洞文件：Win32k.sys 5.1.2600.6514
调试器：Windbg 6.11.1.404 && Olldbg &&IDA6.6
漏洞验证
我在网上拿到了 POC, 这个 POC 包含了两个文件:Win32.exe 和 Win64.exe
 ![image1.png](http://www.netfairy.net/content/uploadfile/201602/8d1e1456244822.png)
先验证漏洞是否存在, 打开控制台, 直接执行 calc.exe
 ![image2.png](http://www.netfairy.net/content/uploadfile/201602/1a8f1456244826.png)
Calc.exe 进程属于用户 netfairy，然后在转到 Win32.exe 所在目录,，执行 Win32.exe calc.exe
 ![image3.png](http://www.netfairy.net/content/uploadfile/201602/5fb61456244829.png)

再看此时的 calc.exe 进程,是以 SYSTEM 权限运行的，所以这个 win32.exe 在 XP SP3 下提权成功.

**漏洞分析**
**粗略分析 Win32.exe 执行流**
在调试机器用 OD 载入 win32.exe 并添加参数 calc.exe. 程序进入主函数后调用的第一个函数是
 ![image4.png](http://www.netfairy.net/content/uploadfile/201602/1b651456244830.png)
OD 对符号的识别不太好，用 IDA 反汇编这个函数
![image5.png](http://www.netfairy.net/content/uploadfile/201602/715e1456244833.png) 
蓝色部分是程序的执行流程。程序先调用
GetVersionExA
获取系统版本信息，下面就 cmp     [ebp+VersionInformation.dwMajorVersion], 5 等等进行一系列的比较。所以可以看看出这个函数的作用就是获取目标系统版本并比较决定是否进行下一步的攻击。接着 main 函数调用的第二个函数是
 ![image6.png](http://www.netfairy.net/content/uploadfile/201602/f5081456244834.png)
这个函数有点大，就不全贴出来了。总之这个函数首先调用 LoadLibraryA 加载 ntdll.dll，接着调用 GetProcAddress 得到 QuerySystemInformation 地址函数的地址，接着调用 LoadLibraryA 得到 ntkrnlpa.exe 的地址，接着调用 GetProcAddress 得到 LookupProcessByProcessId 的地址，最后调用 GetCurrentProcessId 获得当前进程的 PID。
继续执行，main 函数调用的第三个函数是
 ![image7.png](http://www.netfairy.net/content/uploadfile/201602/316a1456244834.png)
一开始我就猜想这个函数创建的线程应该就是触发漏洞提权的用的。因为 Main 在这之后就是一个 CreateProcessA 调用，显然是执行 shellcode 的。跟进 CreateThread 看看，这个线程调用函数次序如下：
 ![image8.png](http://www.netfairy.net/content/uploadfile/201602/90d61456244835.png)
现在我们还不清楚漏洞是怎么触发的，继续往下执行，main 函数调用 CreateProcessA
 ![image9.png](http://www.netfairy.net/content/uploadfile/201602/13f71456244836.png)
通过传入的命令行参数创建一个新的进程，该进程和 win32.exe 有相同的权限。如果前面一步提权成功，那么新创建的进程将拥有 system 权限。总结一下 main 函数执行流程以及每个函数的作用如下
 ![image10.png](http://www.netfairy.net/content/uploadfile/201602/35811456244838.png)

要分析这个漏洞，只需要分析 call    ds:CreateThread ; //触发漏洞,提权 就好。

**IDA&&Windbg 漏洞详细分析**
**静态分析**
先设置加载 win32.exe 时调试器中断下来
 ![image11.png](http://www.netfairy.net/content/uploadfile/201602/576e1456244843.png)
然后 bp $exentry 断在模块入口点，如图
 ![image12.png](http://www.netfairy.net/content/uploadfile/201602/b21b1456244846.png)
但这里不是 main 函数入口点，继续单步
 ![image13.png](http://www.netfairy.net/content/uploadfile/201602/fafd1456244848.png)
这个就是 main 函数了。然后跟进 main 函数。下面不一一说。直接来到关键函数
 ![image14.png](http://www.netfairy.net/content/uploadfile/201602/6d971456244851.png)
 ![image15.png](http://www.netfairy.net/content/uploadfile/201602/d6661456244861.png)
继续往下执行，TrackPopupMenu 执行前
 ![image16.png](http://www.netfairy.net/content/uploadfile/201602/82c61456244871.png)
TrackPopupMenu 执行后
 ![image17.png](http://www.netfairy.net/content/uploadfile/201602/242d1456244874.png)
可见是由 TrackPopupMenu 最终触发了漏洞，这是从用户层看到的，下面跟踪 TrackPopupMenu 对应的内核函数 win32k!xxxTrackPopupMenuEx
 ![image18.png](http://www.netfairy.net/content/uploadfile/201602/48711456244874.png)
1. 在 win32k!xxxTrackPopupMenuEx 中进行一些列处理后，最终会调用 win32k! xxxMNLoop
 ![image19.png](http://www.netfairy.net/content/uploadfile/201602/0b291456244875.png)
2. 跟进 win32k! xxxMNLoop，函数又会调用 win32k!xxxHandleMenuMessages
 ![image20.png](http://www.netfairy.net/content/uploadfile/201602/a3b51456244876.png)
3. 继续跟进 win32k!xxxHandleMenuMessages，其会事先调 win32k! xxxMNFindWindowFromPoint 得到 win32k! xxxSendMessage 需要的菜单窗口对象指针 ptagWND，之后再调用 win32k! xxxSendMessage 给菜单窗口发送消息。
4. 跟进 wn32k! xxxMNFindWindowFromPoint，函数首先调用 win32k! xxxSendMessage 给菜单窗口发送 0x1EB(MN_FINDWINDOWFROMPOINT)消息
 ![image21.png](http://www.netfairy.net/content/uploadfile/201602/3aeb1456244876.png)
在应用层，程序调用 SetWindowsHookExA 安装了一个一个钩子类型为 4，也就是 WH_CALLWNDPROC 类型的钩子(SetWindowsHookExA 与钩子类型见：https://msdn.microsoft.com/en-us/library/ms644990%28VS.85%29.aspx?f=255&MSPPError=-2147217396)，应用层会拦截内核发来的 0x1EB 消息，钩子处理函数如下
 ![image22.png](http://www.netfairy.net/content/uploadfile/201602/269a1456244883.png)
跟进 SetWindowLongA 处理函数，函数最终会调用 EndMenu 销毁菜单窗口并返回 0xFFFFFFFB
 ![image23.png](http://www.netfairy.net/content/uploadfile/201602/2b4a1456244888.png)
应用层代码返回 0xFFFFFFFB，执行流返回到内核 win32k! xxxMNFindWindowFromPoint 上下文
 ![image24.png](http://www.netfairy.net/content/uploadfile/201602/d3d71456244907.png)
此时的 eax 应该为 0xFFFFFFFB(一会我们调试的时候会看到)，函数接着往下执行，最终 0xFFFFFFFB 会做为 win32k! xxxMNFindWindowFromPoint 的返回值
5. win32k! xxxMNFindWindowFromPoint 执行完返回到 win32k!xxxHandleMenuMessages 上下文，对于前边 win32k! xxxMNFindWindowFromPoint 的返回值 0xFFFFFFB，程序没有严格校验它的返回值 ptagWND，导致后边把 0xFFFFFFFB 作为 ptagWND 传给 win32k! xxxSendMessage
 ![image25.png](http://www.netfairy.net/content/uploadfile/201602/2ba41456244910.png)
而不幸的是 win32k! xxxSendMessage 又会调用 ptagWND+0x60 处的函数，也就是
call [0xFFFFFFB+0x60]，即 call [0x5B]。并且应用层会事先调用 ZwAllocateVirtualMemory 在 0 地址分配内存并在 0x5B 处写入 shelllcode 的地址。
 ![image26.png](http://www.netfairy.net/content/uploadfile/201602/66d41456244913.png)
最后，结合前面的分析。给出一份直观的程序流程图

![image27.png](http://www.netfairy.net/content/uploadfile/201602/7f611456244918.png) 

**动态调试**
动态调试需要在应用程和内核层同时下断：
应用层：
004012E2 call    dword_40EBCC    ; ntdll!ZwAllocateVirtualMemory
004015FE call    ds:TrackPopupMenu
 ![image28.png](http://www.netfairy.net/content/uploadfile/201602/0f8e1456244919.png)
内核层：
BF938E11 call    xxxMNFindWindowFromPoint@12
BF9392F6 call    xxxSendMessage@16
 ![image29.png](http://www.netfairy.net/content/uploadfile/201602/c2ae1456244921.png)
其中 poi(poi(poi(fs:0x124)+0x44)+0x84)代表当前执行进程的 pid(win32.exe 的 pid 为 0xba4)，要进行 pid 判断是否为 win32.exe 进程，不然调试器老是断在别的进程。
1. 调用 ZwAllocateVirtualMemory 前
 ![image30.png](http://www.netfairy.net/content/uploadfile/201602/e7361456244921.png)
调用后执行完
004012fb e876050000      call    image00400000+0x1876 (00401876)
 ![image31.png](http://www.netfairy.net/content/uploadfile/201602/c2fb1456244931.png)
可以看到 0x5b 保存了提权的 shellcode 的 地址
……
00401830 55              push    ebp
00401831 8bec            mov     ebp,esp
00401833 83ec08          sub     esp,8
00401836 60              pushad
……
2. 继续运行到
 ![image32.png](http://www.netfairy.net/content/uploadfile/201602/ea101456244937.png)
控制权转到内核
3. 转到内核层，程序断在 win32k! xxxMNFindWindowFromPoint
 ![image33.png](http://www.netfairy.net/content/uploadfile/201602/a5881456244942.png)
4. win32k! xxxMNFindWindowFromPoint 又会调用 win32k! xxxSendMessage
![image34.png](http://www.netfairy.net/content/uploadfile/201602/220c1456244947.png)

5. 最终 win32k! xxxMNFindWindowFromPoint 的返回值是 0xFFFFFFFB
 ![image35.png](http://www.netfairy.net/content/uploadfile/201602/e4df1456244968.png)
6. 最终程序会转到 0x5B 保存的 0x00401830 执行
 ![image36.png](http://www.netfairy.net/content/uploadfile/201602/f31a1456244993.png)
记住，此时处于内核层，所以程序可以执行所有特权指令。当然，你完全可以直接在这里执行 shellcode。Win32.exe 把提权代码放到这里，可以把程序的权限提升至 system，然后转到用户层
004017EE call    ds:CreateProcessA  
由 CreateProcess 创建的 calc.exe 自然也是 system 权限了。

** ![image37.png](http://www.netfairy.net/content/uploadfile/201602/e83e1456245004.png)**

**总结**

有对函数返回值进行进一步利用的，如 call [retn+0xXX]，一定要严格校验返回值。以免攻击者构造恶意的代码控制返回值，进行进一步的漏洞利用。

**参考**
Windows 内核提权漏洞 CVE-2014-4113 分析报告：http://drops.wooyun.org/papers/3324
CVE-2014-4113 漏洞利用过程分析：http://drops.wooyun.org/papers/3331

CrowdStrike Discovers Use of 64-bit Zero-Day Privilege Escalation Exploit (CVE-2014-4113)：http://www.crowdstrike.com/blog/crowdstrike-discovers-use-64-bit-zero-day-privilege-escalation-exploit-cve-2014-4113-hurricane-panda/