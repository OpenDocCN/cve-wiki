# 【转】cve-2013-2094 perf_event_open 漏洞分析 - cgj - 博客园

> 原文：[`www.cnblogs.com/jiayy/p/4444825.html`](https://www.cnblogs.com/jiayy/p/4444825.html)

[cve-2013-2094](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-2094)是于 2013 年 4 月前后发现的 linux kernel 本地漏洞，该漏洞影响 3.8.9 之前开启了 PERF_EVENT 的 linux 系统。利用该漏洞，通过 perf_event_open 系统调用，本地用户可以获得系统的最高权限。

发生漏洞的是 linux kernel 中的 perf event 子系统，perf event 是 linux 系统中提供性能分析接口的子系统，于 2.6.31 之后引入 linux，之前被称为 Performance Counters for Linux (PCL)。通过 syscall 函数，用户可以调用 perf event 子系统提供的功能。由于 perf event 中的漏洞，用户可以通过精心构造的调用在任何内存地址写入数据，从而获得系统的最高权限。

引起 cve-2013-2094 漏洞的是位于[kernel/events/core.c](http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/events/core.c?id=8176cced706b5e5d15887584150764894e94e02f)文件中的 perf_swevent_init 函数。当使用 syscall 打开 perf_event 的 file descriptor 时，该函数被调用。

在受影响的版本中，core.c 关键部分内容如下：

```
static int perf_swevent_init(struct perf_event *event)
{
    int event_id = event->attr.config;  //dangerous!

    /*
 * ....omit some code...
 */

    if (event_id >= PERF_COUNT_SW_MAX)
        return -ENOENT;

    /*
 * .........omit........
 */

} 
```

由于将 event_id 定义为了有符号型整数，而后面又只检查了 event_id 的上界，所以当值为负时，即可越过检查，继续执行后面的代码

```
if (!event->parent) {
    int err;

    err = swevent_hlist_get(event);
    if (err)
        return err;

    atomic_inc(&perf_swevent_enabled[event_id]);
    event->destroy = sw_perf_event_destroy;
} 
```

其中，static_key_slow_inc 函数将某地址内容做 inc。

当使用负数值的 event_id 调用时，perf_swevent_enabled[event_id]将指向内核空间，如，在 Cent OS 64bit 系统中，当 event_id = -1 调用时，perf_swevent_enabled[event_id]的地址为:

```
0xfffffffffffffffe * 4 + 0xffffffff81f360c0 == 0xFFFFFFFF81F360B8 
```

该地址指向内核空间。

而当 file descriptor 关闭时，由于 event_id 定义为 u64 型，所以关闭时做 dec 时，地址指向的是用户空间。

所以当我们用负数值调用 perf_event_open 时，将可以在 perf_swevent_enabled 地址后面任意地址写入数据。

### x64 下的利用思路

x64 架构下，该漏洞比较容易利用，需要的信息更少，exploit 执行更快。方法简单来说是修改 IDT 中 int 4 的中断向量。x64 的 linux 中，Offset hight bits 和 Offset middle bits 是分别保存的，而将 int 4 的高位 0xffffffff 加 1 之后，中断向量将指向用户空间。而将 shellcode 放置在用户空间的这段内存上，即可获得系统最高权限。

具体来说，

1.  使用-1 和-2 调用，得到数组的偏移值。

    使用-1 和-2 调用，在 file descriptor 被关闭后，将使 0x38000000 附近的内存中某两个值减 1，通过搜索可以确定 perf_swevent_enabled 的编译值，并保存起来方便利用。

2.  将 shellcode 放入适当的用户空间内存中

    使用 sidt 指令可以获得 IDT 的地址，然后使用 mmap 将 shellcode 放入适当的地址。使 IDT 中的中断向量高位+1 之后落在 shellcode 上。

3.  修改 shellcode

    将 shellcode 中的 MARKER 修改为实际的 uid 和 gid 的保存地址。这样当 shellcode 运行时，即可找到 task_struct 和 thread_info 的地址，从而直接修改 real_cred 值，使当前进程获得 root 权限。

4.  修改 IDT

    从 1 中得到的信息，和 IDT 地址做计算，用计算好的负数值调用 perf_event_open ，可以使 int 4 的中断向量的高位 +1，从而指向 shellcode。

5.  int 0x4

    触发 shellcode

6.  在 shellcode 中提权，并弹 shell

    修改 real_cred 获得 root 权限，并修复被修改的 IDT 和其他部分内存，

    最后 execl("/bin/bash", "-sh", NULL);

    得到 root 权限的 shell

### 移植到 android 系统

Android 采用了 linux 内核，且更新较 linux 在 PC 上的发行版慢。即使 linux 内核在 2013 年 4 月 13 日修复了该漏洞，原生 Android 系统和大量基于 Android 系统的第三方 ROM 仍然存在该漏洞。

在 ARM linux 下，该漏洞仍然存在，仍然可以通过负数的 event_id 将任意内存地址+1。

但由于手机使用的 ARM 架构和 x64 架构下，linux 内核代码有所不同，该漏洞的利用方式也有所不同。

但是在 ARM linux 下，IDT 的结构如下

```
struct _idt_entry {
  unsigned short base_lo;
  unsigned short sel;
  unsigned char unused;
  unsigned char flags;
  unsigned short base_hi;
} __attribute__((packed)); 
```

注意到 base_hi 是 short 型，而 perf_swevent_enabled 是 int 型的数组，所以无法将地址修改 base_hi 到用户空间地址。

所以在 ARM 下我们没有修改 IDT，而是在 linux 内核中寻找合适的函数指针。反复调用 perf_event_open，将函数指针的值加到用户能控制的地址，然后调用函数。ptmx_fops 结构中的 fsync 函数指针被初始化为 0，且不需要特殊的权限即可调用。

利用的基本思路是：

```
/* file_operations 结构 fsync 函数的偏移为 56 */
int target = pmtx_ops + 56;
int payload = -((perf_table - target)/4)

struct perf_event_attr event_attr;
event_attr.config = payload;
...

/* 反复调用将 fsync 的值修改为合适的值 */
syscall(__NR_perf_event_open, &event_attr, 0, -1, -1, 0);
...

/* 调用 */
int ptmx = open("/dev/ptmx", O_RDWR);
fsync(ptmx); 
```

但是，linux 系统中单个进程能够打开的 file descriptor 数量是有限制的，所以需要 fork 出足够多的进程，反复修改。

### 受影响的 ROM

目前，测试了三款国内比较流行的手机，共 4 个 ROM，该漏洞的情况如下：

|| Nexus 4 官方 Rom 4.2.1|| 成功 || || Nexus 4 Cyanogenmod 10.1.2|| 内核已修补 || || Lenove 860i 官方 ROM || 内核不支持 perf_event || || Huawei U9508 官方 ROM || 内核不支持 perf_event ||

# [CVE-2013-2094 exploit for Android ](http://retme.net/index.php/2014/04/02/CVE-2013-2094.html)