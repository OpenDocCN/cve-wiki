# Shiro(CVE-2020-17523)权限绕过分析 - admin-神风 - 博客园

> 原文：[https://www.cnblogs.com/wh4am1/p/14397630.html](https://www.cnblogs.com/wh4am1/p/14397630.html)

### 一、前言

Apache Shiro是一个强大且易用的Java安全框架，执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API，您可以快速、轻松地获得任何应用程序，从最小的移动应用程序到最大的网络和企业应用程序。

当使用Spring配置Shiro的Filter时候，就有可能导致权限绕过的情况。

### 二、影响范围

Apache Shiro < 1.7.1

### 三、漏洞测试

本次实验通过SpringBoot搭建的环境，配置了Shiro的Filter路径，实验环境：https://github.com/jweny/shiro-cve-2020-17523

![](../Images/4ea71fc9111f4f58685165e40cb05071.png)

 记住此处的authc对应的key是"/admin/*"

所以漏洞的poc就是：http://localhost:9090/admin/%20

### 四、漏洞分析

竟然是分析，我就从详细讲解下Shiro的Filter处理过程，先来看到刚才的Bean是通过ShiroFilterFactoryBean类来配置的Config属性，直接跟进去就能看到其中的getObject方法

getObject方法是实现了FactoryBean接口的方法

![](../Images/da3eb10f88e825fc924f76967b6f6dd3.png)

而这个instance变量是属于AbstractShiroFilter类

![](../Images/70196505499661a04bcefe1e52f7460b.png) 

 再来看看这个createInstance的方法

```
protected AbstractShiroFilter createInstance() throws Exception {

        log.debug("Creating Shiro Filter instance."); //获取shrio的安全管理容器
        SecurityManager securityManager = getSecurityManager(); if (securityManager == null) {
            String msg = "SecurityManager property must be set."; throw new BeanInitializationException(msg);
        } if (!(securityManager instanceof WebSecurityManager)) {
            String msg = "The security manager does not implement the WebSecurityManager interface."; throw new BeanInitializationException(msg);
        } //获取过滤链管理器，就是shrio的全部过滤器，里面保存着路径和对应的过滤器或者过滤链
        FilterChainManager manager = createFilterChainManager(); //Expose the constructed FilterChainManager by first wrapping it in a // FilterChainResolver implementation. The AbstractShiroFilter implementations // do not know about FilterChainManagers - only resolvers: //初始化Ant风格的url匹配器，传入上面的过滤链管理器
        PathMatchingFilterChainResolver chainResolver = new PathMatchingFilterChainResolver();
        chainResolver.setFilterChainManager(manager); //Now create a concrete ShiroFilter instance and apply the acquired SecurityManager and built //FilterChainResolver.  It doesn't matter that the instance is an anonymous inner class //here - we're just using it because it is a concrete AbstractShiroFilter instance that accepts //injection of the SecurityManager and FilterChainResolver: //初始化门户过滤器，所有请求都应该经过这个过滤器
        return new SpringShiroFilter((WebSecurityManager) securityManager, chainResolver);
    }
```

注意SpringShiroFilter这个filter，它是所有请求的入口类
然后再来注意它的doFilterInternal方法，其中有个executeChain方法，根据request获取对应的chain，进行拦截请求。

![](../Images/23b5253afb6065cbaa0e9514e051ec7d.png)

 这里就是过滤器的处理链开始的地方，从这里就可以开始下断点开始往下跟

![](../Images/5599c22429136612a705005013bdbbda.png)

 再往下看就能发现调用了getChain的方法

![](../Images/3196ab38b8e1444d73b935b08023d948.png)

 跟进后程序就跳进org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain

![](../Images/f75a57d7dab3dd474c4fb5ba0e22a1fa.png)

 而关键Sink点就在这个pathMathes方法中

![](../Images/f4476162b00099821571e70f375f0b94.png)

 跟进方法中，会找到org.apache.shiro.util.AntPathMatcher#doMatch方法

方法中通过tokenizeToStringArray方法分别获取需要匹配的格式路径和URL路径

![](../Images/898cd464aef531191ef710862e5762f8.png)

 至此返回false，但由于Spring的Mapping匹配路径是/admin路径

![](../Images/902c48c632fc5e98ae919c417623522e.png)

 所以导致权限绕过

![](../Images/030fe56117002d0e96a7ed6fed7401c5.png)