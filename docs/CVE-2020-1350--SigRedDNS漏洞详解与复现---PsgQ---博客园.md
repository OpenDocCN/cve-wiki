# CVE-2020-1350--SigRedDNS 漏洞详解与复现 - PsgQ - 博客园

> 原文：[`www.cnblogs.com/PsgQ/p/14806195.html`](https://www.cnblogs.com/PsgQ/p/14806195.html)

# 漏洞简介

在 Windows 上，DNS 服务器是域控制器，其管理员是 Domain Admins 组的一部分。默认情况下，Domain Admins 组是已加入域的所有计算机上 Administrators 组的成员，包括域控制器[[8]](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups)。如果利用得当，攻击者可以在易受攻击的系统上远程执行代码，并获得 Domain Admin 权限，从而有效地损害了整个公司的基础架构。

**DNS 服务器-dns.exe 负责在安装了 DNS 角色的 Windows 服务器上回答 DNS 查询。**

CVE-2020-1350 是 DNS.exe 在处理畸形 DNS Sig 消息时，由于对数据包的字段校验不严格，导致了整型溢出。DNS SIG 消息中包含对 DNS 记录集合的数字签名，DNS 记录集合就是一种名字相同，或者类型相同的 DNS 消息集合。

**漏洞类型：**整数溢出导致基于堆的缓冲区溢出

# 攻击流程

![aa91b3_adb7b85135e44f38bcca549851f38d68_mv2](img/6fbbf66713c823068687461d6af30133.png)

攻击者可以配置一个恶意的域名 evildomain.com，该域名的 DNS 指向的 DNS 服务器作为本次攻击的目标。

> 1.  当客户端查询 evildomain.com 的 DNS 记录；
> 2.  目标 DNS 服务器向根域名服务器查询 evildomain.com 的 NS 记录；
> 3.  根域名服务器告诉目标 DNS，evildomain.com 的权威 DNS 服务器是 3.3.3.3，并该记录缓存起来；
> 4.  客户端向目标服务器查询 evildomain.com 的 Sig 记录；
> 5.  目标服务器将请求转发给权威 DNS 服务器;
> 6.  权威 DNS 服务器返回畸形 Sig 查询结果;

目标 DNS 服务器处理 SigQuery 的畸形消息时,将此消息缓存到自己的记录中，触发漏洞。

# 漏洞函数

简言之就是**整数溢出后导致堆溢出**，将该漏洞抽象为以下模型：

```
void Examples(char *in){  
    unsigned short len_p1 = len ( in.p1);  unsigned short len_p2  =len ( in.p2);
    unsigned short len_p  = len_p1 + len_p2;  
    char * buf = (char *)malloc(len_p);  
    memcpy(buf, in.p1, len_p1); } 
```

问题就出在 len_p 的计算上，假设 len_p1 = 0xFFD0，len_p2 = 0x40，相加后高位数据被丢弃，那么 `0xFFD0 + 0x40 = 0x10010 = 0x10`，所以**实际分配的内存是 0x10 而不是 0x10010**，而之后往 0x10 的空间内拷贝 0xFFD0 长度的数据，自然造成了内存溢出。

而在`dns.exe!SigWireRead`函数里面也有类似的溢出漏洞，如图所示第 11 行：

![aa91b3_ffb865d47c0b4f54925b8c2acb34b036_mv2](img/2c71f1af58f3218ad12e14e4c9dd2990.png)

漏洞成因如下：ushort 类型，为无符号 16 位类型。RR_AllocateEx 分配的大小只有 16 个 bit，大小为 0~65535，所以只要构造 size 大于 65535，造成整数溢出，而系统就会分配一个比实际数据量小的堆块，进而造成堆溢出，将整数溢出转化成堆溢出漏洞。

# 漏洞利用：

因此，触发此漏洞所需的全部操作就是让受攻击的 DNS 服务器向我们查询 SIG 记录，并使用长签名(长度&>=64KB)对其作出 SIG 响应。但是，UDP 上的 DNS 的大小限制为 512 字节(如果服务器支持 EDNS0，则为 4096 字节)。在任何情况下，这都不足以触发漏洞。

CheckPoint 找到一种方法可以突破上述限制：**UDP 响应时将 DNS 头部的 `TC` 标志置 1**，表示被截断，之后客户端便会尝试用 TCP 协议和服务器建立连接，并通过 TCP 协议传递数据。由于消息的前两个字节表示其长度，因此 TCP 上的 DNS 中消息的最大大小表示为 16 位，因此限制为 64KB。TCP 协议在 53 端口上可**传输长度最大为 65535 的 DNS 数据**，这无疑给该漏洞创造了先决条件。如下图：红框中的表示 TC 置位字段：

![image-20210524201342778](img/5528a929a186465a19c29e86cb0ba8ec.png)

但是，即使是长度为 65,535 的消息也不足以触发漏洞，因为消息长度包括报头和原始查询。计算传递给 RR_AllocateEx 的大小时不考虑此开销。那么，该漏洞如何触发呢？继续往下看，首先了解一下域名编码和域名压缩。

## 域名编码

eg:对于完整的一个域名 www.baidu.com,需要 14 个字节：

\3 w w w \5 b a i d u \3 c o m

![img]

可以看到第一个字节 是 3，表示之后会有 3 个字节的字符。

## 域名压缩

域名压缩是 DNS 协议节省空间的一种方式，因为请求中的域名字符会频繁出现在响应包的内，故采用了一种标志+偏移的格式来压缩域名。压缩方式很简单：`1 + 1 + offset`，即最高 2bit 位为 1 时代表了将采用域名压缩，剩余的组合为偏移值（基地址为 DNS 头），如下图：响应区域中的 Name 字段为 `0xc00c`，明显是被压缩过的，最高 2bit 位是标志，剩余的 bit 位组合得到的值为 0xc，所以当前 Name 表示的字符串在 DNS 头部向后偏移 0xc 的位置，也就是图中红框中 0x3 开始（**0x50 表示 DNS 头起始位置**）的域名 `bbs.pediy.com`。

![879291_BK62PXN5P34V87F (1)](img/439ccfa14ea0a8e81624850d93a4bb31.png)

因此，可以将**域名压缩的偏移值指向一片可控的区域**，而不是指向查询时域名，就完全有可能使得域名的长度大大增加，比如在这里修改为`c0 0d`,那么表示域名从 0x62 开始，说明后面有 0x62 个字节的字符，然后依次。**这样就使得源代码第 11 行中的 sigName.Length 的大小变大。**

**注意：DNS name 长度最大为 0XFF**

所以，可以在不改变原来数据包大小的情况下，将 sigLength+sigName.length+0x16 的大小，大于 65535，造成整数溢出。分配一个小的空间缓存，然后导致堆溢出。

# POC 分析和漏洞复现

部分 poc 代码，大体就是构造 sig 响应消息。具体 POC，在这里：[`github.com/maxpl0it/CVE-2020-1350-DoS`](https://github.com/maxpl0it/CVE-2020-1350-DoS)

![image-20210524204424343](img/0e772abcbe341b90575938fcda06dca2.png)

## 实验环境：

Windows Server 2012 R2 192.168.29.138

KaLi Linux 192.168.29.135

## 复现过程：

1.在 windows server 2008 安装 dns 服务器，并配置静态 ip

2.在 kali 中运行脚本，开启 ibrokethe.net 域名的恶意服务器，这里的 ibrokethe.net 表示恶意域名，也可以代替为其他域名。

```
sudo python sigred_dos.py ibrokethe.net 
```

3.在受害者服务器配置转发器，转发器 ip 为 kali 机的 ip。

![image-20210525165703551](img/6a8ce181a56099bb936da99325bef257.png)

4.在受害者服务器使用 nslookup 命令查询 9.ibrokethe.net：

```
nslookup -type=sig 9.ibrokethe.net 127.0.0.1 
```

5.查看 kali，发现会发现收到了一个 UDP 连接，又收到了一个 TCP 连接。

![image-20210525165901274](img/548187d230cd80f4f712efc8222bd0e8.png)

###### 最后要说的是，复现过程采用了 Windows DNS 服务器的条件转发器，略过了向权威 NS 查询的步骤，直接向恶意 DNS 服务器发出查询。

## 复现结果：

抓包结果如下：

![image-20210524205603806](img/b5507d128dfd2b74e8c8962d92d042d2.png)

由于本地无法解析“ibrokethe.net”，因此会以 UDP 协议向恶意服务器 kali 发送 DNS 查询，也就是 kali 收到的第一个 UDP 连接。恶意服务器查到了该域名，就向受害者发送响应包，设置 TC 位，通知受害者采用 TCP 重发原来的查询请求，并允许返回的响应报文超过 512 个字节。这是第二个 DNS 包。然后进行三次握手，受害者再次以 TCP 协议发送请求，这就是 kali 收到的 TCP 连接。之后，恶意服务器就可以利用 TCP 传输大于 64KB 的响应包发给受害者，触发漏洞，造成堆溢出。

然后，就可以进行远程代码执行等操作了。

可以看到在复现的过程，产生堆溢出，dns.exe 进程发生崩溃，从而产生 DOS 攻击。如下图：

![879291_P2ZBQGC4C59M8U6](img/d944fa6c2be25f013df33b105aa87bf9.png)

# 漏洞修复

**临时修复方案**

修改注册表，限制 tcp 包的长度,TcpReceivePacketSize 的值为`0xFF00`

```
 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\DNS\Parameters 
  DWORD = TcpReceivePacketSize 
  Value = 0xFF00 
```

**注意：**必须重新启动 DNS 服务才能生效。

**补丁更新**

![17](img/460d154f2660158ff4b541c98126601b.png)

**可看到右图 24 行，在前面对整数溢出做了个判断，即 sigLength+sigName.Length 的值要大于等于 sigLength**

# 总结:

协议方面多多少少都会有我们所疏忽的问题，对于 dns.exe 开发者，最开始并未考虑到最大可以超过 65535，造成溢出，代码并没有问题，造成该漏洞的关键点，主要是因为域名压缩。往往很多个疏忽点，凑到了一起就成了攻击者利用的漏洞。

# 参考链接：

[CVE-2020-1350 Windows Server DNS 漏洞复现](https://qiacuhome.cn/2020/12/08/cve-2020-1350/#toc-heading-3)

[漏洞利用剖析：带有 CVE-2020-1350 SIGRed 的 RCE](https://www.graplsecurity.com/post/anatomy-of-an-exploit-rce-with-cve-2020-1350-sigred)

[CVE-2020-1350: Windows DNS Server 蠕虫级远程代码执行漏洞分析](https://cert.360.cn/report/detail?id=5b7082dae4756f361d43a5efde233edd)
[Windows DNS server 从 cve-2020-1350 到内存泄露](http://v-v.space/2020/09/26/dns-overflow-and-memLeak/)