# shiro < 1.6.0 的认证绕过漏洞分析(CVE-2020-13933) - ph4nt0mer - 博客园

> 原文：[`www.cnblogs.com/ph4nt0mer/p/13535999.html`](https://www.cnblogs.com/ph4nt0mer/p/13535999.html)

## 0x00 什么是 shiro

Apache Shiro 是一个强大且易用的 Java 安全框架,执行身份验证、授权、密码和会话管理。使用 Shiro 的易于理解的 API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。

## 0x01 环境搭建

*   springboot
*   shiro1.5.3

1、去`https://start.spring.io/`使用 springboot 脚手架搭建一个 java8 的 springboot 项目

2、用 IDEA 打开该项目，目录结构与文件如下：
![](img/4a9832b767a4881f7048f60682d1d7b2.png)

3、创建`MyRealm`、`NameController`、`ShiroConfig`三个 class 文件。

4、pom.xml 增加对应的`dependency`

```
<?xml version="1.0" encoding="UTF-8"?>
<project  
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.3.3.RELEASE</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.example</groupId>
	<artifactId>demo</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>demo</name>
	<description>Demo project for Spring Boot</description>

	<properties>
		<java.version>1.8</java.version>
	</properties>

	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<optional>true</optional>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
			<exclusions>
				<exclusion>
					<groupId>org.junit.vintage</groupId>
					<artifactId>junit-vintage-engine</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>org.apache.shiro</groupId>
			<artifactId>shiro-web</artifactId>
			<version>1.5.3</version>
		</dependency>
		<dependency>
			<groupId>org.apache.shiro</groupId>
			<artifactId>shiro-spring</artifactId>
			<version>1.5.3</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-web</artifactId>
			<version>5.2.5.RELEASE</version>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>servlet-api</artifactId>
			<version>2.5</version>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<fork>true</fork>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project> 
```

ShiroConfig.java 代码如下：

```
package com.example.demo;

import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.spring.web.ShiroFilterFactoryBean;
import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.LinkedHashMap;
import java.util.Map;

@Configuration
public class ShiroConfig {
    @Bean
    MyRealm myRealm(){
        return new MyRealm();
    }
    @Bean
    SecurityManager securityManager(){
        DefaultWebSecurityManager manager = new DefaultWebSecurityManager();
        manager.setRealm(myRealm());
        return manager;
    }
    @Bean
    ShiroFilterFactoryBean shiroFilterFactoryBean(){
        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();
        bean.setSecurityManager(securityManager());
        bean.setLoginUrl("/login");
        bean.setSuccessUrl("/index");
        bean.setUnauthorizedUrl("/unauthorizedUrl");
        Map<String,String> map= new LinkedHashMap<>();
        map.put("/doLogin/","anon");
        map.put("/test/*","authc");
        bean.setFilterChainDefinitionMap(map);
        return bean;

    }
} 
```

NameController 代码如下：

```
package com.example.demo;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class NameController {

    @GetMapping("/test/{name}")
    public String test(@PathVariable String name){
        return "s1111";
    }

    @GetMapping("/test/")
    public String test2(){
        return "test2";
    }
} 
```

MyRealm 代码如下:

```
package com.example.demo;

import org.apache.shiro.authc.*;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;

public class MyRealm extends AuthorizingRealm {
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        return null;
    }

    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        return null;
    }
} 
```

## 0x02 poc 测试

![](img/351ef52a2ab89101e10d536a761045a3.png)

![](img/6e2c12a9c133eb22a08cbcf35eb9b2d2.png)

原本需要认证的 test/{name}可以访问到了
![](img/cefffb830c7cf332ca034d714dd58317.png)

证明漏洞利用成功。

## 0x03 漏洞原理分析

根据 shiro 历史上的认证绕过漏洞，本质问题就是 springboot 对 url 的处理和 shiro 的处理不一致导致的认证绕过。
其中 shiro 的 url 处理的问题都出在`org/apache/shiro/web/util/WebUtils.java`类下面，在 return

```
 public static String getPathWithinApplication(HttpServletRequest request) {
        return normalize(removeSemicolon(getServletPath(request) + getPathInfo(request)));
    } 
```

断点，
然后我们去 springboot 的处理 url 的地方进行断点，`org/springframework/web/util/UrlPathHelper.java`。

在 return uri；进行

```
 private String decodeAndCleanUriString(HttpServletRequest request, String uri) {
		uri = removeSemicolonContent(uri);
		uri = decodeRequestString(request, uri);
		uri = getSanitizedPath(uri);
		return uri;
	} 
```

断点。

访问/test/%3bname，先来到 shiro 的 url 处理块，
![](img/4056f3b5c88495395eed626072b6fd56.png)
根据图纸可知，获取到的 url 在处理前已经进行了一次 urldecode。然后在进入`removeSemicolon`操作，最后结果集在交给`normalize`操作。

根据计算器可知 removeSemicolon 会把 url 里;后面的内容给删除(包括;)
![](img/09841c210d66d056eaaf772eff341062.png)
跟进 removeSemicolon 看看。

实现代码如下:

```
 private static String removeSemicolon(String uri) {
        int semicolonIndex = uri.indexOf(';');
        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);
    } 
```

确实是把;后面的内容给删除(包括;)了。

一路 F8，最后果然把/test/赋值给 requestURI 变量了。
![](img/90e28e042bccc41ac95464a803ed99f4.png)

根据测试当初访问/test/
![](img/6e2c12a9c133eb22a08cbcf35eb9b2d2.png)
可以看到，如果 test 目录的话，是默认有权限访问的，但是/test/后面的路由是需要验证的。
![](img/351ef52a2ab89101e10d536a761045a3.png)
接着我们来到 springboot，看看 springboot 是怎么处理 URL 的问题。
![](img/c3496a3921b0a0b32c4a5686dc63baa4.png)
uri 取到的是`/test/;name`，可以看到 springboot 对 url 做了三个操作后才返回的，`removeSemicolonContent`,`decodeRequestString`,`getSanitizedPath`。

*   removeSemicolonContent 是把（url 未解码前的 uri 里的;后面的内容给删除）
*   decodeRequestString 把 uri 进行 urldecode 编码
*   getSanitizedPath 是把"//" 替换成 "/"

这是简单对比下 shiro 的对 url 的操作顺序:

*   uri 进行 urldecode
*   uri 删除;后面的内容，包括;

因为 shiro 的处理和 springboot 的处理顺序不同，导致我们构造的 poc 在 shiro 侧理解的是访问的/test/，/test/我们本身就没有限制权限，放过了这个原本需要认证权限的请求，而 springboot 侧则是访问的是/test/;name，然后 springboot 把;name 当做一个字符串去寻找对应的路由，返回了对应的字符串。

## 0x04 总结

此漏洞主要是两个组件之间对某个关键信息处理的逻辑未进行统一约定，可以理解成前后端对同一个信息处理的不同步导致的安全漏洞。

同样的认证绕过在 shiro 历史上出现过好几次，具体可以去参考链接学习。

## 0x05 参考

*   [`www.freebuf.com/vuls/231909.html`](https://www.freebuf.com/vuls/231909.html)
*   [`xlab.tencent.com/cn/2020/06/30/xlab-20-002/`](https://xlab.tencent.com/cn/2020/06/30/xlab-20-002/)